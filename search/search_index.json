{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hey there! Welcome to the PyTermGUI documentation! For a general overview of the framework, follow the navigation at the bottom. For a set of working examples, check out the walkthroughs section. For a complete look at the API, see our reference ! So what is a Terminal User Interface (or TUI) anyways? A Terminal User Interface is, in general terms, a GUI in your terminal. Due to the terminal's attributes & limitations it can only use plain text to display content, and has to arrange itself on the terminal's character grid. In effect, this means terminal applications are: More constrained, which can often lead to more interesting solutions around known problems More standardized (though not enough) Much faster to execute Way cooler lookin' If all that is true, why are TUIs so rare? Historically, you had 2 options when writing a TUI: Create your own framework with its own rendering pipeline Use curses or ncurses Neither of these are simple to do; drawing in the terminal requires knowledge of a bunch of scattered standards and precedents, which, for the most part, are only available through archaic documentation. Things have gotten a lot better in recent years. Projects like Jexer and notcurses have shown how capable terminals are, and projects like bubbletea and tui-rs have made simplified and modernized TUI creation. How do we help the situation? PTG provides abstractions for the low-level interactions with the terminal, and a modular widget system that is built ontop. Our goals are the following: Versatility Expressive, readable but compact code No pointless abstractions Minimal dependencies Because of the way the framework is built, you can implement the input-key-mouse-draw loop used internally by WindowManager in {insert linecount} lines! Widget layouts are explicit from the syntax of their creation. Widgets are rendered line-by-line, using the plain strings they return. There is built-in support for keyboard & mouse inputs on all widgets, as well as the underlying low-level API that is used to make it all work. This means that you, the user, can create TUI applications with workflows that rival the web in simplicity, without having to deal with the massive fragmentation, framework war, and shudders CSS.","title":"Welcome"},{"location":"#hey-there","text":"Welcome to the PyTermGUI documentation! For a general overview of the framework, follow the navigation at the bottom. For a set of working examples, check out the walkthroughs section. For a complete look at the API, see our reference !","title":"Hey there!"},{"location":"#so-what-is-a-terminal-user-interface-or-tui-anyways","text":"A Terminal User Interface is, in general terms, a GUI in your terminal. Due to the terminal's attributes & limitations it can only use plain text to display content, and has to arrange itself on the terminal's character grid. In effect, this means terminal applications are: More constrained, which can often lead to more interesting solutions around known problems More standardized (though not enough) Much faster to execute Way cooler lookin'","title":"So what is a Terminal User Interface (or TUI) anyways?"},{"location":"#if-all-that-is-true-why-are-tuis-so-rare","text":"Historically, you had 2 options when writing a TUI: Create your own framework with its own rendering pipeline Use curses or ncurses Neither of these are simple to do; drawing in the terminal requires knowledge of a bunch of scattered standards and precedents, which, for the most part, are only available through archaic documentation. Things have gotten a lot better in recent years. Projects like Jexer and notcurses have shown how capable terminals are, and projects like bubbletea and tui-rs have made simplified and modernized TUI creation.","title":"If all that is true, why are TUIs so rare?"},{"location":"#how-do-we-help-the-situation","text":"PTG provides abstractions for the low-level interactions with the terminal, and a modular widget system that is built ontop. Our goals are the following: Versatility Expressive, readable but compact code No pointless abstractions Minimal dependencies Because of the way the framework is built, you can implement the input-key-mouse-draw loop used internally by WindowManager in {insert linecount} lines! Widget layouts are explicit from the syntax of their creation. Widgets are rendered line-by-line, using the plain strings they return. There is built-in support for keyboard & mouse inputs on all widgets, as well as the underlying low-level API that is used to make it all work. This means that you, the user, can create TUI applications with workflows that rival the web in simplicity, without having to deal with the massive fragmentation, framework war, and shudders CSS.","title":"How do we help the situation?"},{"location":"exports/","text":"You may have noticed the screenshots used throughout this documentation. Fun fact: They are all generated using the module! Some code is run, and its result is then displayed in an SVG image. To do this, we use the Termage module, which in turn uses the Terminal.record method, and then calls Recorder.export_svg on the resulting terminal. To use the recording & export API, simply enter a Terminal.record context, run some code & save the recording output: Python Output from pytermgui import ColorPicker , pretty , terminal , tim tim . alias ( \"code\" , \"@black #auto dim\" ) with terminal . record () as recording : tim . print ( \"[italic]Everything[/] you print will be captured!\" ) tim . print () tim . print ( \"By default, only [code]PTG[/]'s prints functions are affected,\" + \" \\n but by overwriting [code]sys.stdout.write[/] you can capture any Python output.\" ) text.termage-0 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-0-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/exports1.py Everything you print will be captured! By default, only PTG 's prints functions are affected, but by overwriting sys.stdout.write you can capture any Python output. You can even hide the \"window\"'s title bar, and get a rectangular image with just your code's output by specifying chrome=False while exporting: text.termage-1 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-1-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } Everything you print will be captured! By default, only PTG 's prints functions are affected, but by overwriting sys.stdout.write you can capture any Python output. Note You can also export as plain HTML! We can't easily show it here (without manually pasting it in) since Termage and its plugin only wrap the SVG API. For more information, check out the Termage module!","title":"SVG & HTML exports"},{"location":"future/","text":"The future of this library I intend on growing this library as long as there are ways to improve it; life might get in the way at some points, but I want to keep using the project in my personal tooling, and I know many people count on it's reliability for their own. The current version of the module is pretty stable in terms of the API. There is only a handful of upcoming API changes, some of which will unfortunately have to roll over a major version. This page exists as a sort of heads-up note, so users know what to expect. I will try to keep this up to date whenever plans change, or tasks are complete. 8.0.0 - The (second) widget update The next major release is, according to my plans, the last one for a long time. It will be a modernization of a lot of APIs, and it's main purpose is to bundle all the minor but compatibility breaking changes together into a single release. The end goal of this version is to make it so implementing the 7GUIs is simple, and can be done by most newcomers to the library. Planned changes A new, more stable Container.get_lines implementation Better API for aligning widgets within containers A rethink of the sizing system -- likely implementing the layout system's dimensions , and possibly removing static sizes Better implementation of heights, one that is more consistent with widths Better buttons: checkboxes with labels, new base button class with more customization and nicer styling and rethink of toggle Better, more customizable layouts within containers: probably a better splitter, possibly allowing Containers to use layouts 8.1.0 - A better YAML styling engine The current YAML styling works, but doesn't support quite as much as I would like it to. CSS, as as hideous as it can be does some things well: being able to apply styles to specific elements individually, swapping style groups on the fly and integration with the scripting language, just to name a few. With this update, our YAML files should do more or less the same as CSS, but in a more thought-out manner, with clear and readable syntax. An example PTG YAML file could be the following: styles.ptg aliases : main-background : '@surface-1' main-foreground : 'surface+1' config : * : background : 'main-background' Window is_modal? : borders : 'DOUBLE' styles.border__corner : 'error' Button .confirm : styles.normal : background : '@success-2' foreground : 'success' styles.hover : background : '@success' foreground : 'success+1' styles.active : background : '@success+1' foreground : 'success+2' from pytermgui import Stylesheet styles = Stylesheet . load ( \"styles.ptg\" , auto_reload = True ) Planned changes Re-wiring _IdManager to act as the style managment overlord Likely re-writing the file_loaders module. I hope to keep the current API alive, with massive deprecation notices Moving some of the default widget configuration into a default.yaml file 8.X.0 : A better composition The current compositor isn't super smart. It does way too much writes to the terminal, and thus it makes things flickery and unstable on lower power emulators. A fix to this is already far in the works, and involves a resizable matrix of screen coordinates to their content. I want this update to happen seemlessly on the user's side, but this makes things a lot more difficult. Planned changes Add a canvas class that handles emulating the terminal's display Change compositor to write to a canvas, and to only update the terminal with the canvas' contents","title":"Future"},{"location":"future/#the-future-of-this-library","text":"I intend on growing this library as long as there are ways to improve it; life might get in the way at some points, but I want to keep using the project in my personal tooling, and I know many people count on it's reliability for their own. The current version of the module is pretty stable in terms of the API. There is only a handful of upcoming API changes, some of which will unfortunately have to roll over a major version. This page exists as a sort of heads-up note, so users know what to expect. I will try to keep this up to date whenever plans change, or tasks are complete.","title":"The future of this library"},{"location":"future/#800-the-second-widget-update","text":"The next major release is, according to my plans, the last one for a long time. It will be a modernization of a lot of APIs, and it's main purpose is to bundle all the minor but compatibility breaking changes together into a single release. The end goal of this version is to make it so implementing the 7GUIs is simple, and can be done by most newcomers to the library.","title":"8.0.0 - The (second) widget update"},{"location":"future/#planned-changes","text":"A new, more stable Container.get_lines implementation Better API for aligning widgets within containers A rethink of the sizing system -- likely implementing the layout system's dimensions , and possibly removing static sizes Better implementation of heights, one that is more consistent with widths Better buttons: checkboxes with labels, new base button class with more customization and nicer styling and rethink of toggle Better, more customizable layouts within containers: probably a better splitter, possibly allowing Containers to use layouts","title":"Planned changes"},{"location":"future/#810-a-better-yaml-styling-engine","text":"The current YAML styling works, but doesn't support quite as much as I would like it to. CSS, as as hideous as it can be does some things well: being able to apply styles to specific elements individually, swapping style groups on the fly and integration with the scripting language, just to name a few. With this update, our YAML files should do more or less the same as CSS, but in a more thought-out manner, with clear and readable syntax. An example PTG YAML file could be the following: styles.ptg aliases : main-background : '@surface-1' main-foreground : 'surface+1' config : * : background : 'main-background' Window is_modal? : borders : 'DOUBLE' styles.border__corner : 'error' Button .confirm : styles.normal : background : '@success-2' foreground : 'success' styles.hover : background : '@success' foreground : 'success+1' styles.active : background : '@success+1' foreground : 'success+2' from pytermgui import Stylesheet styles = Stylesheet . load ( \"styles.ptg\" , auto_reload = True )","title":"8.1.0 - A better YAML styling engine"},{"location":"future/#planned-changes_1","text":"Re-wiring _IdManager to act as the style managment overlord Likely re-writing the file_loaders module. I hope to keep the current API alive, with massive deprecation notices Moving some of the default widget configuration into a default.yaml file","title":"Planned changes"},{"location":"future/#8x0-a-better-composition","text":"The current compositor isn't super smart. It does way too much writes to the terminal, and thus it makes things flickery and unstable on lower power emulators. A fix to this is already far in the works, and involves a resizable matrix of screen coordinates to their content. I want this update to happen seemlessly on the user's side, but this makes things a lot more difficult.","title":"8.X.0: A better composition"},{"location":"future/#planned-changes_2","text":"Add a canvas class that handles emulating the terminal's display Change compositor to write to a canvas, and to only update the terminal with the canvas' contents","title":"Planned changes"},{"location":"inspect/","text":"PyTermGUI provides a pretty nifty inspection utility, inspect ! It's useful to figure out the signature of functions, inspect their general shape & docstrings. text.termage-2 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-2-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/inspect1.py \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502 pytermgui.widgets.containers.Container \u2502 \u2502 Located in /Users/lapis/Code/Projects/pytermgui/pytermgui/widgets/containers.py \u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 class Container (*widgets: Any , **attrs: Any ) -> None : A widget that displays other widgets, stacked vertically. def bind (self, key: str , action: BoundCallback , description: Optional [ str ] = None ) -> None : Binds an action to a keypress. def center (self, where: CenteringPolicy | None = None , store: bool = True ) -> Container : Centers this object to the given axis. def contains (self, pos: tuple [ int , int ]) -> bool : Determines whether widget contains `pos`. def copy (self) -> Widget : Creates a deep copy of this widget def debug (self) -> str : Returns a string with identifiable information on this widget. def execute_binding (self, key: Any , ignore_any: bool = False ) -> bool : Executes a binding on self, and then on self._widgets. The easiest way to use it is by running ptg -i or ptg --inspect with a fully qualified name. This will create an Inspector object for the given name, and print it. You can also give the same function an expression to evaluate. This might be useful if you want to know the type & methods of an object that is the result of some function or method. The more general way to access the API is by using the inspect function from within Python. You can give it any object, and it will give you as much information as it can found out from the signature & source code. You can also play around with an interactive version of the tool by running ptg --app inspect , which will give you a nice UI to play around with. text.termage-3 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-3-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/inspect2.py \u2554 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u2557 \u2551 Inspector \u2551 \u2551 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2551 \u2551 \u2551 \u2551 \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2551 \u2551 \u2502 pytermgui.widgets.boxes.Box \u2502 \u2551 \u2551 \u2502 Located in /Users/lapis/Code/Projects/pytermgui/pytermgui/widgets/boxes.py \u2502 \u2551 \u2551 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 \u2551 \u2551 class Box (lines: list [ str ], content_char: str = x): \u2551 \u2551 Class for defining border & corner styles \u2551 \u2551 \u2551 \u2551 `lines` should be `list[str]` of length 3, such as: \u2551 \u2551 \u2551 \u2551 ```python3 \u2551 \u2551 lines = [ \u2551 \u2551 \".---.\", \u2551 \u2551 \"| x |\", \u2551 \u2551 \"`---`\", \u2551 \u2551 ] \u2551 \u2551 ``` \u2551 \u2551 \u2551 \u2551 The length of individual lines is arbitrary, only limitation is \u2551 \u2551 that the top & bottom border characters should occur most often in \u2551 \u2551 their respective lines. \u2551 \u2551 \u2551 \u2551 You can set corners to be of any length, their end is calculated by \u2551 \u2551 finding the index of the most often occuring character, which is assumed \u2551 \u2551 to be the border character. \u2551 \u2551 \u2551 \u2551 Top & bottom borders are currently limited in length to 1, but sides \u2551 \u2551 operate similarly to corners. They are separated by finding the index \u2551 \u2551 of the fill char from the start or end. The content char is \"x\" by \u2551 \u2551 default, however it can be set to anything else by giving the \"content_char\" \u2551 \u2551 construction parameter. \u2551 \u2551 \u2551 \u2551 As such, this: \u2551 \u2551 \u2551 \u2551 ```python3 \u2551 \u2551 boxes.Box( \u2551 \u2551 [ \u2551 \u2551 \"corner1 ________________ corner2\", \u2551 \u2551 \"xleft ################ rightxx\", \u2551 \u2551 \"corner3 ---------------- corner4\", \u2551 \u2551 ], \u2551 \u2551 content_char=\"#\", \u2551 \u2551 ) \u2551 \u2551 ``` \u2551 \u2551 \u2551 \u2551 Will result in: \u2551 \u2551 \u2551 \u2551 ```python3 \u2551 \u2551 Box( \u2551 \u2551 borders=['xleft ', '_', ' rightxx', '-'], \u2551 \u2551 corners=['corner1 ', ' corner2', ' corner4', 'corner3 '] \u2551 \u2551 ) \u2551 \u2551 ``` \u2551 \u2551 \u2551 \u2551 def debug (self) -> str : \u2551 \u2551 Return identifiable information about object \u2551 \u2551 \u2551 \u2551 def set_chars_of (self, cls_or_obj: WidgetType ) -> WidgetType : \u2551 \u2551 Set border & corner chars of cls_or_obj to self values \u2551 \u2551 \u2551 \u2551 \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2551 \u2551 \u2502 boxes.Box \u2502 \u2551 \u2551 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 \u2551 \u255a \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u255d \u2554 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u2557 \u2551 Inspector \u2551 \u2551 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2551 \u2551 \u2551 \u2551 \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2551 \u2551 \u2502 pytermgui.widgets.boxes.Box \u2502 \u2551 \u2551 \u2502 Located in /Users/lapis/Code/Projects/pytermgui/pytermgui/widgets/boxes.py \u2502 \u2551 \u2551 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 \u2551 \u2551 class Box (lines: list [ str ], content_char: str = x): \u2551 \u2551 Class for defining border & corner styles \u2551 \u2551 \u2551 \u2551 `lines` should be `list[str]` of length 3, such as: \u2551 \u2551 \u2551 \u2551 ```python3 \u2551 \u2551 lines = [ \u2551 \u2551 \".---.\", \u2551 \u2551 \"| x |\", \u2551 \u2551 \"`---`\", \u2551 \u2551 ] \u2551 \u2551 ``` \u2551 \u2551 \u2551 \u2551 The length of individual lines is arbitrary, only limitation is \u2551 \u2551 that the top & bottom border characters should occur most often in \u2551 \u2551 their respective lines. \u2551 \u2551 \u2551 \u2551 You can set corners to be of any length, their end is calculated by \u2551 \u2551 finding the index of the most often occuring character, which is assumed \u2551 \u2551 to be the border character. \u2551 \u2551 \u2551 \u2551 Top & bottom borders are currently limited in length to 1, but sides \u2551 \u2551 operate similarly to corners. They are separated by finding the index \u2551 \u2551 of the fill char from the start or end. The content char is \"x\" by \u2551 \u2551 default, however it can be set to anything else by giving the \"content_char\" \u2551 \u2551 construction parameter. \u2551 \u2551 \u2551 \u2551 As such, this: \u2551 \u2551 \u2551 \u2551 ```python3 \u2551 \u2551 boxes.Box( \u2551 \u2551 [ \u2551 \u2551 \"corner1 ________________ corner2\", \u2551 \u2551 \"xleft ################ rightxx\", \u2551 \u2551 \"corner3 ---------------- corner4\", \u2551 \u2551 ], \u2551 \u2551 content_char=\"#\", \u2551 \u2551 ) \u2551 \u2551 ``` \u2551 \u2551 \u2551 \u2551 Will result in: \u2551 \u2551 \u2551 \u2551 ```python3 \u2551 \u2551 Box( \u2551 \u2551 borders=['xleft ', '_', ' rightxx', '-'], \u2551 \u2551 corners=['corner1 ', ' corner2', ' corner4', 'corner3 '] \u2551 \u2551 ) \u2551 \u2551 ``` \u2551 \u2551 \u2551 \u2551 def debug (self) -> str : \u2551 \u2551 Return identifiable information about object \u2551 \u2551 \u2551 \u2551 def set_chars_of (self, cls_or_obj: WidgetType ) -> WidgetType : \u2551 \u2551 Set border & corner chars of cls_or_obj to self values \u2551 \u2551 \u2551 \u2551 \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2551 \u2551 \u2502 boxes.Box \u2502 \u2551 \u2551 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 \u2551 \u255a \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u255d","title":"Inspection"},{"location":"reference/SUMMARY/","text":"pytermgui animations ansi_interface cmd colors context_managers enums exceptions exporters fancy_repr file_loaders helpers highlighters input inspector markup aliases language macros parsing tokens palettes prettifiers pretty regex serialization term widgets base boxes button checkbox collapsible color_picker containers fancy_repr inline input_field keyboard_button pixel_matrix slider styles toggle window_manager compositor layouts manager window","title":"SUMMARY"},{"location":"reference/pytermgui/","text":"Welcome to the API reference for PyTermGUI , a Python TUI framework with mouse support, modular widget system, customizable and rapid terminal markup language and more! auto ( data , widget_args ) Creates a widget from specific data structures. This conversion includes various widget classes, as well as some shorthands for more complex objects. This method is called implicitly whenever a non-widget is attempted to be added to a Widget. You can read up on the syntacies for each builtin widget within the widget documentation . Parameters: Name Type Description Default data Any The structure to convert. See below for formats. required **widget_args Any Arguments passed straight to the widget constructor. {} Returns: Type Description Optional [ Widget | list [ Splitter ]] The widget or list of widgets created, or None if the passed structure could Optional [ Widget | list [ Splitter ]] not be converted. Example: from pytermgui import Container form = ( Container ( id = \"form\" ) + \"[157 bold]This is a title\" + \"\" + { \"[72 italic]Label1\" : \"[210]Button1\" } + { \"[72 italic]Label2\" : \"[210]Button2\" } + { \"[72 italic]Label3\" : \"[210]Button3\" } + \"\" + [ \"Submit\" , lambda _ , button , your_submit_handler ( button . parent )] ) Source code in pytermgui/__init__.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def auto ( data : Any , ** widget_args : Any ) -> Optional [ Widget | list [ Splitter ]]: \"\"\"Creates a widget from specific data structures. This conversion includes various widget classes, as well as some shorthands for more complex objects. This method is called implicitly whenever a non-widget is attempted to be added to a Widget. You can read up on the syntacies for each builtin widget within the widget [documentation](/widgets/builtins). Args: data: The structure to convert. See below for formats. **widget_args: Arguments passed straight to the widget constructor. Returns: The widget or list of widgets created, or None if the passed structure could not be converted. Example: ```python3 from pytermgui import Container form = ( Container(id=\"form\") + \"[157 bold]This is a title\" + \"\" + {\"[72 italic]Label1\": \"[210]Button1\"} + {\"[72 italic]Label2\": \"[210]Button2\"} + {\"[72 italic]Label3\": \"[210]Button3\"} + \"\" + [\"Submit\", lambda _, button, your_submit_handler(button.parent)] ) ``` \"\"\" # In my opinion, returning immediately after construction is much more readable. # pylint: disable=too-many-return-statements # Nothing to do. if isinstance ( data , Widget ): # Set all **widget_args for key , value in widget_args . items (): setattr ( data , key , value ) return data # Label if isinstance ( data , str ): return Label ( data , ** widget_args ) # Splitter if isinstance ( data , tuple ): return Splitter ( * data , ** widget_args ) # buttons if isinstance ( data , list ): label = data [ 0 ] onclick = None if len ( data ) > 1 : onclick = data [ 1 ] # Checkbox if isinstance ( label , bool ): return Checkbox ( onclick , checked = label , ** widget_args ) # Toggle if isinstance ( label , tuple ): assert len ( label ) == 2 return Toggle ( label , onclick , ** widget_args ) return Button ( label , onclick , ** widget_args ) # prompt splitter if isinstance ( data , dict ): rows : list [ Splitter ] = [] for key , value in data . items (): left = auto ( key , parent_align = HorizontalAlignment . LEFT ) right = auto ( value , parent_align = HorizontalAlignment . RIGHT ) rows . append ( Splitter ( left , right , ** widget_args )) if len ( rows ) == 1 : return rows [ 0 ] return rows return None","title":"Index"},{"location":"reference/pytermgui/#pytermgui.auto","text":"Creates a widget from specific data structures. This conversion includes various widget classes, as well as some shorthands for more complex objects. This method is called implicitly whenever a non-widget is attempted to be added to a Widget. You can read up on the syntacies for each builtin widget within the widget documentation . Parameters: Name Type Description Default data Any The structure to convert. See below for formats. required **widget_args Any Arguments passed straight to the widget constructor. {} Returns: Type Description Optional [ Widget | list [ Splitter ]] The widget or list of widgets created, or None if the passed structure could Optional [ Widget | list [ Splitter ]] not be converted. Example: from pytermgui import Container form = ( Container ( id = \"form\" ) + \"[157 bold]This is a title\" + \"\" + { \"[72 italic]Label1\" : \"[210]Button1\" } + { \"[72 italic]Label2\" : \"[210]Button2\" } + { \"[72 italic]Label3\" : \"[210]Button3\" } + \"\" + [ \"Submit\" , lambda _ , button , your_submit_handler ( button . parent )] ) Source code in pytermgui/__init__.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def auto ( data : Any , ** widget_args : Any ) -> Optional [ Widget | list [ Splitter ]]: \"\"\"Creates a widget from specific data structures. This conversion includes various widget classes, as well as some shorthands for more complex objects. This method is called implicitly whenever a non-widget is attempted to be added to a Widget. You can read up on the syntacies for each builtin widget within the widget [documentation](/widgets/builtins). Args: data: The structure to convert. See below for formats. **widget_args: Arguments passed straight to the widget constructor. Returns: The widget or list of widgets created, or None if the passed structure could not be converted. Example: ```python3 from pytermgui import Container form = ( Container(id=\"form\") + \"[157 bold]This is a title\" + \"\" + {\"[72 italic]Label1\": \"[210]Button1\"} + {\"[72 italic]Label2\": \"[210]Button2\"} + {\"[72 italic]Label3\": \"[210]Button3\"} + \"\" + [\"Submit\", lambda _, button, your_submit_handler(button.parent)] ) ``` \"\"\" # In my opinion, returning immediately after construction is much more readable. # pylint: disable=too-many-return-statements # Nothing to do. if isinstance ( data , Widget ): # Set all **widget_args for key , value in widget_args . items (): setattr ( data , key , value ) return data # Label if isinstance ( data , str ): return Label ( data , ** widget_args ) # Splitter if isinstance ( data , tuple ): return Splitter ( * data , ** widget_args ) # buttons if isinstance ( data , list ): label = data [ 0 ] onclick = None if len ( data ) > 1 : onclick = data [ 1 ] # Checkbox if isinstance ( label , bool ): return Checkbox ( onclick , checked = label , ** widget_args ) # Toggle if isinstance ( label , tuple ): assert len ( label ) == 2 return Toggle ( label , onclick , ** widget_args ) return Button ( label , onclick , ** widget_args ) # prompt splitter if isinstance ( data , dict ): rows : list [ Splitter ] = [] for key , value in data . items (): left = auto ( key , parent_align = HorizontalAlignment . LEFT ) right = auto ( value , parent_align = HorizontalAlignment . RIGHT ) rows . append ( Splitter ( left , right , ** widget_args )) if len ( rows ) == 1 : return rows [ 0 ] return rows return None","title":"auto()"},{"location":"reference/pytermgui/animations/","text":"All animation-related classes & functions. The biggest exports are Animation and its subclasses, as well as Animator . A global instance of Animator is also exported, under the animator name. These can be used both within a WindowManager context (where stepping is done automatically by the pytermgui.window_manager.Compositor on every frame, or manually, by calling animator.step with an elapsed time argument. You can register animations to the Animator using either its schedule method, with an already constructed Animation subclass, or either Animator.animate_attr or Animator.animate_float for an in-place construction of the animation instance. animator = Animator () module-attribute The global Animator instance used by all of the library. Animation dataclass The baseclass for all animations. Source code in pytermgui/animations.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 @dataclass class Animation : \"\"\"The baseclass for all animations.\"\"\" duration : int direction : Direction loop : bool on_step : Callable [[ Animation ], bool ] | None on_finish : Callable [[ Animation ], None ] | None state : float _remaining : float def __post_init__ ( self ) -> None : self . state = 0.0 if self . direction is Direction . FORWARD else 1.0 self . _remaining = self . duration self . _is_paused = False def _update_state ( self , elapsed : float ) -> bool : \"\"\"Updates the internal float state of the animation. Args: elapsed: The time elapsed since last update. Returns: True if the animation deems itself complete, False otherwise. \"\"\" if self . _is_paused : return False self . _remaining -= elapsed * 1000 self . state = ( self . duration - self . _remaining ) / self . duration if self . direction is Direction . BACKWARD : self . state = 1 - self . state self . state = min ( self . state , 1.0 ) if not 0.0 <= self . state < 1.0 : if not self . loop : return True self . _remaining = self . duration self . direction = Direction ( self . direction . value * - 1 ) return False def pause ( self , setting : bool = True ) -> None : \"\"\"Pauses the animation.\"\"\" self . _is_paused = setting def resume ( self ) -> None : \"\"\"Resumes the animation.\"\"\" self . pause ( False ) def step ( self , elapsed : float ) -> bool : \"\"\"Updates animation state. This should call `_update_state`, passing in the elapsed value. That call will update the `state` attribute, which can then be used to animate things. Args: elapsed: The time elapsed since last update. \"\"\" state_finished = self . _update_state ( elapsed ) step_finished = False if self . on_step is not None : step_finished = self . on_step ( self ) return state_finished or step_finished def finish ( self ) -> None : \"\"\"Finishes and cleans up after the animation. Called by `Animator` after `on_step` returns True. Should call `on_finish` if it is not None. \"\"\" if self . on_finish is not None : self . on_finish ( self ) finish () Finishes and cleans up after the animation. Called by Animator after on_step returns True. Should call on_finish if it is not None. Source code in pytermgui/animations.py 158 159 160 161 162 163 164 165 166 def finish ( self ) -> None : \"\"\"Finishes and cleans up after the animation. Called by `Animator` after `on_step` returns True. Should call `on_finish` if it is not None. \"\"\" if self . on_finish is not None : self . on_finish ( self ) pause ( setting = True ) Pauses the animation. Source code in pytermgui/animations.py 130 131 132 133 def pause ( self , setting : bool = True ) -> None : \"\"\"Pauses the animation.\"\"\" self . _is_paused = setting resume () Resumes the animation. Source code in pytermgui/animations.py 135 136 137 138 def resume ( self ) -> None : \"\"\"Resumes the animation.\"\"\" self . pause ( False ) step ( elapsed ) Updates animation state. This should call _update_state , passing in the elapsed value. That call will update the state attribute, which can then be used to animate things. Parameters: Name Type Description Default elapsed float The time elapsed since last update. required Source code in pytermgui/animations.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def step ( self , elapsed : float ) -> bool : \"\"\"Updates animation state. This should call `_update_state`, passing in the elapsed value. That call will update the `state` attribute, which can then be used to animate things. Args: elapsed: The time elapsed since last update. \"\"\" state_finished = self . _update_state ( elapsed ) step_finished = False if self . on_step is not None : step_finished = self . on_step ( self ) return state_finished or step_finished Animator The Animator class This class maintains a list of animations (self._animations), stepping each of them forward as long as they return False. When they return False, the animation is removed from the tracked animations. This stepping is done when step is called. Source code in pytermgui/animations.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 class Animator : \"\"\"The Animator class This class maintains a list of animations (self._animations), stepping each of them forward as long as they return False. When they return False, the animation is removed from the tracked animations. This stepping is done when `step` is called. \"\"\" def __init__ ( self ) -> None : \"\"\"Initializes an animator.\"\"\" self . _animations : list [ Animation ] = [] def __contains__ ( self , item : object ) -> bool : \"\"\"Returns whether the item is inside _animations.\"\"\" return item in self . _animations @property def is_active ( self ) -> bool : \"\"\"Determines whether there are any active animations.\"\"\" return len ( self . _animations ) > 0 def step ( self , elapsed : float ) -> None : \"\"\"Steps the animation forward by the given elapsed time.\"\"\" for animation in self . _animations . copy (): if animation . step ( elapsed ): self . _animations . remove ( animation ) animation . finish () def schedule ( self , animation : Animation ) -> None : \"\"\"Starts an animation on the next step.\"\"\" self . _animations . append ( animation ) def animate_attr ( self , ** animation_args : Any ) -> AttrAnimation : \"\"\"Creates and schedules an AttrAnimation. All arguments are passed to the `AttrAnimation` constructor. `direction`, if given as an integer, will be converted to a `Direction` before being passed. Returns: The created animation. \"\"\" if \"direction\" in animation_args : animation_args [ \"direction\" ] = Direction ( animation_args [ \"direction\" ]) anim = AttrAnimation ( ** animation_args ) self . schedule ( anim ) return anim def animate_float ( self , ** animation_args : Any ) -> FloatAnimation : \"\"\"Creates and schedules an Animation. All arguments are passed to the `Animation` constructor. `direction`, if given as an integer, will be converted to a `Direction` before being passed. Returns: The created animation. \"\"\" if \"direction\" in animation_args : animation_args [ \"direction\" ] = Direction ( animation_args [ \"direction\" ]) anim = FloatAnimation ( ** animation_args ) self . schedule ( anim ) return anim __contains__ ( item ) Returns whether the item is inside _animations. Source code in pytermgui/animations.py 264 265 266 267 def __contains__ ( self , item : object ) -> bool : \"\"\"Returns whether the item is inside _animations.\"\"\" return item in self . _animations __init__ () Initializes an animator. Source code in pytermgui/animations.py 259 260 261 262 def __init__ ( self ) -> None : \"\"\"Initializes an animator.\"\"\" self . _animations : list [ Animation ] = [] animate_attr ( animation_args ) Creates and schedules an AttrAnimation. All arguments are passed to the AttrAnimation constructor. direction , if given as an integer, will be converted to a Direction before being passed. Returns: Type Description AttrAnimation The created animation. Source code in pytermgui/animations.py 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 def animate_attr ( self , ** animation_args : Any ) -> AttrAnimation : \"\"\"Creates and schedules an AttrAnimation. All arguments are passed to the `AttrAnimation` constructor. `direction`, if given as an integer, will be converted to a `Direction` before being passed. Returns: The created animation. \"\"\" if \"direction\" in animation_args : animation_args [ \"direction\" ] = Direction ( animation_args [ \"direction\" ]) anim = AttrAnimation ( ** animation_args ) self . schedule ( anim ) return anim animate_float ( animation_args ) Creates and schedules an Animation. All arguments are passed to the Animation constructor. direction , if given as an integer, will be converted to a Direction before being passed. Returns: Type Description FloatAnimation The created animation. Source code in pytermgui/animations.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 def animate_float ( self , ** animation_args : Any ) -> FloatAnimation : \"\"\"Creates and schedules an Animation. All arguments are passed to the `Animation` constructor. `direction`, if given as an integer, will be converted to a `Direction` before being passed. Returns: The created animation. \"\"\" if \"direction\" in animation_args : animation_args [ \"direction\" ] = Direction ( animation_args [ \"direction\" ]) anim = FloatAnimation ( ** animation_args ) self . schedule ( anim ) return anim is_active () property Determines whether there are any active animations. Source code in pytermgui/animations.py 269 270 271 272 273 @property def is_active ( self ) -> bool : \"\"\"Determines whether there are any active animations.\"\"\" return len ( self . _animations ) > 0 schedule ( animation ) Starts an animation on the next step. Source code in pytermgui/animations.py 283 284 285 286 def schedule ( self , animation : Animation ) -> None : \"\"\"Starts an animation on the next step.\"\"\" self . _animations . append ( animation ) step ( elapsed ) Steps the animation forward by the given elapsed time. Source code in pytermgui/animations.py 275 276 277 278 279 280 281 def step ( self , elapsed : float ) -> None : \"\"\"Steps the animation forward by the given elapsed time.\"\"\" for animation in self . _animations . copy (): if animation . step ( elapsed ): self . _animations . remove ( animation ) animation . finish () AttrAnimation dataclass Bases: Animation Animates an attribute going from one value to another. Source code in pytermgui/animations.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 @dataclass class AttrAnimation ( Animation ): \"\"\"Animates an attribute going from one value to another.\"\"\" target : object = None attr : str = \"\" value_type : type = int end : int | float = 0 start : int | float | None = None on_step : Callable [[ Animation ], bool ] | None = None on_finish : Callable [[ Animation ], None ] | None = None direction : Direction = Direction . FORWARD loop : bool = False state : float = field ( init = False ) _remaining : int = field ( init = False ) def __post_init__ ( self ) -> None : super () . __post_init__ () if self . start is None : self . start = getattr ( self . target , self . attr ) if self . end < self . start : self . start , self . end = self . end , self . start self . direction = Direction . BACKWARD self . end -= self . start _add_flag ( self . target , self . attr ) def step ( self , elapsed : float ) -> bool : \"\"\"Steps forward in the attribute animation.\"\"\" state_finished = self . _update_state ( elapsed ) step_finished = False assert self . start is not None updated = self . start + ( self . end * self . state ) setattr ( self . target , self . attr , self . value_type ( updated )) if self . on_step is not None : step_finished = self . on_step ( self ) if step_finished or state_finished : return True return False def finish ( self ) -> None : \"\"\"Deletes `__ptg_animated__` flag, calls `on_finish`.\"\"\" _remove_flag ( self . target , self . attr ) super () . finish () finish () Deletes __ptg_animated__ flag, calls on_finish . Source code in pytermgui/animations.py 242 243 244 245 246 def finish ( self ) -> None : \"\"\"Deletes `__ptg_animated__` flag, calls `on_finish`.\"\"\" _remove_flag ( self . target , self . attr ) super () . finish () step ( elapsed ) Steps forward in the attribute animation. Source code in pytermgui/animations.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def step ( self , elapsed : float ) -> bool : \"\"\"Steps forward in the attribute animation.\"\"\" state_finished = self . _update_state ( elapsed ) step_finished = False assert self . start is not None updated = self . start + ( self . end * self . state ) setattr ( self . target , self . attr , self . value_type ( updated )) if self . on_step is not None : step_finished = self . on_step ( self ) if step_finished or state_finished : return True return False Direction Bases: Enum Animation directions. Source code in pytermgui/animations.py 73 74 75 76 77 class Direction ( Enum ): \"\"\"Animation directions.\"\"\" FORWARD = 1 BACKWARD = - 1 FloatAnimation dataclass Bases: Animation Transitions a floating point number from 0.0 to 1.0. Note that this is just a wrapper over the base class, and provides no extra functionality. Source code in pytermgui/animations.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 @dataclass class FloatAnimation ( Animation ): \"\"\"Transitions a floating point number from 0.0 to 1.0. Note that this is just a wrapper over the base class, and provides no extra functionality. \"\"\" duration : int on_step : Callable [[ Animation ], bool ] | None = None on_finish : Callable [[ Animation ], None ] | None = None direction : Direction = Direction . FORWARD loop : bool = False state : float = field ( init = False ) _remaining : int = field ( init = False ) is_animated ( target , attribute ) Determines whether the given object.attribute is animated. This looks for __ptg_animated__ , and whether it contains the given attribute. Source code in pytermgui/animations.py 59 60 61 62 63 64 65 66 67 68 69 70 def is_animated ( target : object , attribute : str ) -> bool : \"\"\"Determines whether the given object.attribute is animated. This looks for `__ptg_animated__`, and whether it contains the given attribute. \"\"\" if not hasattr ( target , \"__ptg_animated__\" ): return False animated = getattr ( target , \"__ptg_animated__\" ) return attribute in animated","title":"animations"},{"location":"reference/pytermgui/animations/#pytermgui.animations.animator","text":"The global Animator instance used by all of the library.","title":"animator"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animation","text":"The baseclass for all animations. Source code in pytermgui/animations.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 @dataclass class Animation : \"\"\"The baseclass for all animations.\"\"\" duration : int direction : Direction loop : bool on_step : Callable [[ Animation ], bool ] | None on_finish : Callable [[ Animation ], None ] | None state : float _remaining : float def __post_init__ ( self ) -> None : self . state = 0.0 if self . direction is Direction . FORWARD else 1.0 self . _remaining = self . duration self . _is_paused = False def _update_state ( self , elapsed : float ) -> bool : \"\"\"Updates the internal float state of the animation. Args: elapsed: The time elapsed since last update. Returns: True if the animation deems itself complete, False otherwise. \"\"\" if self . _is_paused : return False self . _remaining -= elapsed * 1000 self . state = ( self . duration - self . _remaining ) / self . duration if self . direction is Direction . BACKWARD : self . state = 1 - self . state self . state = min ( self . state , 1.0 ) if not 0.0 <= self . state < 1.0 : if not self . loop : return True self . _remaining = self . duration self . direction = Direction ( self . direction . value * - 1 ) return False def pause ( self , setting : bool = True ) -> None : \"\"\"Pauses the animation.\"\"\" self . _is_paused = setting def resume ( self ) -> None : \"\"\"Resumes the animation.\"\"\" self . pause ( False ) def step ( self , elapsed : float ) -> bool : \"\"\"Updates animation state. This should call `_update_state`, passing in the elapsed value. That call will update the `state` attribute, which can then be used to animate things. Args: elapsed: The time elapsed since last update. \"\"\" state_finished = self . _update_state ( elapsed ) step_finished = False if self . on_step is not None : step_finished = self . on_step ( self ) return state_finished or step_finished def finish ( self ) -> None : \"\"\"Finishes and cleans up after the animation. Called by `Animator` after `on_step` returns True. Should call `on_finish` if it is not None. \"\"\" if self . on_finish is not None : self . on_finish ( self )","title":"Animation"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animation.finish","text":"Finishes and cleans up after the animation. Called by Animator after on_step returns True. Should call on_finish if it is not None. Source code in pytermgui/animations.py 158 159 160 161 162 163 164 165 166 def finish ( self ) -> None : \"\"\"Finishes and cleans up after the animation. Called by `Animator` after `on_step` returns True. Should call `on_finish` if it is not None. \"\"\" if self . on_finish is not None : self . on_finish ( self )","title":"finish()"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animation.pause","text":"Pauses the animation. Source code in pytermgui/animations.py 130 131 132 133 def pause ( self , setting : bool = True ) -> None : \"\"\"Pauses the animation.\"\"\" self . _is_paused = setting","title":"pause()"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animation.resume","text":"Resumes the animation. Source code in pytermgui/animations.py 135 136 137 138 def resume ( self ) -> None : \"\"\"Resumes the animation.\"\"\" self . pause ( False )","title":"resume()"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animation.step","text":"Updates animation state. This should call _update_state , passing in the elapsed value. That call will update the state attribute, which can then be used to animate things. Parameters: Name Type Description Default elapsed float The time elapsed since last update. required Source code in pytermgui/animations.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def step ( self , elapsed : float ) -> bool : \"\"\"Updates animation state. This should call `_update_state`, passing in the elapsed value. That call will update the `state` attribute, which can then be used to animate things. Args: elapsed: The time elapsed since last update. \"\"\" state_finished = self . _update_state ( elapsed ) step_finished = False if self . on_step is not None : step_finished = self . on_step ( self ) return state_finished or step_finished","title":"step()"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animator","text":"The Animator class This class maintains a list of animations (self._animations), stepping each of them forward as long as they return False. When they return False, the animation is removed from the tracked animations. This stepping is done when step is called. Source code in pytermgui/animations.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 class Animator : \"\"\"The Animator class This class maintains a list of animations (self._animations), stepping each of them forward as long as they return False. When they return False, the animation is removed from the tracked animations. This stepping is done when `step` is called. \"\"\" def __init__ ( self ) -> None : \"\"\"Initializes an animator.\"\"\" self . _animations : list [ Animation ] = [] def __contains__ ( self , item : object ) -> bool : \"\"\"Returns whether the item is inside _animations.\"\"\" return item in self . _animations @property def is_active ( self ) -> bool : \"\"\"Determines whether there are any active animations.\"\"\" return len ( self . _animations ) > 0 def step ( self , elapsed : float ) -> None : \"\"\"Steps the animation forward by the given elapsed time.\"\"\" for animation in self . _animations . copy (): if animation . step ( elapsed ): self . _animations . remove ( animation ) animation . finish () def schedule ( self , animation : Animation ) -> None : \"\"\"Starts an animation on the next step.\"\"\" self . _animations . append ( animation ) def animate_attr ( self , ** animation_args : Any ) -> AttrAnimation : \"\"\"Creates and schedules an AttrAnimation. All arguments are passed to the `AttrAnimation` constructor. `direction`, if given as an integer, will be converted to a `Direction` before being passed. Returns: The created animation. \"\"\" if \"direction\" in animation_args : animation_args [ \"direction\" ] = Direction ( animation_args [ \"direction\" ]) anim = AttrAnimation ( ** animation_args ) self . schedule ( anim ) return anim def animate_float ( self , ** animation_args : Any ) -> FloatAnimation : \"\"\"Creates and schedules an Animation. All arguments are passed to the `Animation` constructor. `direction`, if given as an integer, will be converted to a `Direction` before being passed. Returns: The created animation. \"\"\" if \"direction\" in animation_args : animation_args [ \"direction\" ] = Direction ( animation_args [ \"direction\" ]) anim = FloatAnimation ( ** animation_args ) self . schedule ( anim ) return anim","title":"Animator"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animator.__contains__","text":"Returns whether the item is inside _animations. Source code in pytermgui/animations.py 264 265 266 267 def __contains__ ( self , item : object ) -> bool : \"\"\"Returns whether the item is inside _animations.\"\"\" return item in self . _animations","title":"__contains__()"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animator.__init__","text":"Initializes an animator. Source code in pytermgui/animations.py 259 260 261 262 def __init__ ( self ) -> None : \"\"\"Initializes an animator.\"\"\" self . _animations : list [ Animation ] = []","title":"__init__()"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animator.animate_attr","text":"Creates and schedules an AttrAnimation. All arguments are passed to the AttrAnimation constructor. direction , if given as an integer, will be converted to a Direction before being passed. Returns: Type Description AttrAnimation The created animation. Source code in pytermgui/animations.py 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 def animate_attr ( self , ** animation_args : Any ) -> AttrAnimation : \"\"\"Creates and schedules an AttrAnimation. All arguments are passed to the `AttrAnimation` constructor. `direction`, if given as an integer, will be converted to a `Direction` before being passed. Returns: The created animation. \"\"\" if \"direction\" in animation_args : animation_args [ \"direction\" ] = Direction ( animation_args [ \"direction\" ]) anim = AttrAnimation ( ** animation_args ) self . schedule ( anim ) return anim","title":"animate_attr()"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animator.animate_float","text":"Creates and schedules an Animation. All arguments are passed to the Animation constructor. direction , if given as an integer, will be converted to a Direction before being passed. Returns: Type Description FloatAnimation The created animation. Source code in pytermgui/animations.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 def animate_float ( self , ** animation_args : Any ) -> FloatAnimation : \"\"\"Creates and schedules an Animation. All arguments are passed to the `Animation` constructor. `direction`, if given as an integer, will be converted to a `Direction` before being passed. Returns: The created animation. \"\"\" if \"direction\" in animation_args : animation_args [ \"direction\" ] = Direction ( animation_args [ \"direction\" ]) anim = FloatAnimation ( ** animation_args ) self . schedule ( anim ) return anim","title":"animate_float()"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animator.is_active","text":"Determines whether there are any active animations. Source code in pytermgui/animations.py 269 270 271 272 273 @property def is_active ( self ) -> bool : \"\"\"Determines whether there are any active animations.\"\"\" return len ( self . _animations ) > 0","title":"is_active()"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animator.schedule","text":"Starts an animation on the next step. Source code in pytermgui/animations.py 283 284 285 286 def schedule ( self , animation : Animation ) -> None : \"\"\"Starts an animation on the next step.\"\"\" self . _animations . append ( animation )","title":"schedule()"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animator.step","text":"Steps the animation forward by the given elapsed time. Source code in pytermgui/animations.py 275 276 277 278 279 280 281 def step ( self , elapsed : float ) -> None : \"\"\"Steps the animation forward by the given elapsed time.\"\"\" for animation in self . _animations . copy (): if animation . step ( elapsed ): self . _animations . remove ( animation ) animation . finish ()","title":"step()"},{"location":"reference/pytermgui/animations/#pytermgui.animations.AttrAnimation","text":"Bases: Animation Animates an attribute going from one value to another. Source code in pytermgui/animations.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 @dataclass class AttrAnimation ( Animation ): \"\"\"Animates an attribute going from one value to another.\"\"\" target : object = None attr : str = \"\" value_type : type = int end : int | float = 0 start : int | float | None = None on_step : Callable [[ Animation ], bool ] | None = None on_finish : Callable [[ Animation ], None ] | None = None direction : Direction = Direction . FORWARD loop : bool = False state : float = field ( init = False ) _remaining : int = field ( init = False ) def __post_init__ ( self ) -> None : super () . __post_init__ () if self . start is None : self . start = getattr ( self . target , self . attr ) if self . end < self . start : self . start , self . end = self . end , self . start self . direction = Direction . BACKWARD self . end -= self . start _add_flag ( self . target , self . attr ) def step ( self , elapsed : float ) -> bool : \"\"\"Steps forward in the attribute animation.\"\"\" state_finished = self . _update_state ( elapsed ) step_finished = False assert self . start is not None updated = self . start + ( self . end * self . state ) setattr ( self . target , self . attr , self . value_type ( updated )) if self . on_step is not None : step_finished = self . on_step ( self ) if step_finished or state_finished : return True return False def finish ( self ) -> None : \"\"\"Deletes `__ptg_animated__` flag, calls `on_finish`.\"\"\" _remove_flag ( self . target , self . attr ) super () . finish ()","title":"AttrAnimation"},{"location":"reference/pytermgui/animations/#pytermgui.animations.AttrAnimation.finish","text":"Deletes __ptg_animated__ flag, calls on_finish . Source code in pytermgui/animations.py 242 243 244 245 246 def finish ( self ) -> None : \"\"\"Deletes `__ptg_animated__` flag, calls `on_finish`.\"\"\" _remove_flag ( self . target , self . attr ) super () . finish ()","title":"finish()"},{"location":"reference/pytermgui/animations/#pytermgui.animations.AttrAnimation.step","text":"Steps forward in the attribute animation. Source code in pytermgui/animations.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def step ( self , elapsed : float ) -> bool : \"\"\"Steps forward in the attribute animation.\"\"\" state_finished = self . _update_state ( elapsed ) step_finished = False assert self . start is not None updated = self . start + ( self . end * self . state ) setattr ( self . target , self . attr , self . value_type ( updated )) if self . on_step is not None : step_finished = self . on_step ( self ) if step_finished or state_finished : return True return False","title":"step()"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Direction","text":"Bases: Enum Animation directions. Source code in pytermgui/animations.py 73 74 75 76 77 class Direction ( Enum ): \"\"\"Animation directions.\"\"\" FORWARD = 1 BACKWARD = - 1","title":"Direction"},{"location":"reference/pytermgui/animations/#pytermgui.animations.FloatAnimation","text":"Bases: Animation Transitions a floating point number from 0.0 to 1.0. Note that this is just a wrapper over the base class, and provides no extra functionality. Source code in pytermgui/animations.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 @dataclass class FloatAnimation ( Animation ): \"\"\"Transitions a floating point number from 0.0 to 1.0. Note that this is just a wrapper over the base class, and provides no extra functionality. \"\"\" duration : int on_step : Callable [[ Animation ], bool ] | None = None on_finish : Callable [[ Animation ], None ] | None = None direction : Direction = Direction . FORWARD loop : bool = False state : float = field ( init = False ) _remaining : int = field ( init = False )","title":"FloatAnimation"},{"location":"reference/pytermgui/animations/#pytermgui.animations.is_animated","text":"Determines whether the given object.attribute is animated. This looks for __ptg_animated__ , and whether it contains the given attribute. Source code in pytermgui/animations.py 59 60 61 62 63 64 65 66 67 68 69 70 def is_animated ( target : object , attribute : str ) -> bool : \"\"\"Determines whether the given object.attribute is animated. This looks for `__ptg_animated__`, and whether it contains the given attribute. \"\"\" if not hasattr ( target , \"__ptg_animated__\" ): return False animated = getattr ( target , \"__ptg_animated__\" ) return attribute in animated","title":"is_animated()"},{"location":"reference/pytermgui/ansi_interface/","text":"Various functions to interface with the terminal, using ANSI sequences. Credits: https://wiki.bash-hackers.org/scripting/terminalcodes https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797 MouseAction Bases: Enum An enumeration of all the polled mouse actions Source code in pytermgui/ansi_interface.py 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 class MouseAction ( Enum ): \"\"\"An enumeration of all the polled mouse actions\"\"\" LEFT_CLICK = \"left_click\" \"\"\"Start of a left button action sequence.\"\"\" LEFT_DRAG = \"left_drag\" \"\"\"Mouse moved while left button was held down.\"\"\" RIGHT_CLICK = \"right_click\" \"\"\"Start of a right button action sequence.\"\"\" RIGHT_DRAG = \"right_drag\" \"\"\"Mouse moved while right button was held down.\"\"\" SCROLL_UP = \"scroll_up\" \"\"\"Mouse wheel or touchpad scroll upwards.\"\"\" SCROLL_DOWN = \"scroll_down\" \"\"\"Mouse wheel or touchpad scroll downwards.\"\"\" SHIFT_SCROLL_UP = \"shift_scroll_up\" \"\"\"Mouse wheel or touchpad scroll upwards.\"\"\" SHIFT_SCROLL_DOWN = \"shift_scroll_down\" \"\"\"Mouse wheel or touchpad scroll downwards.\"\"\" HOVER = \"hover\" \"\"\"Mouse moved without clicking.\"\"\" # TODO: Support left & right mouse release separately, without breaking # current API. RELEASE = \"release\" \"\"\"Mouse button released; end of any and all mouse action sequences.\"\"\" HOVER = 'hover' class-attribute Mouse moved without clicking. LEFT_CLICK = 'left_click' class-attribute Start of a left button action sequence. LEFT_DRAG = 'left_drag' class-attribute Mouse moved while left button was held down. RELEASE = 'release' class-attribute Mouse button released; end of any and all mouse action sequences. RIGHT_CLICK = 'right_click' class-attribute Start of a right button action sequence. RIGHT_DRAG = 'right_drag' class-attribute Mouse moved while right button was held down. SCROLL_DOWN = 'scroll_down' class-attribute Mouse wheel or touchpad scroll downwards. SCROLL_UP = 'scroll_up' class-attribute Mouse wheel or touchpad scroll upwards. SHIFT_SCROLL_DOWN = 'shift_scroll_down' class-attribute Mouse wheel or touchpad scroll downwards. SHIFT_SCROLL_UP = 'shift_scroll_up' class-attribute Mouse wheel or touchpad scroll upwards. MouseEvent dataclass A class to represent events created by mouse actions. Its first argument is a MouseAction describing what happened, and its second argument is a tuple[int, int] describing where it happened. This class mostly exists for readability & typing reasons. It also implements the iterable protocol, so you can use the unpacking syntax, such as: action , position = MouseEvent ( ... ) Source code in pytermgui/ansi_interface.py 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 @dataclass class MouseEvent : \"\"\"A class to represent events created by mouse actions. Its first argument is a `MouseAction` describing what happened, and its second argument is a `tuple[int, int]` describing where it happened. This class mostly exists for readability & typing reasons. It also implements the iterable protocol, so you can use the unpacking syntax, such as: ```python3 action, position = MouseEvent(...) ``` \"\"\" action : MouseAction position : tuple [ int , int ] def __post_init__ ( self ) -> None : \"\"\"Initialize iteration counter\"\"\" self . _iter_index = 0 def __next__ ( self ) -> MouseAction | tuple [ int , int ]: \"\"\"Get next iteration item\"\"\" data = fields ( self ) if self . _iter_index >= len ( data ): self . _iter_index = 0 raise StopIteration self . _iter_index += 1 return getattr ( self , data [ self . _iter_index - 1 ] . name ) def __iter__ ( self ) -> MouseEvent : \"\"\"Start iteration\"\"\" return self def is_scroll ( self ) -> bool : \"\"\"Returns True if event.action is one of the scrolling actions.\"\"\" return self . action in { MouseAction . SCROLL_DOWN , MouseAction . SCROLL_UP } def is_primary ( self ) -> bool : \"\"\"Returns True if event.action is one of the primary (left-button) actions.\"\"\" return self . action in { MouseAction . LEFT_CLICK , MouseAction . LEFT_DRAG } def is_secondary ( self ) -> bool : \"\"\"Returns True if event.action is one of the secondary (secondary-button) actions.\"\"\" return self . action in { MouseAction . RIGHT_CLICK , MouseAction . RIGHT_DRAG } __iter__ () Start iteration Source code in pytermgui/ansi_interface.py 450 451 452 453 def __iter__ ( self ) -> MouseEvent : \"\"\"Start iteration\"\"\" return self __next__ () Get next iteration item Source code in pytermgui/ansi_interface.py 438 439 440 441 442 443 444 445 446 447 448 def __next__ ( self ) -> MouseAction | tuple [ int , int ]: \"\"\"Get next iteration item\"\"\" data = fields ( self ) if self . _iter_index >= len ( data ): self . _iter_index = 0 raise StopIteration self . _iter_index += 1 return getattr ( self , data [ self . _iter_index - 1 ] . name ) __post_init__ () Initialize iteration counter Source code in pytermgui/ansi_interface.py 433 434 435 436 def __post_init__ ( self ) -> None : \"\"\"Initialize iteration counter\"\"\" self . _iter_index = 0 is_primary () Returns True if event.action is one of the primary (left-button) actions. Source code in pytermgui/ansi_interface.py 460 461 462 463 def is_primary ( self ) -> bool : \"\"\"Returns True if event.action is one of the primary (left-button) actions.\"\"\" return self . action in { MouseAction . LEFT_CLICK , MouseAction . LEFT_DRAG } is_scroll () Returns True if event.action is one of the scrolling actions. Source code in pytermgui/ansi_interface.py 455 456 457 458 def is_scroll ( self ) -> bool : \"\"\"Returns True if event.action is one of the scrolling actions.\"\"\" return self . action in { MouseAction . SCROLL_DOWN , MouseAction . SCROLL_UP } is_secondary () Returns True if event.action is one of the secondary (secondary-button) actions. Source code in pytermgui/ansi_interface.py 465 466 467 468 def is_secondary ( self ) -> bool : \"\"\"Returns True if event.action is one of the secondary (secondary-button) actions.\"\"\" return self . action in { MouseAction . RIGHT_CLICK , MouseAction . RIGHT_DRAG } blink ( text , reset_style = True ) Returns text blinking. Parameters: Name Type Description Default reset_style Optional [ bool ] Boolean that determines whether a reset character should be appended to the end of the string. True Source code in pytermgui/ansi_interface.py 681 682 683 684 685 686 687 688 689 def blink ( text : str , reset_style : Optional [ bool ] = True ) -> str : \"\"\"Returns text blinking. Args: reset_style: Boolean that determines whether a reset character should be appended to the end of the string. \"\"\" return set_mode ( \"blink\" , False ) + text + ( reset () if reset_style else \"\" ) bold ( text , reset_style = True ) Returns text in bold. Parameters: Name Type Description Default reset_style Optional [ bool ] Boolean that determines whether a reset character should be appended to the end of the string. True Source code in pytermgui/ansi_interface.py 637 638 639 640 641 642 643 644 645 def bold ( text : str , reset_style : Optional [ bool ] = True ) -> str : \"\"\"Returns text in bold. Args: reset_style: Boolean that determines whether a reset character should be appended to the end of the string. \"\"\" return set_mode ( \"bold\" , False ) + text + ( reset () if reset_style else \"\" ) clear ( what = 'screen' ) Clears the specified screen region. Parameters: Name Type Description Default what str The specifier defining the screen area. 'screen' Available options: * screen: clear whole screen and go to origin * bos: clear screen from cursor backwards * eos: clear screen from cursor forwards * line: clear line and go to beginning * bol: clear line from cursor backwards * eol: clear line from cursor forwards Source code in pytermgui/ansi_interface.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def clear ( what : str = \"screen\" ) -> None : \"\"\"Clears the specified screen region. Args: what: The specifier defining the screen area. Available options: * screen: clear whole screen and go to origin * bos: clear screen from cursor backwards * eos: clear screen from cursor forwards * line: clear line and go to beginning * bol: clear line from cursor backwards * eol: clear line from cursor forwards \"\"\" commands = { \"eos\" : \" \\x1b [0J\" , \"bos\" : \" \\x1b [1J\" , \"screen\" : \" \\x1b [2J\" , \"eol\" : \" \\x1b [0K\" , \"bol\" : \" \\x1b [1K\" , \"line\" : \" \\x1b [2K\" , } get_terminal () . write ( commands [ what ]) cursor_column ( num = 0 ) Moves the cursor to the num -th character of the current line. Parameters: Name Type Description Default num int The new cursor position. 0 Note This does not flush the terminal for performance reasons. You can do it manually with sys.stdout.flush() . Source code in pytermgui/ansi_interface.py 276 277 278 279 280 281 282 283 284 285 286 287 def cursor_column ( num : int = 0 ) -> None : \"\"\"Moves the cursor to the `num`-th character of the current line. Args: num: The new cursor position. Note: This does not flush the terminal for performance reasons. You can do it manually with `sys.stdout.flush()`. \"\"\" get_terminal () . write ( f \" \\x1b [ { num } G\" ) cursor_down ( num = 1 ) Moves the cursor up by num lines. Parameters: Name Type Description Default num int How many lines the cursor should move by. Must be positive, to move in the opposite direction use cursor_up . 1 Note This does not flush the terminal for performance reasons. You can do it manually with sys.stdout.flush() . Source code in pytermgui/ansi_interface.py 206 207 208 209 210 211 212 213 214 215 216 217 def cursor_down ( num : int = 1 ) -> None : \"\"\"Moves the cursor up by `num` lines. Args: num: How many lines the cursor should move by. Must be positive, to move in the opposite direction use `cursor_up`. Note: This does not flush the terminal for performance reasons. You can do it manually with `sys.stdout.flush()`. \"\"\" get_terminal () . write ( f \" \\x1b [ { num } B\" ) cursor_home () Moves cursor to get_terminal().origin . Note This does not flush the terminal for performance reasons. You can do it manually with sys.stdout.flush() . Source code in pytermgui/ansi_interface.py 290 291 292 293 294 295 296 297 298 def cursor_home () -> None : \"\"\"Moves cursor to `get_terminal().origin`. Note: This does not flush the terminal for performance reasons. You can do it manually with `sys.stdout.flush()`. \"\"\" get_terminal () . write ( \" \\x1b [H\" ) cursor_left ( num = 1 ) Moves the cursor left by num lines. Parameters: Name Type Description Default num int How many characters the cursor should move by. Must be positive, to move in the opposite direction use cursor_right . 1 Note This does not flush the terminal for performance reasons. You can do it manually with sys.stdout.flush() . Source code in pytermgui/ansi_interface.py 234 235 236 237 238 239 240 241 242 243 244 245 def cursor_left ( num : int = 1 ) -> None : \"\"\"Moves the cursor left by `num` lines. Args: num: How many characters the cursor should move by. Must be positive, to move in the opposite direction use `cursor_right`. Note: This does not flush the terminal for performance reasons. You can do it manually with `sys.stdout.flush()`. \"\"\" get_terminal () . write ( f \" \\x1b [ { num } D\" ) cursor_next_line ( num = 1 ) Moves the cursor to the beginning of the num -th line downwards. Parameters: Name Type Description Default num int The amount the cursor should move by. Must be positive, to move in the opposite direction use cursor_prev_line . 1 Note This does not flush the terminal for performance reasons. You can do it manually with sys.stdout.flush() . Source code in pytermgui/ansi_interface.py 248 249 250 251 252 253 254 255 256 257 258 259 def cursor_next_line ( num : int = 1 ) -> None : \"\"\"Moves the cursor to the beginning of the `num`-th line downwards. Args: num: The amount the cursor should move by. Must be positive, to move in the opposite direction use `cursor_prev_line`. Note: This does not flush the terminal for performance reasons. You can do it manually with `sys.stdout.flush()`. \"\"\" get_terminal () . write ( f \" \\x1b [ { num } E\" ) cursor_prev_line ( num = 1 ) Moves the cursor to the beginning of the num -th line upwards. Parameters: Name Type Description Default num int The amount the cursor should move by. Must be positive, to move in the opposite direction use cursor_next_line . 1 Note This does not flush the terminal for performance reasons. You can do it manually with sys.stdout.flush() . Source code in pytermgui/ansi_interface.py 262 263 264 265 266 267 268 269 270 271 272 273 def cursor_prev_line ( num : int = 1 ) -> None : \"\"\"Moves the cursor to the beginning of the `num`-th line upwards. Args: num: The amount the cursor should move by. Must be positive, to move in the opposite direction use `cursor_next_line`. Note: This does not flush the terminal for performance reasons. You can do it manually with `sys.stdout.flush()`. \"\"\" get_terminal () . write ( f \" \\x1b [ { num } F\" ) cursor_right ( num = 1 ) Moves the cursor right by num lines. Parameters: Name Type Description Default num int How many characters the cursor should move by. Must be positive, to move in the opposite direction use cursor_left . 1 Note This does not flush the terminal for performance reasons. You can do it manually with sys.stdout.flush() . Source code in pytermgui/ansi_interface.py 220 221 222 223 224 225 226 227 228 229 230 231 def cursor_right ( num : int = 1 ) -> None : \"\"\"Moves the cursor right by `num` lines. Args: num: How many characters the cursor should move by. Must be positive, to move in the opposite direction use `cursor_left`. Note: This does not flush the terminal for performance reasons. You can do it manually with `sys.stdout.flush()`. \"\"\" get_terminal () . write ( f \" \\x1b [ { num } C\" ) cursor_up ( num = 1 ) Moves the cursor up by num lines. Parameters: Name Type Description Default num int How many lines the cursor should move by. Must be positive, to move in the opposite direction use cursor_down . 1 Note This does not flush the terminal for performance reasons. You can do it manually with sys.stdout.flush() . Source code in pytermgui/ansi_interface.py 192 193 194 195 196 197 198 199 200 201 202 203 def cursor_up ( num : int = 1 ) -> None : \"\"\"Moves the cursor up by `num` lines. Args: num: How many lines the cursor should move by. Must be positive, to move in the opposite direction use `cursor_down`. Note: This does not flush the terminal for performance reasons. You can do it manually with `sys.stdout.flush()`. \"\"\" get_terminal () . write ( f \" \\x1b [ { num } A\" ) dim ( text , reset_style = True ) Returns text in dim. Parameters: Name Type Description Default reset_style Optional [ bool ] Boolean that determines whether a reset character should be appended to the end of the string. True Source code in pytermgui/ansi_interface.py 648 649 650 651 652 653 654 655 656 def dim ( text : str , reset_style : Optional [ bool ] = True ) -> str : \"\"\"Returns text in dim. Args: reset_style: Boolean that determines whether a reset character should be appended to the end of the string. \"\"\" return set_mode ( \"dim\" , False ) + text + ( reset () if reset_style else \"\" ) hide_cursor () Stops printing the cursor. Source code in pytermgui/ansi_interface.py 129 130 131 132 def hide_cursor () -> None : \"\"\"Stops printing the cursor.\"\"\" get_terminal () . write ( \" \\x1b [?25l\" ) inverse ( text , reset_style = True ) Returns text inverse-colored. Parameters: Name Type Description Default reset_style Optional [ bool ] Boolean that determines whether a reset character should be appended to the end of the string. True Source code in pytermgui/ansi_interface.py 692 693 694 695 696 697 698 699 700 def inverse ( text : str , reset_style : Optional [ bool ] = True ) -> str : \"\"\"Returns text inverse-colored. Args: reset_style: Boolean that determines whether a reset character should be appended to the end of the string. \"\"\" return set_mode ( \"inverse\" , False ) + text + ( reset () if reset_style else \"\" ) invisible ( text , reset_style = True ) Returns text as invisible. Parameters: Name Type Description Default reset_style Optional [ bool ] Boolean that determines whether a reset character should be appended to the end of the string. True Note This isn't very widely supported. Source code in pytermgui/ansi_interface.py 703 704 705 706 707 708 709 710 711 712 713 714 def invisible ( text : str , reset_style : Optional [ bool ] = True ) -> str : \"\"\"Returns text as invisible. Args: reset_style: Boolean that determines whether a reset character should be appended to the end of the string. Note: This isn't very widely supported. \"\"\" return set_mode ( \"invisible\" , False ) + text + ( reset () if reset_style else \"\" ) italic ( text , reset_style = True ) Returns text in italic. Parameters: Name Type Description Default reset_style Optional [ bool ] Boolean that determines whether a reset character should be appended to the end of the string. True Source code in pytermgui/ansi_interface.py 659 660 661 662 663 664 665 666 667 def italic ( text : str , reset_style : Optional [ bool ] = True ) -> str : \"\"\"Returns text in italic. Args: reset_style: Boolean that determines whether a reset character should be appended to the end of the string. \"\"\" return set_mode ( \"italic\" , False ) + text + ( reset () if reset_style else \"\" ) move_cursor ( pos ) Moves the cursor. Parameters: Name Type Description Default pos tuple [ int , int ] Tuple of that the cursor will be moved to. required This does not flush the terminal for performance reasons. You can do it manually with sys.stdout.flush() . Source code in pytermgui/ansi_interface.py 178 179 180 181 182 183 184 185 186 187 188 189 def move_cursor ( pos : tuple [ int , int ]) -> None : \"\"\"Moves the cursor. Args: pos: Tuple of that the cursor will be moved to. This does not flush the terminal for performance reasons. You can do it manually with `sys.stdout.flush()`. \"\"\" posx , posy = pos get_terminal () . write ( f \" \\x1b [ { posy } ; { posx } H\" ) overline ( text , reset_style = True ) Return text overlined. Parameters: Name Type Description Default reset_style Optional [ bool ] Boolean that determines whether a reset character should be appended to the end of the string. True Note This isnt' very widely supported. Source code in pytermgui/ansi_interface.py 728 729 730 731 732 733 734 735 736 737 738 739 def overline ( text : str , reset_style : Optional [ bool ] = True ) -> str : \"\"\"Return text overlined. Args: reset_style: Boolean that determines whether a reset character should be appended to the end of the string. Note: This isnt' very widely supported. \"\"\" return set_mode ( \"overline\" , False ) + text + ( reset () if reset_style else \"\" ) print_to ( pos , args , kwargs ) Prints text to given pos . Note This method passes through all arguments (except for pos ) to the print method. Source code in pytermgui/ansi_interface.py 619 620 621 622 623 624 625 626 627 628 def print_to ( pos : tuple [ int , int ], * args : Any , ** kwargs : Any ) -> None : \"\"\"Prints text to given `pos`. Note: This method passes through all arguments (except for `pos`) to the `print` method. \"\"\" move_cursor ( pos ) print ( * args , ** kwargs ) report_cursor () Gets position of cursor. Returns: Type Description Optional [ tuple [ int , int ]] A tuple of integers, (columns, rows), describing the Optional [ tuple [ int , int ]] current (printing) cursor's position. Returns None if Optional [ tuple [ int , int ]] this could not be determined. Optional [ tuple [ int , int ]] Note that this position is not the mouse position. See Optional [ tuple [ int , int ]] report_mouse if that is what you are interested in. Source code in pytermgui/ansi_interface.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def report_cursor () -> Optional [ tuple [ int , int ]]: \"\"\"Gets position of cursor. Returns: A tuple of integers, (columns, rows), describing the current (printing) cursor's position. Returns None if this could not be determined. Note that this position is **not** the mouse position. See `report_mouse` if that is what you are interested in. \"\"\" get_terminal () . write ( \" \\x1b [6n\" , flush = True ) chars = getch () posy , posx = chars [ 2 : - 1 ] . split ( \";\" ) if not posx . isdigit () or not posy . isdigit (): return None return int ( posx ), int ( posy ) report_mouse ( event , method = 'decimal_xterm' , stop = False ) Starts reporting of mouse events. You can specify multiple events to report on. Parameters: Name Type Description Default event str The type of event to report on. See below for options. required method Optional [ str ] The method of reporting to use. See below for options. 'decimal_xterm' stop bool If set to True, the stopping code is written to stdout. False Raises: Type Description NotImplementedError The given event is not supported. Note If you need this functionality, you're probably better off using the wrapper pytermgui.context_managers.mouse_handler , which allows listening on multiple events, gives a translator method and handles exceptions. Possible events press : Report when the mouse is clicked, left or right button. highlight : Report highlighting. press_hold : Report with a left or right click, as well as both left & right drag and release. hover : Report even when no active action is done, only the mouse is moved. Methods None : Non-decimal xterm method. Limited in coordinates. decimal_xterm : The default setting. Most universally supported. decimal_urxvt : Older, less compatible, but useful on some systems. decimal_utf8 : Apparently not too stable. More information here . Source code in pytermgui/ansi_interface.py 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 def report_mouse ( event : str , method : Optional [ str ] = \"decimal_xterm\" , stop : bool = False ) -> None : \"\"\"Starts reporting of mouse events. You can specify multiple events to report on. Args: event: The type of event to report on. See below for options. method: The method of reporting to use. See below for options. stop: If set to True, the stopping code is written to stdout. Raises: NotImplementedError: The given event is not supported. Note: If you need this functionality, you're probably better off using the wrapper `pytermgui.context_managers.mouse_handler`, which allows listening on multiple events, gives a translator method and handles exceptions. Possible events: - **press**: Report when the mouse is clicked, left or right button. - **highlight**: Report highlighting. - **press_hold**: Report with a left or right click, as well as both left & right drag and release. - **hover**: Report even when no active action is done, only the mouse is moved. Methods: - **None**: Non-decimal xterm method. Limited in coordinates. - **decimal_xterm**: The default setting. Most universally supported. - **decimal_urxvt**: Older, less compatible, but useful on some systems. - **decimal_utf8**: Apparently not too stable. More information <a href='https://stackoverflow.com/a/5970472'>here</a>. \"\"\" if event == \"press\" : get_terminal () . write ( \" \\x1b [?1000\" ) elif event == \"highlight\" : get_terminal () . write ( \" \\x1b [?1001\" ) elif event == \"press_hold\" : get_terminal () . write ( \" \\x1b [?1002\" ) elif event == \"hover\" : get_terminal () . write ( \" \\x1b [?1003\" ) else : raise NotImplementedError ( f \"Mouse report event { event } is not supported!\" ) get_terminal () . write ( \"l\" if stop else \"h\" ) if method == \"decimal_utf8\" : get_terminal () . write ( \" \\x1b [?1005\" ) elif method == \"decimal_xterm\" : get_terminal () . write ( \" \\x1b [?1006\" ) elif method == \"decimal_urxvt\" : get_terminal () . write ( \" \\x1b [?1015\" ) elif method is None : return else : raise NotImplementedError ( f \"Mouse report method { method } is not supported!\" ) get_terminal () . write ( \"l\" if stop else \"h\" , flush = True ) reset () Resets printing mode. Source code in pytermgui/ansi_interface.py 631 632 633 634 def reset () -> str : \"\"\"Resets printing mode.\"\"\" return set_mode ( \"reset\" , False ) restore_cursor () Restore cursor position as saved by save_cursor . Source code in pytermgui/ansi_interface.py 150 151 152 153 def restore_cursor () -> None : \"\"\"Restore cursor position as saved by `save_cursor`.\"\"\" get_terminal () . write ( \" \\x1b [u\" ) restore_screen () Restores the contents of the screen saved by save_screen() . Source code in pytermgui/ansi_interface.py 83 84 85 86 def restore_screen () -> None : \"\"\"Restores the contents of the screen saved by `save_screen()`.\"\"\" print ( \" \\x1b [?47l\" ) save_cursor () Saves the current cursor position. Use restore_cursor to restore it. Source code in pytermgui/ansi_interface.py 141 142 143 144 145 146 147 def save_cursor () -> None : \"\"\"Saves the current cursor position. Use `restore_cursor` to restore it. \"\"\" get_terminal () . write ( \" \\x1b [s\" ) save_screen () Saves the contents of the screen, and wipes it. Use restore_screen() to get them back. Source code in pytermgui/ansi_interface.py 74 75 76 77 78 79 80 def save_screen () -> None : \"\"\"Saves the contents of the screen, and wipes it. Use `restore_screen()` to get them back. \"\"\" print ( \" \\x1b [?47h\" ) set_alt_buffer () Starts an alternate buffer. Source code in pytermgui/ansi_interface.py 89 90 91 92 def set_alt_buffer () -> None : \"\"\"Starts an alternate buffer.\"\"\" print ( \" \\x1b [?1049h\" ) set_echo () Starts echoing of user input. Note This is currently only available on POSIX. Source code in pytermgui/ansi_interface.py 351 352 353 354 355 356 357 358 359 360 361 def set_echo () -> None : \"\"\"Starts echoing of user input. Note: This is currently only available on POSIX. \"\"\" if not _name == \"posix\" : return system ( \"stty echo\" ) set_mode ( mode , write = True ) Sets terminal display mode. This is better left internal. To use these modes, you can call their specific functions, such as bold(\"text\") or italic(\"text\") . Parameters: Name Type Description Default mode Union [ str , int ] One of the available modes. Strings and integers both work. required write bool Boolean that determines whether the output should be written to stdout. True Returns: Type Description str A string that sets the given mode. Available modes 0: reset 1: bold 2: dim 3: italic 4: underline 5: blink 7: inverse 8: invisible 9: strikethrough 53: overline Source code in pytermgui/ansi_interface.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 def set_mode ( mode : Union [ str , int ], write : bool = True ) -> str : \"\"\"Sets terminal display mode. This is better left internal. To use these modes, you can call their specific functions, such as `bold(\"text\")` or `italic(\"text\")`. Args: mode: One of the available modes. Strings and integers both work. write: Boolean that determines whether the output should be written to stdout. Returns: A string that sets the given mode. Available modes: - 0: reset - 1: bold - 2: dim - 3: italic - 4: underline - 5: blink - 7: inverse - 8: invisible - 9: strikethrough - 53: overline \"\"\" options = { \"reset\" : 0 , \"bold\" : 1 , \"dim\" : 2 , \"italic\" : 3 , \"underline\" : 4 , \"blink\" : 5 , \"inverse\" : 7 , \"invisible\" : 8 , \"strikethrough\" : 9 , \"overline\" : 53 , } if not str ( mode ) . isdigit (): mode = options [ str ( mode )] code = f \" \\x1b [ { mode } m\" if write : get_terminal () . write ( code ) return code show_cursor () Starts printing the cursor. Source code in pytermgui/ansi_interface.py 135 136 137 138 def show_cursor () -> None : \"\"\"Starts printing the cursor.\"\"\" get_terminal () . write ( \" \\x1b [?25h\" ) strikethrough ( text , reset_style = True ) Return text as strikethrough. Parameters: Name Type Description Default reset_style Optional [ bool ] Boolean that determines whether a reset character should be appended to the end of the string. True Source code in pytermgui/ansi_interface.py 717 718 719 720 721 722 723 724 725 def strikethrough ( text : str , reset_style : Optional [ bool ] = True ) -> str : \"\"\"Return text as strikethrough. Args: reset_style: Boolean that determines whether a reset character should be appended to the end of the string. \"\"\" return set_mode ( \"strikethrough\" , False ) + text + ( reset () if reset_style else \"\" ) translate_mouse ( code , method ) Translates the output of produced by setting report_mouse into MouseEvents. This method currently only supports decimal_xterm and decimal_urxvt . Parameters: Name Type Description Default code str The string of mouse code(s) to translate. required method str The reporting method to translate. One of decimal_xterm , decimal_urxvt . required Returns: Type Description list [ MouseEvent | None] | None A list of optional mouse events obtained from the code argument. If the code was malformed, list [ MouseEvent | None] | None and no codes could be determined None is returned. Source code in pytermgui/ansi_interface.py 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 def translate_mouse ( code : str , method : str ) -> list [ MouseEvent | None ] | None : \"\"\"Translates the output of produced by setting `report_mouse` into MouseEvents. This method currently only supports `decimal_xterm` and `decimal_urxvt`. Args: code: The string of mouse code(s) to translate. method: The reporting method to translate. One of `decimal_xterm`, `decimal_urxvt`. Returns: A list of optional mouse events obtained from the code argument. If the code was malformed, and no codes could be determined None is returned. \"\"\" if code == \" \\x1b \" : return None mouse_codes = { \"decimal_xterm\" : { \"0M\" : MouseAction . LEFT_CLICK , \"0m\" : MouseAction . RELEASE , \"2M\" : MouseAction . RIGHT_CLICK , \"2m\" : MouseAction . RELEASE , \"32\" : MouseAction . LEFT_DRAG , \"34\" : MouseAction . RIGHT_DRAG , \"35\" : MouseAction . HOVER , \"64\" : MouseAction . SCROLL_UP , \"65\" : MouseAction . SCROLL_DOWN , \"68\" : MouseAction . SHIFT_SCROLL_UP , \"69\" : MouseAction . SHIFT_SCROLL_DOWN , }, \"decimal_urxvt\" : { \"32\" : MouseAction . LEFT_CLICK , \"34\" : MouseAction . RIGHT_CLICK , \"35\" : MouseAction . RELEASE , \"64\" : MouseAction . LEFT_DRAG , \"66\" : MouseAction . RIGHT_DRAG , \"96\" : MouseAction . SCROLL_UP , \"97\" : MouseAction . SCROLL_DOWN , }, } mapping = mouse_codes [ method ] pattern : Pattern = RE_MOUSE [ method ] events : list [ MouseEvent | None ] = [] for sequence in code . split ( \" \\x1b \" ): if len ( sequence ) == 0 : continue matches = list ( pattern . finditer ( sequence )) if len ( matches ) == 0 : return None for match in matches : identifier , * pos , release_code = match . groups () # decimal_xterm uses the last character's # capitalization to signify press/release state if len ( release_code ) > 0 and identifier in [ \"0\" , \"2\" ]: identifier += release_code if identifier in mapping : action = mapping [ identifier ] assert isinstance ( action , MouseAction ) events . append ( MouseEvent ( action , ( int ( pos [ 0 ]), int ( pos [ 1 ])))) continue events . append ( None ) return events underline ( text , reset_style = True ) Returns text underlined. Parameters: Name Type Description Default reset_style Optional [ bool ] Boolean that determines whether a reset character should be appended to the end of the string. True Source code in pytermgui/ansi_interface.py 670 671 672 673 674 675 676 677 678 def underline ( text : str , reset_style : Optional [ bool ] = True ) -> str : \"\"\"Returns text underlined. Args: reset_style: Boolean that determines whether a reset character should be appended to the end of the string. \"\"\" return set_mode ( \"underline\" , False ) + text + ( reset () if reset_style else \"\" ) unset_alt_buffer () Returns to main buffer, restoring its original state. Source code in pytermgui/ansi_interface.py 95 96 97 98 def unset_alt_buffer () -> None : \"\"\"Returns to main buffer, restoring its original state.\"\"\" print ( \" \\x1b [?1049l\" ) unset_echo () Stops echoing of user input. Note This is currently only available on POSIX. Source code in pytermgui/ansi_interface.py 364 365 366 367 368 369 370 371 372 373 374 def unset_echo () -> None : \"\"\"Stops echoing of user input. Note: This is currently only available on POSIX. \"\"\" if not _name == \"posix\" : return system ( \"stty -echo\" )","title":"ansi_interface"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseAction","text":"Bases: Enum An enumeration of all the polled mouse actions Source code in pytermgui/ansi_interface.py 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 class MouseAction ( Enum ): \"\"\"An enumeration of all the polled mouse actions\"\"\" LEFT_CLICK = \"left_click\" \"\"\"Start of a left button action sequence.\"\"\" LEFT_DRAG = \"left_drag\" \"\"\"Mouse moved while left button was held down.\"\"\" RIGHT_CLICK = \"right_click\" \"\"\"Start of a right button action sequence.\"\"\" RIGHT_DRAG = \"right_drag\" \"\"\"Mouse moved while right button was held down.\"\"\" SCROLL_UP = \"scroll_up\" \"\"\"Mouse wheel or touchpad scroll upwards.\"\"\" SCROLL_DOWN = \"scroll_down\" \"\"\"Mouse wheel or touchpad scroll downwards.\"\"\" SHIFT_SCROLL_UP = \"shift_scroll_up\" \"\"\"Mouse wheel or touchpad scroll upwards.\"\"\" SHIFT_SCROLL_DOWN = \"shift_scroll_down\" \"\"\"Mouse wheel or touchpad scroll downwards.\"\"\" HOVER = \"hover\" \"\"\"Mouse moved without clicking.\"\"\" # TODO: Support left & right mouse release separately, without breaking # current API. RELEASE = \"release\" \"\"\"Mouse button released; end of any and all mouse action sequences.\"\"\"","title":"MouseAction"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseAction.HOVER","text":"Mouse moved without clicking.","title":"HOVER"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseAction.LEFT_CLICK","text":"Start of a left button action sequence.","title":"LEFT_CLICK"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseAction.LEFT_DRAG","text":"Mouse moved while left button was held down.","title":"LEFT_DRAG"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseAction.RELEASE","text":"Mouse button released; end of any and all mouse action sequences.","title":"RELEASE"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseAction.RIGHT_CLICK","text":"Start of a right button action sequence.","title":"RIGHT_CLICK"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseAction.RIGHT_DRAG","text":"Mouse moved while right button was held down.","title":"RIGHT_DRAG"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseAction.SCROLL_DOWN","text":"Mouse wheel or touchpad scroll downwards.","title":"SCROLL_DOWN"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseAction.SCROLL_UP","text":"Mouse wheel or touchpad scroll upwards.","title":"SCROLL_UP"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseAction.SHIFT_SCROLL_DOWN","text":"Mouse wheel or touchpad scroll downwards.","title":"SHIFT_SCROLL_DOWN"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseAction.SHIFT_SCROLL_UP","text":"Mouse wheel or touchpad scroll upwards.","title":"SHIFT_SCROLL_UP"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseEvent","text":"A class to represent events created by mouse actions. Its first argument is a MouseAction describing what happened, and its second argument is a tuple[int, int] describing where it happened. This class mostly exists for readability & typing reasons. It also implements the iterable protocol, so you can use the unpacking syntax, such as: action , position = MouseEvent ( ... ) Source code in pytermgui/ansi_interface.py 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 @dataclass class MouseEvent : \"\"\"A class to represent events created by mouse actions. Its first argument is a `MouseAction` describing what happened, and its second argument is a `tuple[int, int]` describing where it happened. This class mostly exists for readability & typing reasons. It also implements the iterable protocol, so you can use the unpacking syntax, such as: ```python3 action, position = MouseEvent(...) ``` \"\"\" action : MouseAction position : tuple [ int , int ] def __post_init__ ( self ) -> None : \"\"\"Initialize iteration counter\"\"\" self . _iter_index = 0 def __next__ ( self ) -> MouseAction | tuple [ int , int ]: \"\"\"Get next iteration item\"\"\" data = fields ( self ) if self . _iter_index >= len ( data ): self . _iter_index = 0 raise StopIteration self . _iter_index += 1 return getattr ( self , data [ self . _iter_index - 1 ] . name ) def __iter__ ( self ) -> MouseEvent : \"\"\"Start iteration\"\"\" return self def is_scroll ( self ) -> bool : \"\"\"Returns True if event.action is one of the scrolling actions.\"\"\" return self . action in { MouseAction . SCROLL_DOWN , MouseAction . SCROLL_UP } def is_primary ( self ) -> bool : \"\"\"Returns True if event.action is one of the primary (left-button) actions.\"\"\" return self . action in { MouseAction . LEFT_CLICK , MouseAction . LEFT_DRAG } def is_secondary ( self ) -> bool : \"\"\"Returns True if event.action is one of the secondary (secondary-button) actions.\"\"\" return self . action in { MouseAction . RIGHT_CLICK , MouseAction . RIGHT_DRAG }","title":"MouseEvent"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseEvent.__iter__","text":"Start iteration Source code in pytermgui/ansi_interface.py 450 451 452 453 def __iter__ ( self ) -> MouseEvent : \"\"\"Start iteration\"\"\" return self","title":"__iter__()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseEvent.__next__","text":"Get next iteration item Source code in pytermgui/ansi_interface.py 438 439 440 441 442 443 444 445 446 447 448 def __next__ ( self ) -> MouseAction | tuple [ int , int ]: \"\"\"Get next iteration item\"\"\" data = fields ( self ) if self . _iter_index >= len ( data ): self . _iter_index = 0 raise StopIteration self . _iter_index += 1 return getattr ( self , data [ self . _iter_index - 1 ] . name )","title":"__next__()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseEvent.__post_init__","text":"Initialize iteration counter Source code in pytermgui/ansi_interface.py 433 434 435 436 def __post_init__ ( self ) -> None : \"\"\"Initialize iteration counter\"\"\" self . _iter_index = 0","title":"__post_init__()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseEvent.is_primary","text":"Returns True if event.action is one of the primary (left-button) actions. Source code in pytermgui/ansi_interface.py 460 461 462 463 def is_primary ( self ) -> bool : \"\"\"Returns True if event.action is one of the primary (left-button) actions.\"\"\" return self . action in { MouseAction . LEFT_CLICK , MouseAction . LEFT_DRAG }","title":"is_primary()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseEvent.is_scroll","text":"Returns True if event.action is one of the scrolling actions. Source code in pytermgui/ansi_interface.py 455 456 457 458 def is_scroll ( self ) -> bool : \"\"\"Returns True if event.action is one of the scrolling actions.\"\"\" return self . action in { MouseAction . SCROLL_DOWN , MouseAction . SCROLL_UP }","title":"is_scroll()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseEvent.is_secondary","text":"Returns True if event.action is one of the secondary (secondary-button) actions. Source code in pytermgui/ansi_interface.py 465 466 467 468 def is_secondary ( self ) -> bool : \"\"\"Returns True if event.action is one of the secondary (secondary-button) actions.\"\"\" return self . action in { MouseAction . RIGHT_CLICK , MouseAction . RIGHT_DRAG }","title":"is_secondary()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.blink","text":"Returns text blinking. Parameters: Name Type Description Default reset_style Optional [ bool ] Boolean that determines whether a reset character should be appended to the end of the string. True Source code in pytermgui/ansi_interface.py 681 682 683 684 685 686 687 688 689 def blink ( text : str , reset_style : Optional [ bool ] = True ) -> str : \"\"\"Returns text blinking. Args: reset_style: Boolean that determines whether a reset character should be appended to the end of the string. \"\"\" return set_mode ( \"blink\" , False ) + text + ( reset () if reset_style else \"\" )","title":"blink()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.bold","text":"Returns text in bold. Parameters: Name Type Description Default reset_style Optional [ bool ] Boolean that determines whether a reset character should be appended to the end of the string. True Source code in pytermgui/ansi_interface.py 637 638 639 640 641 642 643 644 645 def bold ( text : str , reset_style : Optional [ bool ] = True ) -> str : \"\"\"Returns text in bold. Args: reset_style: Boolean that determines whether a reset character should be appended to the end of the string. \"\"\" return set_mode ( \"bold\" , False ) + text + ( reset () if reset_style else \"\" )","title":"bold()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.clear","text":"Clears the specified screen region. Parameters: Name Type Description Default what str The specifier defining the screen area. 'screen' Available options: * screen: clear whole screen and go to origin * bos: clear screen from cursor backwards * eos: clear screen from cursor forwards * line: clear line and go to beginning * bol: clear line from cursor backwards * eol: clear line from cursor forwards Source code in pytermgui/ansi_interface.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def clear ( what : str = \"screen\" ) -> None : \"\"\"Clears the specified screen region. Args: what: The specifier defining the screen area. Available options: * screen: clear whole screen and go to origin * bos: clear screen from cursor backwards * eos: clear screen from cursor forwards * line: clear line and go to beginning * bol: clear line from cursor backwards * eol: clear line from cursor forwards \"\"\" commands = { \"eos\" : \" \\x1b [0J\" , \"bos\" : \" \\x1b [1J\" , \"screen\" : \" \\x1b [2J\" , \"eol\" : \" \\x1b [0K\" , \"bol\" : \" \\x1b [1K\" , \"line\" : \" \\x1b [2K\" , } get_terminal () . write ( commands [ what ])","title":"clear()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.cursor_column","text":"Moves the cursor to the num -th character of the current line. Parameters: Name Type Description Default num int The new cursor position. 0 Note This does not flush the terminal for performance reasons. You can do it manually with sys.stdout.flush() . Source code in pytermgui/ansi_interface.py 276 277 278 279 280 281 282 283 284 285 286 287 def cursor_column ( num : int = 0 ) -> None : \"\"\"Moves the cursor to the `num`-th character of the current line. Args: num: The new cursor position. Note: This does not flush the terminal for performance reasons. You can do it manually with `sys.stdout.flush()`. \"\"\" get_terminal () . write ( f \" \\x1b [ { num } G\" )","title":"cursor_column()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.cursor_down","text":"Moves the cursor up by num lines. Parameters: Name Type Description Default num int How many lines the cursor should move by. Must be positive, to move in the opposite direction use cursor_up . 1 Note This does not flush the terminal for performance reasons. You can do it manually with sys.stdout.flush() . Source code in pytermgui/ansi_interface.py 206 207 208 209 210 211 212 213 214 215 216 217 def cursor_down ( num : int = 1 ) -> None : \"\"\"Moves the cursor up by `num` lines. Args: num: How many lines the cursor should move by. Must be positive, to move in the opposite direction use `cursor_up`. Note: This does not flush the terminal for performance reasons. You can do it manually with `sys.stdout.flush()`. \"\"\" get_terminal () . write ( f \" \\x1b [ { num } B\" )","title":"cursor_down()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.cursor_home","text":"Moves cursor to get_terminal().origin . Note This does not flush the terminal for performance reasons. You can do it manually with sys.stdout.flush() . Source code in pytermgui/ansi_interface.py 290 291 292 293 294 295 296 297 298 def cursor_home () -> None : \"\"\"Moves cursor to `get_terminal().origin`. Note: This does not flush the terminal for performance reasons. You can do it manually with `sys.stdout.flush()`. \"\"\" get_terminal () . write ( \" \\x1b [H\" )","title":"cursor_home()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.cursor_left","text":"Moves the cursor left by num lines. Parameters: Name Type Description Default num int How many characters the cursor should move by. Must be positive, to move in the opposite direction use cursor_right . 1 Note This does not flush the terminal for performance reasons. You can do it manually with sys.stdout.flush() . Source code in pytermgui/ansi_interface.py 234 235 236 237 238 239 240 241 242 243 244 245 def cursor_left ( num : int = 1 ) -> None : \"\"\"Moves the cursor left by `num` lines. Args: num: How many characters the cursor should move by. Must be positive, to move in the opposite direction use `cursor_right`. Note: This does not flush the terminal for performance reasons. You can do it manually with `sys.stdout.flush()`. \"\"\" get_terminal () . write ( f \" \\x1b [ { num } D\" )","title":"cursor_left()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.cursor_next_line","text":"Moves the cursor to the beginning of the num -th line downwards. Parameters: Name Type Description Default num int The amount the cursor should move by. Must be positive, to move in the opposite direction use cursor_prev_line . 1 Note This does not flush the terminal for performance reasons. You can do it manually with sys.stdout.flush() . Source code in pytermgui/ansi_interface.py 248 249 250 251 252 253 254 255 256 257 258 259 def cursor_next_line ( num : int = 1 ) -> None : \"\"\"Moves the cursor to the beginning of the `num`-th line downwards. Args: num: The amount the cursor should move by. Must be positive, to move in the opposite direction use `cursor_prev_line`. Note: This does not flush the terminal for performance reasons. You can do it manually with `sys.stdout.flush()`. \"\"\" get_terminal () . write ( f \" \\x1b [ { num } E\" )","title":"cursor_next_line()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.cursor_prev_line","text":"Moves the cursor to the beginning of the num -th line upwards. Parameters: Name Type Description Default num int The amount the cursor should move by. Must be positive, to move in the opposite direction use cursor_next_line . 1 Note This does not flush the terminal for performance reasons. You can do it manually with sys.stdout.flush() . Source code in pytermgui/ansi_interface.py 262 263 264 265 266 267 268 269 270 271 272 273 def cursor_prev_line ( num : int = 1 ) -> None : \"\"\"Moves the cursor to the beginning of the `num`-th line upwards. Args: num: The amount the cursor should move by. Must be positive, to move in the opposite direction use `cursor_next_line`. Note: This does not flush the terminal for performance reasons. You can do it manually with `sys.stdout.flush()`. \"\"\" get_terminal () . write ( f \" \\x1b [ { num } F\" )","title":"cursor_prev_line()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.cursor_right","text":"Moves the cursor right by num lines. Parameters: Name Type Description Default num int How many characters the cursor should move by. Must be positive, to move in the opposite direction use cursor_left . 1 Note This does not flush the terminal for performance reasons. You can do it manually with sys.stdout.flush() . Source code in pytermgui/ansi_interface.py 220 221 222 223 224 225 226 227 228 229 230 231 def cursor_right ( num : int = 1 ) -> None : \"\"\"Moves the cursor right by `num` lines. Args: num: How many characters the cursor should move by. Must be positive, to move in the opposite direction use `cursor_left`. Note: This does not flush the terminal for performance reasons. You can do it manually with `sys.stdout.flush()`. \"\"\" get_terminal () . write ( f \" \\x1b [ { num } C\" )","title":"cursor_right()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.cursor_up","text":"Moves the cursor up by num lines. Parameters: Name Type Description Default num int How many lines the cursor should move by. Must be positive, to move in the opposite direction use cursor_down . 1 Note This does not flush the terminal for performance reasons. You can do it manually with sys.stdout.flush() . Source code in pytermgui/ansi_interface.py 192 193 194 195 196 197 198 199 200 201 202 203 def cursor_up ( num : int = 1 ) -> None : \"\"\"Moves the cursor up by `num` lines. Args: num: How many lines the cursor should move by. Must be positive, to move in the opposite direction use `cursor_down`. Note: This does not flush the terminal for performance reasons. You can do it manually with `sys.stdout.flush()`. \"\"\" get_terminal () . write ( f \" \\x1b [ { num } A\" )","title":"cursor_up()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.dim","text":"Returns text in dim. Parameters: Name Type Description Default reset_style Optional [ bool ] Boolean that determines whether a reset character should be appended to the end of the string. True Source code in pytermgui/ansi_interface.py 648 649 650 651 652 653 654 655 656 def dim ( text : str , reset_style : Optional [ bool ] = True ) -> str : \"\"\"Returns text in dim. Args: reset_style: Boolean that determines whether a reset character should be appended to the end of the string. \"\"\" return set_mode ( \"dim\" , False ) + text + ( reset () if reset_style else \"\" )","title":"dim()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.hide_cursor","text":"Stops printing the cursor. Source code in pytermgui/ansi_interface.py 129 130 131 132 def hide_cursor () -> None : \"\"\"Stops printing the cursor.\"\"\" get_terminal () . write ( \" \\x1b [?25l\" )","title":"hide_cursor()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.inverse","text":"Returns text inverse-colored. Parameters: Name Type Description Default reset_style Optional [ bool ] Boolean that determines whether a reset character should be appended to the end of the string. True Source code in pytermgui/ansi_interface.py 692 693 694 695 696 697 698 699 700 def inverse ( text : str , reset_style : Optional [ bool ] = True ) -> str : \"\"\"Returns text inverse-colored. Args: reset_style: Boolean that determines whether a reset character should be appended to the end of the string. \"\"\" return set_mode ( \"inverse\" , False ) + text + ( reset () if reset_style else \"\" )","title":"inverse()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.invisible","text":"Returns text as invisible. Parameters: Name Type Description Default reset_style Optional [ bool ] Boolean that determines whether a reset character should be appended to the end of the string. True Note This isn't very widely supported. Source code in pytermgui/ansi_interface.py 703 704 705 706 707 708 709 710 711 712 713 714 def invisible ( text : str , reset_style : Optional [ bool ] = True ) -> str : \"\"\"Returns text as invisible. Args: reset_style: Boolean that determines whether a reset character should be appended to the end of the string. Note: This isn't very widely supported. \"\"\" return set_mode ( \"invisible\" , False ) + text + ( reset () if reset_style else \"\" )","title":"invisible()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.italic","text":"Returns text in italic. Parameters: Name Type Description Default reset_style Optional [ bool ] Boolean that determines whether a reset character should be appended to the end of the string. True Source code in pytermgui/ansi_interface.py 659 660 661 662 663 664 665 666 667 def italic ( text : str , reset_style : Optional [ bool ] = True ) -> str : \"\"\"Returns text in italic. Args: reset_style: Boolean that determines whether a reset character should be appended to the end of the string. \"\"\" return set_mode ( \"italic\" , False ) + text + ( reset () if reset_style else \"\" )","title":"italic()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.move_cursor","text":"Moves the cursor. Parameters: Name Type Description Default pos tuple [ int , int ] Tuple of that the cursor will be moved to. required This does not flush the terminal for performance reasons. You can do it manually with sys.stdout.flush() . Source code in pytermgui/ansi_interface.py 178 179 180 181 182 183 184 185 186 187 188 189 def move_cursor ( pos : tuple [ int , int ]) -> None : \"\"\"Moves the cursor. Args: pos: Tuple of that the cursor will be moved to. This does not flush the terminal for performance reasons. You can do it manually with `sys.stdout.flush()`. \"\"\" posx , posy = pos get_terminal () . write ( f \" \\x1b [ { posy } ; { posx } H\" )","title":"move_cursor()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.overline","text":"Return text overlined. Parameters: Name Type Description Default reset_style Optional [ bool ] Boolean that determines whether a reset character should be appended to the end of the string. True Note This isnt' very widely supported. Source code in pytermgui/ansi_interface.py 728 729 730 731 732 733 734 735 736 737 738 739 def overline ( text : str , reset_style : Optional [ bool ] = True ) -> str : \"\"\"Return text overlined. Args: reset_style: Boolean that determines whether a reset character should be appended to the end of the string. Note: This isnt' very widely supported. \"\"\" return set_mode ( \"overline\" , False ) + text + ( reset () if reset_style else \"\" )","title":"overline()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.print_to","text":"Prints text to given pos . Note This method passes through all arguments (except for pos ) to the print method. Source code in pytermgui/ansi_interface.py 619 620 621 622 623 624 625 626 627 628 def print_to ( pos : tuple [ int , int ], * args : Any , ** kwargs : Any ) -> None : \"\"\"Prints text to given `pos`. Note: This method passes through all arguments (except for `pos`) to the `print` method. \"\"\" move_cursor ( pos ) print ( * args , ** kwargs )","title":"print_to()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.report_cursor","text":"Gets position of cursor. Returns: Type Description Optional [ tuple [ int , int ]] A tuple of integers, (columns, rows), describing the Optional [ tuple [ int , int ]] current (printing) cursor's position. Returns None if Optional [ tuple [ int , int ]] this could not be determined. Optional [ tuple [ int , int ]] Note that this position is not the mouse position. See Optional [ tuple [ int , int ]] report_mouse if that is what you are interested in. Source code in pytermgui/ansi_interface.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def report_cursor () -> Optional [ tuple [ int , int ]]: \"\"\"Gets position of cursor. Returns: A tuple of integers, (columns, rows), describing the current (printing) cursor's position. Returns None if this could not be determined. Note that this position is **not** the mouse position. See `report_mouse` if that is what you are interested in. \"\"\" get_terminal () . write ( \" \\x1b [6n\" , flush = True ) chars = getch () posy , posx = chars [ 2 : - 1 ] . split ( \";\" ) if not posx . isdigit () or not posy . isdigit (): return None return int ( posx ), int ( posy )","title":"report_cursor()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.report_mouse","text":"Starts reporting of mouse events. You can specify multiple events to report on. Parameters: Name Type Description Default event str The type of event to report on. See below for options. required method Optional [ str ] The method of reporting to use. See below for options. 'decimal_xterm' stop bool If set to True, the stopping code is written to stdout. False Raises: Type Description NotImplementedError The given event is not supported. Note If you need this functionality, you're probably better off using the wrapper pytermgui.context_managers.mouse_handler , which allows listening on multiple events, gives a translator method and handles exceptions. Possible events press : Report when the mouse is clicked, left or right button. highlight : Report highlighting. press_hold : Report with a left or right click, as well as both left & right drag and release. hover : Report even when no active action is done, only the mouse is moved. Methods None : Non-decimal xterm method. Limited in coordinates. decimal_xterm : The default setting. Most universally supported. decimal_urxvt : Older, less compatible, but useful on some systems. decimal_utf8 : Apparently not too stable. More information here . Source code in pytermgui/ansi_interface.py 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 def report_mouse ( event : str , method : Optional [ str ] = \"decimal_xterm\" , stop : bool = False ) -> None : \"\"\"Starts reporting of mouse events. You can specify multiple events to report on. Args: event: The type of event to report on. See below for options. method: The method of reporting to use. See below for options. stop: If set to True, the stopping code is written to stdout. Raises: NotImplementedError: The given event is not supported. Note: If you need this functionality, you're probably better off using the wrapper `pytermgui.context_managers.mouse_handler`, which allows listening on multiple events, gives a translator method and handles exceptions. Possible events: - **press**: Report when the mouse is clicked, left or right button. - **highlight**: Report highlighting. - **press_hold**: Report with a left or right click, as well as both left & right drag and release. - **hover**: Report even when no active action is done, only the mouse is moved. Methods: - **None**: Non-decimal xterm method. Limited in coordinates. - **decimal_xterm**: The default setting. Most universally supported. - **decimal_urxvt**: Older, less compatible, but useful on some systems. - **decimal_utf8**: Apparently not too stable. More information <a href='https://stackoverflow.com/a/5970472'>here</a>. \"\"\" if event == \"press\" : get_terminal () . write ( \" \\x1b [?1000\" ) elif event == \"highlight\" : get_terminal () . write ( \" \\x1b [?1001\" ) elif event == \"press_hold\" : get_terminal () . write ( \" \\x1b [?1002\" ) elif event == \"hover\" : get_terminal () . write ( \" \\x1b [?1003\" ) else : raise NotImplementedError ( f \"Mouse report event { event } is not supported!\" ) get_terminal () . write ( \"l\" if stop else \"h\" ) if method == \"decimal_utf8\" : get_terminal () . write ( \" \\x1b [?1005\" ) elif method == \"decimal_xterm\" : get_terminal () . write ( \" \\x1b [?1006\" ) elif method == \"decimal_urxvt\" : get_terminal () . write ( \" \\x1b [?1015\" ) elif method is None : return else : raise NotImplementedError ( f \"Mouse report method { method } is not supported!\" ) get_terminal () . write ( \"l\" if stop else \"h\" , flush = True )","title":"report_mouse()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.reset","text":"Resets printing mode. Source code in pytermgui/ansi_interface.py 631 632 633 634 def reset () -> str : \"\"\"Resets printing mode.\"\"\" return set_mode ( \"reset\" , False )","title":"reset()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.restore_cursor","text":"Restore cursor position as saved by save_cursor . Source code in pytermgui/ansi_interface.py 150 151 152 153 def restore_cursor () -> None : \"\"\"Restore cursor position as saved by `save_cursor`.\"\"\" get_terminal () . write ( \" \\x1b [u\" )","title":"restore_cursor()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.restore_screen","text":"Restores the contents of the screen saved by save_screen() . Source code in pytermgui/ansi_interface.py 83 84 85 86 def restore_screen () -> None : \"\"\"Restores the contents of the screen saved by `save_screen()`.\"\"\" print ( \" \\x1b [?47l\" )","title":"restore_screen()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.save_cursor","text":"Saves the current cursor position. Use restore_cursor to restore it. Source code in pytermgui/ansi_interface.py 141 142 143 144 145 146 147 def save_cursor () -> None : \"\"\"Saves the current cursor position. Use `restore_cursor` to restore it. \"\"\" get_terminal () . write ( \" \\x1b [s\" )","title":"save_cursor()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.save_screen","text":"Saves the contents of the screen, and wipes it. Use restore_screen() to get them back. Source code in pytermgui/ansi_interface.py 74 75 76 77 78 79 80 def save_screen () -> None : \"\"\"Saves the contents of the screen, and wipes it. Use `restore_screen()` to get them back. \"\"\" print ( \" \\x1b [?47h\" )","title":"save_screen()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.set_alt_buffer","text":"Starts an alternate buffer. Source code in pytermgui/ansi_interface.py 89 90 91 92 def set_alt_buffer () -> None : \"\"\"Starts an alternate buffer.\"\"\" print ( \" \\x1b [?1049h\" )","title":"set_alt_buffer()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.set_echo","text":"Starts echoing of user input. Note This is currently only available on POSIX. Source code in pytermgui/ansi_interface.py 351 352 353 354 355 356 357 358 359 360 361 def set_echo () -> None : \"\"\"Starts echoing of user input. Note: This is currently only available on POSIX. \"\"\" if not _name == \"posix\" : return system ( \"stty echo\" )","title":"set_echo()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.set_mode","text":"Sets terminal display mode. This is better left internal. To use these modes, you can call their specific functions, such as bold(\"text\") or italic(\"text\") . Parameters: Name Type Description Default mode Union [ str , int ] One of the available modes. Strings and integers both work. required write bool Boolean that determines whether the output should be written to stdout. True Returns: Type Description str A string that sets the given mode. Available modes 0: reset 1: bold 2: dim 3: italic 4: underline 5: blink 7: inverse 8: invisible 9: strikethrough 53: overline Source code in pytermgui/ansi_interface.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 def set_mode ( mode : Union [ str , int ], write : bool = True ) -> str : \"\"\"Sets terminal display mode. This is better left internal. To use these modes, you can call their specific functions, such as `bold(\"text\")` or `italic(\"text\")`. Args: mode: One of the available modes. Strings and integers both work. write: Boolean that determines whether the output should be written to stdout. Returns: A string that sets the given mode. Available modes: - 0: reset - 1: bold - 2: dim - 3: italic - 4: underline - 5: blink - 7: inverse - 8: invisible - 9: strikethrough - 53: overline \"\"\" options = { \"reset\" : 0 , \"bold\" : 1 , \"dim\" : 2 , \"italic\" : 3 , \"underline\" : 4 , \"blink\" : 5 , \"inverse\" : 7 , \"invisible\" : 8 , \"strikethrough\" : 9 , \"overline\" : 53 , } if not str ( mode ) . isdigit (): mode = options [ str ( mode )] code = f \" \\x1b [ { mode } m\" if write : get_terminal () . write ( code ) return code","title":"set_mode()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.show_cursor","text":"Starts printing the cursor. Source code in pytermgui/ansi_interface.py 135 136 137 138 def show_cursor () -> None : \"\"\"Starts printing the cursor.\"\"\" get_terminal () . write ( \" \\x1b [?25h\" )","title":"show_cursor()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.strikethrough","text":"Return text as strikethrough. Parameters: Name Type Description Default reset_style Optional [ bool ] Boolean that determines whether a reset character should be appended to the end of the string. True Source code in pytermgui/ansi_interface.py 717 718 719 720 721 722 723 724 725 def strikethrough ( text : str , reset_style : Optional [ bool ] = True ) -> str : \"\"\"Return text as strikethrough. Args: reset_style: Boolean that determines whether a reset character should be appended to the end of the string. \"\"\" return set_mode ( \"strikethrough\" , False ) + text + ( reset () if reset_style else \"\" )","title":"strikethrough()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.translate_mouse","text":"Translates the output of produced by setting report_mouse into MouseEvents. This method currently only supports decimal_xterm and decimal_urxvt . Parameters: Name Type Description Default code str The string of mouse code(s) to translate. required method str The reporting method to translate. One of decimal_xterm , decimal_urxvt . required Returns: Type Description list [ MouseEvent | None] | None A list of optional mouse events obtained from the code argument. If the code was malformed, list [ MouseEvent | None] | None and no codes could be determined None is returned. Source code in pytermgui/ansi_interface.py 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 def translate_mouse ( code : str , method : str ) -> list [ MouseEvent | None ] | None : \"\"\"Translates the output of produced by setting `report_mouse` into MouseEvents. This method currently only supports `decimal_xterm` and `decimal_urxvt`. Args: code: The string of mouse code(s) to translate. method: The reporting method to translate. One of `decimal_xterm`, `decimal_urxvt`. Returns: A list of optional mouse events obtained from the code argument. If the code was malformed, and no codes could be determined None is returned. \"\"\" if code == \" \\x1b \" : return None mouse_codes = { \"decimal_xterm\" : { \"0M\" : MouseAction . LEFT_CLICK , \"0m\" : MouseAction . RELEASE , \"2M\" : MouseAction . RIGHT_CLICK , \"2m\" : MouseAction . RELEASE , \"32\" : MouseAction . LEFT_DRAG , \"34\" : MouseAction . RIGHT_DRAG , \"35\" : MouseAction . HOVER , \"64\" : MouseAction . SCROLL_UP , \"65\" : MouseAction . SCROLL_DOWN , \"68\" : MouseAction . SHIFT_SCROLL_UP , \"69\" : MouseAction . SHIFT_SCROLL_DOWN , }, \"decimal_urxvt\" : { \"32\" : MouseAction . LEFT_CLICK , \"34\" : MouseAction . RIGHT_CLICK , \"35\" : MouseAction . RELEASE , \"64\" : MouseAction . LEFT_DRAG , \"66\" : MouseAction . RIGHT_DRAG , \"96\" : MouseAction . SCROLL_UP , \"97\" : MouseAction . SCROLL_DOWN , }, } mapping = mouse_codes [ method ] pattern : Pattern = RE_MOUSE [ method ] events : list [ MouseEvent | None ] = [] for sequence in code . split ( \" \\x1b \" ): if len ( sequence ) == 0 : continue matches = list ( pattern . finditer ( sequence )) if len ( matches ) == 0 : return None for match in matches : identifier , * pos , release_code = match . groups () # decimal_xterm uses the last character's # capitalization to signify press/release state if len ( release_code ) > 0 and identifier in [ \"0\" , \"2\" ]: identifier += release_code if identifier in mapping : action = mapping [ identifier ] assert isinstance ( action , MouseAction ) events . append ( MouseEvent ( action , ( int ( pos [ 0 ]), int ( pos [ 1 ])))) continue events . append ( None ) return events","title":"translate_mouse()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.underline","text":"Returns text underlined. Parameters: Name Type Description Default reset_style Optional [ bool ] Boolean that determines whether a reset character should be appended to the end of the string. True Source code in pytermgui/ansi_interface.py 670 671 672 673 674 675 676 677 678 def underline ( text : str , reset_style : Optional [ bool ] = True ) -> str : \"\"\"Returns text underlined. Args: reset_style: Boolean that determines whether a reset character should be appended to the end of the string. \"\"\" return set_mode ( \"underline\" , False ) + text + ( reset () if reset_style else \"\" )","title":"underline()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.unset_alt_buffer","text":"Returns to main buffer, restoring its original state. Source code in pytermgui/ansi_interface.py 95 96 97 98 def unset_alt_buffer () -> None : \"\"\"Returns to main buffer, restoring its original state.\"\"\" print ( \" \\x1b [?1049l\" )","title":"unset_alt_buffer()"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.unset_echo","text":"Stops echoing of user input. Note This is currently only available on POSIX. Source code in pytermgui/ansi_interface.py 364 365 366 367 368 369 370 371 372 373 374 def unset_echo () -> None : \"\"\"Stops echoing of user input. Note: This is currently only available on POSIX. \"\"\" if not _name == \"posix\" : return system ( \"stty -echo\" )","title":"unset_echo()"},{"location":"reference/pytermgui/cmd/","text":"The command-line module of the library. See ptg --help for more information. AppWindow Bases: ptg . Window A generic application window. It contains a header with the app's title, as well as some global settings. Source code in pytermgui/cmd.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class AppWindow ( ptg . Window ): \"\"\"A generic application window. It contains a header with the app's title, as well as some global settings. \"\"\" app_title : str \"\"\"The display title of the application.\"\"\" app_id : str \"\"\"The short identifier used by ArgumentParser.\"\"\" standalone : bool \"\"\"Whether this app was launched directly from the CLI.\"\"\" overflow = ptg . Overflow . SCROLL vertical_align = ptg . VerticalAlignment . TOP def __init__ ( self , args : Namespace | None = None , ** attrs : Any ) -> None : super () . __init__ ( ** attrs ) self . standalone = bool ( getattr ( args , self . app_id , None )) bottom = ptg . Container . chars [ \"border\" ][ - 1 ] header_box = ptg . boxes . Box ( [ \"\" , \" x \" , bottom * 3 , ] ) self . _add_widget ( ptg . Container ( f \"[ptg.title] { self . app_title } \" , box = header_box )) self . _add_widget ( \"\" ) def setup ( self ) -> None : \"\"\"Centers window, sets its width & height.\"\"\" self . width = int ( self . terminal . width * 2 / 3 ) self . height = int ( self . terminal . height * 2 / 3 ) self . center ( store = False ) def on_exit ( self ) -> None : \"\"\"Called on application exit. Should be used to print current application state to the user's shell. \"\"\" ptg . tim . print ( f \" { _title () } - [dim] { self . app_title } \" ) print () app_id : str class-attribute The short identifier used by ArgumentParser. app_title : str class-attribute The display title of the application. on_exit () Called on application exit. Should be used to print current application state to the user's shell. Source code in pytermgui/cmd.py 70 71 72 73 74 75 76 77 def on_exit ( self ) -> None : \"\"\"Called on application exit. Should be used to print current application state to the user's shell. \"\"\" ptg . tim . print ( f \" { _title () } - [dim] { self . app_title } \" ) print () setup () Centers window, sets its width & height. Source code in pytermgui/cmd.py 63 64 65 66 67 68 def setup ( self ) -> None : \"\"\"Centers window, sets its width & height.\"\"\" self . width = int ( self . terminal . width * 2 / 3 ) self . height = int ( self . terminal . height * 2 / 3 ) self . center ( store = False ) ColorPickerWindow Bases: AppWindow A window to pick colors from the xterm-256 palette. Source code in pytermgui/cmd.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 class ColorPickerWindow ( AppWindow ): \"\"\"A window to pick colors from the xterm-256 palette.\"\"\" app_title = \"ColorPicker\" app_id = \"color\" def __init__ ( self , args : Namespace | None = None , ** attrs : Any ) -> None : super () . __init__ ( args , ** attrs ) self . _chosen_rgb = ptg . str_to_color ( \"black\" ) self . _colorpicker = ptg . ColorPicker () self . _add_widget ( ptg . FancyReprWidget ( ptg . palette , starts_at = 2 )) self . _add_widget ( ptg . Collapsible ( \"xterm-256\" , \"\" , self . _colorpicker )) self . _add_widget ( \"\" ) self . _add_widget ( ptg . Collapsible ( \"RGB & HEX\" , \"\" , self . _create_rgb_picker (), static_width = 81 ) ) self . setup () def _create_rgb_picker ( self ) -> ptg . Container : \"\"\"Creates the RGB picker 'widget'.\"\"\" root = ptg . Container ( static_width = 72 ) matrix = ptg . DensePixelMatrix ( 68 , 20 ) hexdisplay = ptg . Label () rgbdisplay = ptg . Label () sliders = [ ptg . Slider () for _ in range ( 3 )] def _get_rgb () -> tuple [ int , int , int ]: \"\"\"Computes the RGB value from the 3 sliders.\"\"\" values = [ int ( 255 * slider . value ) for slider in sliders ] return values [ 0 ], values [ 1 ], values [ 2 ] def _update ( * _ ) -> None : \"\"\"Updates the matrix & displays with the current color.\"\"\" color = self . _chosen_rgb = ptg . RGBColor . from_rgb ( _get_rgb ()) for row in range ( matrix . rows ): for col in range ( matrix . columns ): matrix [ row , col ] = color . hex hexdisplay . value = f \"[ptg.body] { color . hex } \" rgbdisplay . value = f \"[ptg.body]rgb( { ', ' . join ( map ( str , color . rgb )) } )\" matrix . build () red , green , blue = sliders # red.styles.filled_selected__cursor = \"red\" # green.styles.filled_selected__cursor = \"green\" # blue.styles.filled_selected__cursor = \"blue\" for slider in sliders : slider . onchange = _update root += hexdisplay root += rgbdisplay root += \"\" root += matrix root += \"\" root += red root += green root += blue _update () return root def on_exit ( self ) -> None : super () . on_exit () color = self . _chosen_rgb eightbit = \" \" . join ( button . get_lines ()[ 0 ] for button in self . _colorpicker . chosen ) ptg . tim . print ( \"[ptg.title]Your colors:\" ) ptg . tim . print ( f \" [ { color . hex } ] { color . rgb } [/] // [ { color . hex } ] { color . hex } \" ) ptg . tim . print () ptg . tim . print ( f \" { eightbit } \" ) GetchWindow Bases: AppWindow A window for the Getch utility. Source code in pytermgui/cmd.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 class GetchWindow ( AppWindow ): \"\"\"A window for the Getch utility.\"\"\" app_title = \"Getch\" app_id = \"getch\" def __init__ ( self , args : Namespace | None = None , ** attrs : Any ) -> None : super () . __init__ ( args , ** attrs ) self . bind ( ptg . keys . ANY_KEY , self . _update ) self . _content = ptg . Container ( \"Press any key...\" , static_width = 50 ) self . _add_widget ( self . _content ) self . setup () def _update ( self , _ : ptg . Widget , key : str ) -> None : \"\"\"Updates window contents on keypress.\"\"\" self . _content . set_widgets ([]) name = _get_key_name ( key ) if name != ascii ( key ): name = f \"keys. { name } \" style = ptg . HighlighterStyle ( ptg . highlight_python ) items = [ \"[ptg.title]Your output\" , \"\" , { \"[ptg.detail]key\" : ptg . Label ( name , style = style )}, { \"[ptg.detail]value:\" : ptg . Label ( ascii ( key ), style = style )}, { \"[ptg.detail]len()\" : ptg . Label ( str ( len ( key )), style = style )}, { \"[ptg.detail]real_length()\" : ptg . Label ( str ( ptg . real_length ( key )), style = style ) }, ] for item in items : self . _content += item if self . standalone : assert self . manager is not None self . manager . stop () def on_exit ( self ) -> None : super () . on_exit () for line in self . _content . get_lines (): print ( line ) InspectorWindow Bases: AppWindow A window for the inspect utility. Source code in pytermgui/cmd.py 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 class InspectorWindow ( AppWindow ): \"\"\"A window for the `inspect` utility.\"\"\" app_title = \"Inspector\" app_id = \"inspect\" def __init__ ( self , args : Namespace | None = None , ** attrs : Any ) -> None : super () . __init__ ( args , ** attrs ) self . _input = ptg . InputField ( value = \"boxes.Box\" ) self . _output = ptg . Container ( box = \"EMPTY\" ) self . _update () self . _input . bind ( ptg . keys . ENTER , self . _update ) self . _add_widget ( ptg . Container ( self . _output , \"\" , ptg . Container ( self . _input ), box = \"EMPTY\" , ) ) self . setup () self . select ( 0 ) @staticmethod def obj_from_path ( path : str ) -> object | None : \"\"\"Retrieves an object from any valid import path. An import path could be something like: pytermgui.window_manager.compositor.Compositor ...or if the library in question imports its parts within `__init__.py`-s: pytermgui.Compositor \"\"\" parts = path . split ( \".\" ) if parts [ 0 ] in dir ( builtins ): obj = getattr ( builtins , parts [ 0 ]) elif parts [ 0 ] in dir ( ptg ): obj = getattr ( ptg , parts [ 0 ]) else : try : obj = importlib . import_module ( \".\" . join ( parts [: - 1 ])) except ( ValueError , ModuleNotFoundError ) as error : return ( f \"Could not import object at path { path !r} : { error } .\" + \" Maybe try using the --eval flag?\" ) try : obj = getattr ( obj , parts [ - 1 ]) except AttributeError : return obj return obj def _update ( self , * _ ) -> None : \"\"\"Updates output with new inspection result.\"\"\" obj = self . obj_from_path ( self . _input . value ) self . _output . vertical_align = ptg . VerticalAlignment . CENTER self . _output . set_widgets ([ ptg . inspect ( obj )]) def on_exit ( self ) -> None : super () . on_exit () self . _output . vertical_align = ptg . VerticalAlignment . TOP for line in self . _output . get_lines (): print ( line ) obj_from_path ( path ) staticmethod Retrieves an object from any valid import path. An import path could be something like pytermgui.window_manager.compositor.Compositor ...or if the library in question imports its parts within __init__.py -s: pytermgui.Compositor Source code in pytermgui/cmd.py 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 @staticmethod def obj_from_path ( path : str ) -> object | None : \"\"\"Retrieves an object from any valid import path. An import path could be something like: pytermgui.window_manager.compositor.Compositor ...or if the library in question imports its parts within `__init__.py`-s: pytermgui.Compositor \"\"\" parts = path . split ( \".\" ) if parts [ 0 ] in dir ( builtins ): obj = getattr ( builtins , parts [ 0 ]) elif parts [ 0 ] in dir ( ptg ): obj = getattr ( ptg , parts [ 0 ]) else : try : obj = importlib . import_module ( \".\" . join ( parts [: - 1 ])) except ( ValueError , ModuleNotFoundError ) as error : return ( f \"Could not import object at path { path !r} : { error } .\" + \" Maybe try using the --eval flag?\" ) try : obj = getattr ( obj , parts [ - 1 ]) except AttributeError : return obj return obj TIMWindow Bases: AppWindow An application to play around with TIM. Source code in pytermgui/cmd.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 class TIMWindow ( AppWindow ): \"\"\"An application to play around with TIM.\"\"\" app_title = \"TIM Playground\" app_id = \"tim\" def __init__ ( self , args : Namespace | None = None , ** attrs : Any ) -> None : super () . __init__ ( args , ** attrs ) if self . standalone : self . bind ( ptg . keys . RETURN , lambda * _ : self . manager . stop () if self . manager is not None else None , ) self . _generate_colors () self . _output = ptg . Label ( parent_align = 0 ) self . _input = ptg . InputField () self . _input . styles . value__fill = lambda _ , item : item self . _showcase = self . _create_showcase () self . _input . bind ( ptg . keys . ANY_KEY , lambda * _ : self . _update_output ()) self . _add_widget ( ptg . Container ( ptg . Container ( self . _output ), self . _showcase , ptg . Container ( self . _input ), box = \"EMPTY\" , static_width = 60 , ) ) self . bind ( ptg . keys . CTRL_R , self . _generate_colors ) self . setup () self . select ( 0 ) @staticmethod def _random_rgb () -> ptg . Color : \"\"\"Returns a random Color.\"\"\" rgb = tuple ( random . randint ( 0 , 255 ) for _ in range ( 3 )) return ptg . RGBColor . from_rgb ( rgb ) # type: ignore def _update_output ( self ) -> None : \"\"\"Updates the output field.\"\"\" self . _output . value = self . _input . value def _generate_colors ( self , * _ ) -> None : \"\"\"Generates self._example_{255,rgb,hex}.\"\"\" ptg . tim . alias ( \"ptg.timwindow.255\" , str ( random . randint ( 16 , 233 ))) ptg . tim . alias ( \"ptg.timwindow.rgb\" , \";\" . join ( map ( str , self . _random_rgb () . rgb ))) ptg . tim . alias ( \"ptg.timwindow.hex\" , self . _random_rgb () . hex ) @staticmethod def _create_showcase () -> ptg . Container : \"\"\"Creates the showcase container.\"\"\" def _show_style ( name : str ) -> str : return f \"[ { name } ] { name } \" # .replace(\"'\", \"\") def _create_table ( source : Iterable [ tuple [ str , str ]]) -> ptg . Container : root = ptg . Container () for left , right in source : row = ptg . Splitter ( ptg . Label ( left , parent_align = 0 ), ptg . Label ( right , parent_align = 2 ) ) row . set_char ( \"separator\" , f \" { ptg . Container . chars [ 'border' ][ 0 ] } \" ) root += row return root prefix = \"ptg.timwindow\" tags = [ _show_style ( style ) for style in ptg . markup . style_maps . STYLES ] colors = [ f \"[[ { prefix } .255]0-255[/]]\" , f \"[[ { prefix } .hex]#RRGGBB[/]]\" , f \"[[ { prefix } .rgb]RRR;GGG;BBB[/]]\" , \"\" , f \"[[inverse { prefix } .255]@0-255[/]]\" , f \"[[inverse { prefix } .hex]@#RRGGBB[/]]\" , f \"[[inverse { prefix } .rgb]@RRR;GGG;BBB[/]]\" , ] tag_container = _create_table ( zip_longest ( tags , colors , fillvalue = \"\" )) user_container = _create_table ( ( _show_style ( tag ), f \"[ { tag } ] { value } \" ) for tag , value in ptg . tim . aliases . items () if not tag . startswith ( \"/\" ) and tag not in ptg . palette . data ) return ptg . Container ( tag_container , user_container , box = \"EMPTY\" ) def on_exit ( self ) -> None : super () . on_exit () ptg . tim . print ( ptg . highlight_tim ( self . _input . value )) ptg . tim . print ( self . _input . value ) main ( argv = None ) Runs the program. Parameters: Name Type Description Default argv list [ str ] | None A list of arguments, not included the 0th element pointing to the executable path. None Source code in pytermgui/cmd.py 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 def main ( argv : list [ str ] | None = None ) -> None : \"\"\"Runs the program. Args: argv: A list of arguments, not included the 0th element pointing to the executable path. \"\"\" _create_aliases () args = process_args ( argv ) args . app = args . app or ( \"getch\" if args . getch else ( \"tim\" if args . tim else ( \"color\" if args . color else None )) ) if args . app or len ( sys . argv ) == 1 : run_environment ( args ) return with ptg . terminal . record () as recording : if args . size : ptg . tim . print ( f \" { ptg . terminal . width } x { ptg . terminal . height } \" ) elif args . version : _print_version () elif args . palette : ptg . palette . print () elif args . inspect : _run_inspect ( args ) elif args . exec : args . exec = sys . stdin . read () if args . exec == \"-\" else args . exec for name in dir ( ptg ): obj = getattr ( ptg , name , None ) globals ()[ name ] = obj globals ()[ \"print\" ] = ptg . terminal . print exec ( args . exec , locals (), globals ()) # pylint: disable=exec-used elif args . highlight : text = sys . stdin . read () if args . highlight == \"-\" else args . highlight ptg . tim . print ( ptg . highlight_python ( text )) elif args . file : _interpret_file ( args ) if args . export_svg : recording . save_svg ( args . export_svg ) elif args . export_html : recording . save_html ( args . export_html ) process_args ( argv = None ) Processes command line arguments. Source code in pytermgui/cmd.py 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 def process_args ( argv : list [ str ] | None = None ) -> Namespace : \"\"\"Processes command line arguments.\"\"\" parser = ArgumentParser ( description = f \" { ptg . tim . parse ( _title ()) } 's command line environment.\" ) apps = [ short for ( _ , short ), _ in APPLICATION_MAP . items ()] app_group = parser . add_argument_group ( \"Applications\" ) app_group . add_argument ( \"--app\" , type = str . lower , help = \"Launch an app.\" , metavar = f \" { ', ' . join ( app . capitalize () for app in apps ) } \" , choices = apps , ) app_group . add_argument ( \"-g\" , \"--getch\" , help = \"Launch the Getch app.\" , action = \"store_true\" ) app_group . add_argument ( \"-t\" , \"--tim\" , help = \"Launch the TIM Playground app.\" , action = \"store_true\" ) app_group . add_argument ( \"-c\" , \"--color\" , help = \"Launch the ColorPicker app.\" , action = \"store_true\" , ) inspect_group = parser . add_argument_group ( \"Inspection\" ) inspect_group . add_argument ( \"-i\" , \"--inspect\" , help = \"Inspect an object.\" , metavar = \"PATH_OR_CODE\" ) inspect_group . add_argument ( \"-e\" , \"--eval\" , help = \"Evaluate the expression given to `--inspect` instead of treating it as a path.\" , action = \"store_true\" , ) inspect_group . add_argument ( \"--methods\" , help = \"Always show methods when inspecting.\" , action = \"store_true\" ) inspect_group . add_argument ( \"--dunder\" , help = \"Always show __dunder__ methods when inspecting.\" , action = \"store_true\" , ) inspect_group . add_argument ( \"--private\" , help = \"Always show _private methods when inspecting.\" , action = \"store_true\" , ) util_group = parser . add_argument_group ( \"Utilities\" ) util_group . add_argument ( \"-s\" , \"--size\" , help = \"Output the current terminal size in WxH format.\" , action = \"store_true\" , ) util_group . add_argument ( \"-v\" , \"--version\" , help = \"Print version & system information.\" , action = \"store_true\" , ) util_group . add_argument ( \"--palette\" , help = \"Print the default PyTermGUI color palette.\" , action = \"store_true\" , ) util_group . add_argument ( \"--highlight\" , help = ( \"Highlight some python-like code syntax.\" + \" No argument or '-' will read STDIN.\" ), metavar = \"SYNTAX\" , const = \"-\" , nargs = \"?\" , ) util_group . add_argument ( \"--exec\" , help = \"Execute some Python code. No argument or '-' will read STDIN.\" , const = \"-\" , nargs = \"?\" , ) util_group . add_argument ( \"-f\" , \"--file\" , help = \"Interpret a PTG-YAML file.\" ) util_group . add_argument ( \"--print-only\" , help = \"When interpreting YAML, print the environment without running it interactively.\" , action = \"store_true\" , ) export_group = parser . add_argument_group ( \"Exporters\" ) export_group . add_argument ( \"--export-svg\" , help = \"Export the result of any non-interactive argument as an SVG file.\" , metavar = \"FILE\" , ) export_group . add_argument ( \"--export-html\" , help = \"Export the result of any non-interactive argument as an HTML file.\" , metavar = \"FILE\" , ) argv = argv or sys . argv [ 1 :] args = parser . parse_args ( args = argv ) return args run_environment ( args ) Runs the WindowManager environment. Parameters: Name Type Description Default args Namespace An argparse namespace containing relevant arguments. required Source code in pytermgui/cmd.py 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 def run_environment ( args : Namespace ) -> None : \"\"\"Runs the WindowManager environment. Args: args: An argparse namespace containing relevant arguments. \"\"\" def _find_focused ( manager : ptg . WindowManager ) -> ptg . Window | None : if manager . focused is None : return None # Find foremost non-persistent window for window in manager : if window . is_persistent : continue return window return None def _toggle_attachment ( manager : ptg . WindowManager ) -> None : focused = _find_focused ( manager ) if focused is None : return slot = manager . layout . body if slot . content is None : slot . content = focused else : slot . detach_content () manager . layout . apply () def _close_focused ( manager : ptg . WindowManager ) -> None : focused = _find_focused ( manager ) if focused is None : return focused . close () _configure_widgets () window : AppWindow | None = None with ptg . WindowManager () as manager : app_picker = _create_app_picker ( manager ) manager . bind ( ptg . keys . CTRL_W , lambda * _ : _close_focused ( manager ), \"Close window\" , ) manager . bind ( ptg . keys . F12 , lambda * _ : screenshot ( manager ), \"Screenshot\" , ) manager . bind ( ptg . keys . CTRL_F , lambda * _ : _toggle_attachment ( manager ), \"Toggle layout\" , ) manager . bind ( ptg . keys . CTRL_A , lambda * _ : { manager . focus ( app_picker ), # type: ignore app_picker . execute_binding ( ptg . keys . CTRL_A ), }, ) manager . bind ( ptg . keys . ALT + ptg . keys . TAB , lambda * _ : manager . focus_next (), ) manager . bind ( \"!\" , lambda * _ : ptg . palette . regenerate ( primary = \";\" . join ( str ( random . randint ( 0 , 256 )) for _ in range ( 3 )) ), \"Re-palette\" , ) if not args . app : manager . layout = _create_layout () manager . add ( _create_header (), assign = \"header\" ) manager . add ( app_picker , assign = \"applications\" ) manager . add ( _create_footer ( manager ), assign = \"footer\" ) manager . toast ( \"[ptg.title]Welcome to the [/ptg.title ptg.brand_title]\" + \"PyTermGUI[/ptg.brand_title ptg.title] CLI!\" , offset = ptg . terminal . height // 2 - 3 , delay = 700 , ) else : manager . layout . add_slot ( \"Body\" ) app = _app_from_short ( args . app ) window = app ( args ) manager . add ( window , assign = \"body\" ) window = window or manager . focused # type: ignore if window is None or not isinstance ( window , AppWindow ): return window . on_exit () screenshot ( man ) Opens a modal dialogue & saves a screenshot. Source code in pytermgui/cmd.py 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 def screenshot ( man : ptg . WindowManager ) -> None : \"\"\"Opens a modal dialogue & saves a screenshot.\"\"\" tempname = \".screenshot_temp.svg\" modal : ptg . Window def _finish ( * _ : Any ) -> None : \"\"\"Closes the modal and renames the window.\"\"\" man . remove ( modal ) filename = field . value or \"screenshot\" if not filename . endswith ( \".svg\" ): filename += \".svg\" os . rename ( tempname , filename ) man . toast ( \"[ptg.title]Screenshot saved!\" , \"\" , f \"[ptg.detail] { filename } \" ) title = sys . argv [ 0 ] field = ptg . InputField ( prompt = \"Save as: \" ) man . screenshot ( title = title , filename = tempname ) modal = man . alert ( \"[ptg.title]Screenshot taken!\" , \"\" , ptg . Container ( field ), \"\" , [ \"Save!\" , _finish ] )","title":"cmd"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.AppWindow","text":"Bases: ptg . Window A generic application window. It contains a header with the app's title, as well as some global settings. Source code in pytermgui/cmd.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class AppWindow ( ptg . Window ): \"\"\"A generic application window. It contains a header with the app's title, as well as some global settings. \"\"\" app_title : str \"\"\"The display title of the application.\"\"\" app_id : str \"\"\"The short identifier used by ArgumentParser.\"\"\" standalone : bool \"\"\"Whether this app was launched directly from the CLI.\"\"\" overflow = ptg . Overflow . SCROLL vertical_align = ptg . VerticalAlignment . TOP def __init__ ( self , args : Namespace | None = None , ** attrs : Any ) -> None : super () . __init__ ( ** attrs ) self . standalone = bool ( getattr ( args , self . app_id , None )) bottom = ptg . Container . chars [ \"border\" ][ - 1 ] header_box = ptg . boxes . Box ( [ \"\" , \" x \" , bottom * 3 , ] ) self . _add_widget ( ptg . Container ( f \"[ptg.title] { self . app_title } \" , box = header_box )) self . _add_widget ( \"\" ) def setup ( self ) -> None : \"\"\"Centers window, sets its width & height.\"\"\" self . width = int ( self . terminal . width * 2 / 3 ) self . height = int ( self . terminal . height * 2 / 3 ) self . center ( store = False ) def on_exit ( self ) -> None : \"\"\"Called on application exit. Should be used to print current application state to the user's shell. \"\"\" ptg . tim . print ( f \" { _title () } - [dim] { self . app_title } \" ) print ()","title":"AppWindow"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.AppWindow.app_id","text":"The short identifier used by ArgumentParser.","title":"app_id"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.AppWindow.app_title","text":"The display title of the application.","title":"app_title"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.AppWindow.on_exit","text":"Called on application exit. Should be used to print current application state to the user's shell. Source code in pytermgui/cmd.py 70 71 72 73 74 75 76 77 def on_exit ( self ) -> None : \"\"\"Called on application exit. Should be used to print current application state to the user's shell. \"\"\" ptg . tim . print ( f \" { _title () } - [dim] { self . app_title } \" ) print ()","title":"on_exit()"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.AppWindow.setup","text":"Centers window, sets its width & height. Source code in pytermgui/cmd.py 63 64 65 66 67 68 def setup ( self ) -> None : \"\"\"Centers window, sets its width & height.\"\"\" self . width = int ( self . terminal . width * 2 / 3 ) self . height = int ( self . terminal . height * 2 / 3 ) self . center ( store = False )","title":"setup()"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.ColorPickerWindow","text":"Bases: AppWindow A window to pick colors from the xterm-256 palette. Source code in pytermgui/cmd.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 class ColorPickerWindow ( AppWindow ): \"\"\"A window to pick colors from the xterm-256 palette.\"\"\" app_title = \"ColorPicker\" app_id = \"color\" def __init__ ( self , args : Namespace | None = None , ** attrs : Any ) -> None : super () . __init__ ( args , ** attrs ) self . _chosen_rgb = ptg . str_to_color ( \"black\" ) self . _colorpicker = ptg . ColorPicker () self . _add_widget ( ptg . FancyReprWidget ( ptg . palette , starts_at = 2 )) self . _add_widget ( ptg . Collapsible ( \"xterm-256\" , \"\" , self . _colorpicker )) self . _add_widget ( \"\" ) self . _add_widget ( ptg . Collapsible ( \"RGB & HEX\" , \"\" , self . _create_rgb_picker (), static_width = 81 ) ) self . setup () def _create_rgb_picker ( self ) -> ptg . Container : \"\"\"Creates the RGB picker 'widget'.\"\"\" root = ptg . Container ( static_width = 72 ) matrix = ptg . DensePixelMatrix ( 68 , 20 ) hexdisplay = ptg . Label () rgbdisplay = ptg . Label () sliders = [ ptg . Slider () for _ in range ( 3 )] def _get_rgb () -> tuple [ int , int , int ]: \"\"\"Computes the RGB value from the 3 sliders.\"\"\" values = [ int ( 255 * slider . value ) for slider in sliders ] return values [ 0 ], values [ 1 ], values [ 2 ] def _update ( * _ ) -> None : \"\"\"Updates the matrix & displays with the current color.\"\"\" color = self . _chosen_rgb = ptg . RGBColor . from_rgb ( _get_rgb ()) for row in range ( matrix . rows ): for col in range ( matrix . columns ): matrix [ row , col ] = color . hex hexdisplay . value = f \"[ptg.body] { color . hex } \" rgbdisplay . value = f \"[ptg.body]rgb( { ', ' . join ( map ( str , color . rgb )) } )\" matrix . build () red , green , blue = sliders # red.styles.filled_selected__cursor = \"red\" # green.styles.filled_selected__cursor = \"green\" # blue.styles.filled_selected__cursor = \"blue\" for slider in sliders : slider . onchange = _update root += hexdisplay root += rgbdisplay root += \"\" root += matrix root += \"\" root += red root += green root += blue _update () return root def on_exit ( self ) -> None : super () . on_exit () color = self . _chosen_rgb eightbit = \" \" . join ( button . get_lines ()[ 0 ] for button in self . _colorpicker . chosen ) ptg . tim . print ( \"[ptg.title]Your colors:\" ) ptg . tim . print ( f \" [ { color . hex } ] { color . rgb } [/] // [ { color . hex } ] { color . hex } \" ) ptg . tim . print () ptg . tim . print ( f \" { eightbit } \" )","title":"ColorPickerWindow"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.GetchWindow","text":"Bases: AppWindow A window for the Getch utility. Source code in pytermgui/cmd.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 class GetchWindow ( AppWindow ): \"\"\"A window for the Getch utility.\"\"\" app_title = \"Getch\" app_id = \"getch\" def __init__ ( self , args : Namespace | None = None , ** attrs : Any ) -> None : super () . __init__ ( args , ** attrs ) self . bind ( ptg . keys . ANY_KEY , self . _update ) self . _content = ptg . Container ( \"Press any key...\" , static_width = 50 ) self . _add_widget ( self . _content ) self . setup () def _update ( self , _ : ptg . Widget , key : str ) -> None : \"\"\"Updates window contents on keypress.\"\"\" self . _content . set_widgets ([]) name = _get_key_name ( key ) if name != ascii ( key ): name = f \"keys. { name } \" style = ptg . HighlighterStyle ( ptg . highlight_python ) items = [ \"[ptg.title]Your output\" , \"\" , { \"[ptg.detail]key\" : ptg . Label ( name , style = style )}, { \"[ptg.detail]value:\" : ptg . Label ( ascii ( key ), style = style )}, { \"[ptg.detail]len()\" : ptg . Label ( str ( len ( key )), style = style )}, { \"[ptg.detail]real_length()\" : ptg . Label ( str ( ptg . real_length ( key )), style = style ) }, ] for item in items : self . _content += item if self . standalone : assert self . manager is not None self . manager . stop () def on_exit ( self ) -> None : super () . on_exit () for line in self . _content . get_lines (): print ( line )","title":"GetchWindow"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.InspectorWindow","text":"Bases: AppWindow A window for the inspect utility. Source code in pytermgui/cmd.py 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 class InspectorWindow ( AppWindow ): \"\"\"A window for the `inspect` utility.\"\"\" app_title = \"Inspector\" app_id = \"inspect\" def __init__ ( self , args : Namespace | None = None , ** attrs : Any ) -> None : super () . __init__ ( args , ** attrs ) self . _input = ptg . InputField ( value = \"boxes.Box\" ) self . _output = ptg . Container ( box = \"EMPTY\" ) self . _update () self . _input . bind ( ptg . keys . ENTER , self . _update ) self . _add_widget ( ptg . Container ( self . _output , \"\" , ptg . Container ( self . _input ), box = \"EMPTY\" , ) ) self . setup () self . select ( 0 ) @staticmethod def obj_from_path ( path : str ) -> object | None : \"\"\"Retrieves an object from any valid import path. An import path could be something like: pytermgui.window_manager.compositor.Compositor ...or if the library in question imports its parts within `__init__.py`-s: pytermgui.Compositor \"\"\" parts = path . split ( \".\" ) if parts [ 0 ] in dir ( builtins ): obj = getattr ( builtins , parts [ 0 ]) elif parts [ 0 ] in dir ( ptg ): obj = getattr ( ptg , parts [ 0 ]) else : try : obj = importlib . import_module ( \".\" . join ( parts [: - 1 ])) except ( ValueError , ModuleNotFoundError ) as error : return ( f \"Could not import object at path { path !r} : { error } .\" + \" Maybe try using the --eval flag?\" ) try : obj = getattr ( obj , parts [ - 1 ]) except AttributeError : return obj return obj def _update ( self , * _ ) -> None : \"\"\"Updates output with new inspection result.\"\"\" obj = self . obj_from_path ( self . _input . value ) self . _output . vertical_align = ptg . VerticalAlignment . CENTER self . _output . set_widgets ([ ptg . inspect ( obj )]) def on_exit ( self ) -> None : super () . on_exit () self . _output . vertical_align = ptg . VerticalAlignment . TOP for line in self . _output . get_lines (): print ( line )","title":"InspectorWindow"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.InspectorWindow.obj_from_path","text":"Retrieves an object from any valid import path. An import path could be something like pytermgui.window_manager.compositor.Compositor ...or if the library in question imports its parts within __init__.py -s: pytermgui.Compositor Source code in pytermgui/cmd.py 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 @staticmethod def obj_from_path ( path : str ) -> object | None : \"\"\"Retrieves an object from any valid import path. An import path could be something like: pytermgui.window_manager.compositor.Compositor ...or if the library in question imports its parts within `__init__.py`-s: pytermgui.Compositor \"\"\" parts = path . split ( \".\" ) if parts [ 0 ] in dir ( builtins ): obj = getattr ( builtins , parts [ 0 ]) elif parts [ 0 ] in dir ( ptg ): obj = getattr ( ptg , parts [ 0 ]) else : try : obj = importlib . import_module ( \".\" . join ( parts [: - 1 ])) except ( ValueError , ModuleNotFoundError ) as error : return ( f \"Could not import object at path { path !r} : { error } .\" + \" Maybe try using the --eval flag?\" ) try : obj = getattr ( obj , parts [ - 1 ]) except AttributeError : return obj return obj","title":"obj_from_path()"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.TIMWindow","text":"Bases: AppWindow An application to play around with TIM. Source code in pytermgui/cmd.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 class TIMWindow ( AppWindow ): \"\"\"An application to play around with TIM.\"\"\" app_title = \"TIM Playground\" app_id = \"tim\" def __init__ ( self , args : Namespace | None = None , ** attrs : Any ) -> None : super () . __init__ ( args , ** attrs ) if self . standalone : self . bind ( ptg . keys . RETURN , lambda * _ : self . manager . stop () if self . manager is not None else None , ) self . _generate_colors () self . _output = ptg . Label ( parent_align = 0 ) self . _input = ptg . InputField () self . _input . styles . value__fill = lambda _ , item : item self . _showcase = self . _create_showcase () self . _input . bind ( ptg . keys . ANY_KEY , lambda * _ : self . _update_output ()) self . _add_widget ( ptg . Container ( ptg . Container ( self . _output ), self . _showcase , ptg . Container ( self . _input ), box = \"EMPTY\" , static_width = 60 , ) ) self . bind ( ptg . keys . CTRL_R , self . _generate_colors ) self . setup () self . select ( 0 ) @staticmethod def _random_rgb () -> ptg . Color : \"\"\"Returns a random Color.\"\"\" rgb = tuple ( random . randint ( 0 , 255 ) for _ in range ( 3 )) return ptg . RGBColor . from_rgb ( rgb ) # type: ignore def _update_output ( self ) -> None : \"\"\"Updates the output field.\"\"\" self . _output . value = self . _input . value def _generate_colors ( self , * _ ) -> None : \"\"\"Generates self._example_{255,rgb,hex}.\"\"\" ptg . tim . alias ( \"ptg.timwindow.255\" , str ( random . randint ( 16 , 233 ))) ptg . tim . alias ( \"ptg.timwindow.rgb\" , \";\" . join ( map ( str , self . _random_rgb () . rgb ))) ptg . tim . alias ( \"ptg.timwindow.hex\" , self . _random_rgb () . hex ) @staticmethod def _create_showcase () -> ptg . Container : \"\"\"Creates the showcase container.\"\"\" def _show_style ( name : str ) -> str : return f \"[ { name } ] { name } \" # .replace(\"'\", \"\") def _create_table ( source : Iterable [ tuple [ str , str ]]) -> ptg . Container : root = ptg . Container () for left , right in source : row = ptg . Splitter ( ptg . Label ( left , parent_align = 0 ), ptg . Label ( right , parent_align = 2 ) ) row . set_char ( \"separator\" , f \" { ptg . Container . chars [ 'border' ][ 0 ] } \" ) root += row return root prefix = \"ptg.timwindow\" tags = [ _show_style ( style ) for style in ptg . markup . style_maps . STYLES ] colors = [ f \"[[ { prefix } .255]0-255[/]]\" , f \"[[ { prefix } .hex]#RRGGBB[/]]\" , f \"[[ { prefix } .rgb]RRR;GGG;BBB[/]]\" , \"\" , f \"[[inverse { prefix } .255]@0-255[/]]\" , f \"[[inverse { prefix } .hex]@#RRGGBB[/]]\" , f \"[[inverse { prefix } .rgb]@RRR;GGG;BBB[/]]\" , ] tag_container = _create_table ( zip_longest ( tags , colors , fillvalue = \"\" )) user_container = _create_table ( ( _show_style ( tag ), f \"[ { tag } ] { value } \" ) for tag , value in ptg . tim . aliases . items () if not tag . startswith ( \"/\" ) and tag not in ptg . palette . data ) return ptg . Container ( tag_container , user_container , box = \"EMPTY\" ) def on_exit ( self ) -> None : super () . on_exit () ptg . tim . print ( ptg . highlight_tim ( self . _input . value )) ptg . tim . print ( self . _input . value )","title":"TIMWindow"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.main","text":"Runs the program. Parameters: Name Type Description Default argv list [ str ] | None A list of arguments, not included the 0th element pointing to the executable path. None Source code in pytermgui/cmd.py 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 def main ( argv : list [ str ] | None = None ) -> None : \"\"\"Runs the program. Args: argv: A list of arguments, not included the 0th element pointing to the executable path. \"\"\" _create_aliases () args = process_args ( argv ) args . app = args . app or ( \"getch\" if args . getch else ( \"tim\" if args . tim else ( \"color\" if args . color else None )) ) if args . app or len ( sys . argv ) == 1 : run_environment ( args ) return with ptg . terminal . record () as recording : if args . size : ptg . tim . print ( f \" { ptg . terminal . width } x { ptg . terminal . height } \" ) elif args . version : _print_version () elif args . palette : ptg . palette . print () elif args . inspect : _run_inspect ( args ) elif args . exec : args . exec = sys . stdin . read () if args . exec == \"-\" else args . exec for name in dir ( ptg ): obj = getattr ( ptg , name , None ) globals ()[ name ] = obj globals ()[ \"print\" ] = ptg . terminal . print exec ( args . exec , locals (), globals ()) # pylint: disable=exec-used elif args . highlight : text = sys . stdin . read () if args . highlight == \"-\" else args . highlight ptg . tim . print ( ptg . highlight_python ( text )) elif args . file : _interpret_file ( args ) if args . export_svg : recording . save_svg ( args . export_svg ) elif args . export_html : recording . save_html ( args . export_html )","title":"main()"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.process_args","text":"Processes command line arguments. Source code in pytermgui/cmd.py 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 def process_args ( argv : list [ str ] | None = None ) -> Namespace : \"\"\"Processes command line arguments.\"\"\" parser = ArgumentParser ( description = f \" { ptg . tim . parse ( _title ()) } 's command line environment.\" ) apps = [ short for ( _ , short ), _ in APPLICATION_MAP . items ()] app_group = parser . add_argument_group ( \"Applications\" ) app_group . add_argument ( \"--app\" , type = str . lower , help = \"Launch an app.\" , metavar = f \" { ', ' . join ( app . capitalize () for app in apps ) } \" , choices = apps , ) app_group . add_argument ( \"-g\" , \"--getch\" , help = \"Launch the Getch app.\" , action = \"store_true\" ) app_group . add_argument ( \"-t\" , \"--tim\" , help = \"Launch the TIM Playground app.\" , action = \"store_true\" ) app_group . add_argument ( \"-c\" , \"--color\" , help = \"Launch the ColorPicker app.\" , action = \"store_true\" , ) inspect_group = parser . add_argument_group ( \"Inspection\" ) inspect_group . add_argument ( \"-i\" , \"--inspect\" , help = \"Inspect an object.\" , metavar = \"PATH_OR_CODE\" ) inspect_group . add_argument ( \"-e\" , \"--eval\" , help = \"Evaluate the expression given to `--inspect` instead of treating it as a path.\" , action = \"store_true\" , ) inspect_group . add_argument ( \"--methods\" , help = \"Always show methods when inspecting.\" , action = \"store_true\" ) inspect_group . add_argument ( \"--dunder\" , help = \"Always show __dunder__ methods when inspecting.\" , action = \"store_true\" , ) inspect_group . add_argument ( \"--private\" , help = \"Always show _private methods when inspecting.\" , action = \"store_true\" , ) util_group = parser . add_argument_group ( \"Utilities\" ) util_group . add_argument ( \"-s\" , \"--size\" , help = \"Output the current terminal size in WxH format.\" , action = \"store_true\" , ) util_group . add_argument ( \"-v\" , \"--version\" , help = \"Print version & system information.\" , action = \"store_true\" , ) util_group . add_argument ( \"--palette\" , help = \"Print the default PyTermGUI color palette.\" , action = \"store_true\" , ) util_group . add_argument ( \"--highlight\" , help = ( \"Highlight some python-like code syntax.\" + \" No argument or '-' will read STDIN.\" ), metavar = \"SYNTAX\" , const = \"-\" , nargs = \"?\" , ) util_group . add_argument ( \"--exec\" , help = \"Execute some Python code. No argument or '-' will read STDIN.\" , const = \"-\" , nargs = \"?\" , ) util_group . add_argument ( \"-f\" , \"--file\" , help = \"Interpret a PTG-YAML file.\" ) util_group . add_argument ( \"--print-only\" , help = \"When interpreting YAML, print the environment without running it interactively.\" , action = \"store_true\" , ) export_group = parser . add_argument_group ( \"Exporters\" ) export_group . add_argument ( \"--export-svg\" , help = \"Export the result of any non-interactive argument as an SVG file.\" , metavar = \"FILE\" , ) export_group . add_argument ( \"--export-html\" , help = \"Export the result of any non-interactive argument as an HTML file.\" , metavar = \"FILE\" , ) argv = argv or sys . argv [ 1 :] args = parser . parse_args ( args = argv ) return args","title":"process_args()"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.run_environment","text":"Runs the WindowManager environment. Parameters: Name Type Description Default args Namespace An argparse namespace containing relevant arguments. required Source code in pytermgui/cmd.py 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 def run_environment ( args : Namespace ) -> None : \"\"\"Runs the WindowManager environment. Args: args: An argparse namespace containing relevant arguments. \"\"\" def _find_focused ( manager : ptg . WindowManager ) -> ptg . Window | None : if manager . focused is None : return None # Find foremost non-persistent window for window in manager : if window . is_persistent : continue return window return None def _toggle_attachment ( manager : ptg . WindowManager ) -> None : focused = _find_focused ( manager ) if focused is None : return slot = manager . layout . body if slot . content is None : slot . content = focused else : slot . detach_content () manager . layout . apply () def _close_focused ( manager : ptg . WindowManager ) -> None : focused = _find_focused ( manager ) if focused is None : return focused . close () _configure_widgets () window : AppWindow | None = None with ptg . WindowManager () as manager : app_picker = _create_app_picker ( manager ) manager . bind ( ptg . keys . CTRL_W , lambda * _ : _close_focused ( manager ), \"Close window\" , ) manager . bind ( ptg . keys . F12 , lambda * _ : screenshot ( manager ), \"Screenshot\" , ) manager . bind ( ptg . keys . CTRL_F , lambda * _ : _toggle_attachment ( manager ), \"Toggle layout\" , ) manager . bind ( ptg . keys . CTRL_A , lambda * _ : { manager . focus ( app_picker ), # type: ignore app_picker . execute_binding ( ptg . keys . CTRL_A ), }, ) manager . bind ( ptg . keys . ALT + ptg . keys . TAB , lambda * _ : manager . focus_next (), ) manager . bind ( \"!\" , lambda * _ : ptg . palette . regenerate ( primary = \";\" . join ( str ( random . randint ( 0 , 256 )) for _ in range ( 3 )) ), \"Re-palette\" , ) if not args . app : manager . layout = _create_layout () manager . add ( _create_header (), assign = \"header\" ) manager . add ( app_picker , assign = \"applications\" ) manager . add ( _create_footer ( manager ), assign = \"footer\" ) manager . toast ( \"[ptg.title]Welcome to the [/ptg.title ptg.brand_title]\" + \"PyTermGUI[/ptg.brand_title ptg.title] CLI!\" , offset = ptg . terminal . height // 2 - 3 , delay = 700 , ) else : manager . layout . add_slot ( \"Body\" ) app = _app_from_short ( args . app ) window = app ( args ) manager . add ( window , assign = \"body\" ) window = window or manager . focused # type: ignore if window is None or not isinstance ( window , AppWindow ): return window . on_exit ()","title":"run_environment()"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.screenshot","text":"Opens a modal dialogue & saves a screenshot. Source code in pytermgui/cmd.py 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 def screenshot ( man : ptg . WindowManager ) -> None : \"\"\"Opens a modal dialogue & saves a screenshot.\"\"\" tempname = \".screenshot_temp.svg\" modal : ptg . Window def _finish ( * _ : Any ) -> None : \"\"\"Closes the modal and renames the window.\"\"\" man . remove ( modal ) filename = field . value or \"screenshot\" if not filename . endswith ( \".svg\" ): filename += \".svg\" os . rename ( tempname , filename ) man . toast ( \"[ptg.title]Screenshot saved!\" , \"\" , f \"[ptg.detail] { filename } \" ) title = sys . argv [ 0 ] field = ptg . InputField ( prompt = \"Save as: \" ) man . screenshot ( title = title , filename = tempname ) modal = man . alert ( \"[ptg.title]Screenshot taken!\" , \"\" , ptg . Container ( field ), \"\" , [ \"Save!\" , _finish ] )","title":"screenshot()"},{"location":"reference/pytermgui/colors/","text":"The module containing all of the color-centric features of this library. This module provides a base class, Color , and a bunch of abstractions over it. Shoutout to: https://stackoverflow.com/a/33206814, one of the best StackOverflow answers I've ever bumped into. Color dataclass A terminal color. Parameters: Name Type Description Default value str The data contained within this color. required background bool Whether this color will represent a color. False These colors are all formattable. There are currently 2 'spec' strings: - f\"{my_color:tim}\" -> Returns self.markup - f\"{my_color:seq}\" -> Returns self.sequence They can thus be used in TIM strings ptg.tim.parse(\"[{my_color:tim}]Hello\") '[ ]Hello' And in normal, ANSI coded strings: >>> \"{my_color:seq}Hello\" '<my_color.sequence>Hello' Source code in pytermgui/colors.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 @dataclass class Color : # pylint: disable=too-many-public-methods \"\"\"A terminal color. Args: value: The data contained within this color. background: Whether this color will represent a color. These colors are all formattable. There are currently 2 'spec' strings: - f\"{my_color:tim}\" -> Returns self.markup - f\"{my_color:seq}\" -> Returns self.sequence They can thus be used in TIM strings: >>> ptg.tim.parse(\"[{my_color:tim}]Hello\") '[<my_color.markup>]Hello' And in normal, ANSI coded strings: >>> \"{my_color:seq}Hello\" '<my_color.sequence>Hello' \"\"\" value : str background : bool = False system : ColorSystem = field ( init = False ) default_foreground : Color | None = field ( default = None , repr = False ) default_background : Color | None = field ( default = None , repr = False ) _rgb : tuple [ int , int , int ] | None = field ( init = False , default = None , repr = False ) def __format__ ( self , spec : str ) -> str : \"\"\"Formats the color by the given specification.\"\"\" if spec == \"tim\" : return self . markup if spec == \"seq\" : return self . sequence return repr ( self ) @classmethod def from_rgb ( cls , rgb : RGBTriplet ) -> Color : \"\"\"Creates a color from the given RGB. Args: rgb: The RGB value to base the new color off of. \"\"\" return RGBColor . from_rgb ( rgb ) @classmethod def from_hls ( cls , hsl : RGBTriplet ) -> Color : \"\"\"Creates a color from the given HLS. HLS stands for Hue, Lightness & Saturation. It is more commonly known as HSL, but the `colorsys` library uses HLS instead so that's what we use too. Args: hsl: The HLS value to base the new color off of. \"\"\" rgb = cast ( RGBTriplet , map ( lambda n : int ( 256 * n ), colorsys . hls_to_rgb ( * hsl )), ) return RGBColor . from_rgb ( rgb ) @property def sequence ( self ) -> str : \"\"\"Returns the ANSI sequence representation of the color.\"\"\" raise NotImplementedError @cached_property def markup ( self ) -> str : \"\"\"Returns the TIM representation of this color.\"\"\" return ( \"@\" if self . background else \"\" ) + self . value @cached_property def rgb ( self ) -> RGBTriplet : \"\"\"Returns this color as a tuple of (red, green, blue) values.\"\"\" if self . _rgb is None : raise NotImplementedError return self . _rgb @cached_property def red ( self ) -> Number : \"\"\"Returns the red component of this color.\"\"\" return self . rgb [ 0 ] @cached_property def green ( self ) -> Number : \"\"\"Returns the red component of this color.\"\"\" return self . rgb [ 1 ] @cached_property def blue ( self ) -> Number : \"\"\"Returns the red component of this color.\"\"\" return self . rgb [ 2 ] @cached_property def hls ( self ) -> RGBTriplet : \"\"\"Returns the HLS (Hue, Lightness, Saturation) representation of this color.\"\"\" return colorsys . rgb_to_hls ( self . red / 256 , self . green / 256 , self . blue / 256 ) @cached_property def hue ( self ) -> float : \"\"\"Returns the hue component of this color.\"\"\" return self . hls [ 0 ] @cached_property def lightness ( self ) -> float : \"\"\"Returns the lightness component of this color.\"\"\" return self . hls [ 1 ] @cached_property def saturation ( self ) -> float : \"\"\"Returns the saturation component of this color.\"\"\" return self . hls [ 2 ] @cached_property def hex ( self ) -> str : \"\"\"Returns CSS-like HEX representation of this color.\"\"\" buff = \"#\" for color in self . rgb : buff += f \" { format ( color , 'x' ) : 0>2 } \" return buff @classmethod def get_default_foreground ( cls ) -> Color : \"\"\"Gets the terminal emulator's default foreground color.\"\"\" if cls . default_foreground is not None : return cls . default_foreground return _get_palette_color ( \"10\" ) @classmethod def get_default_background ( cls ) -> Color : \"\"\"Gets the terminal emulator's default foreground color.\"\"\" if cls . default_background is not None : return cls . default_background return _get_palette_color ( \"11\" ) @property def name ( self ) -> str : \"\"\"Returns the reverse-parseable name of this color.\"\"\" return ( \"@\" if self . background else \"\" ) + self . value @cached_property def luminance ( self ) -> float : \"\"\"Returns this color's perceived luminance (brightness). From https://stackoverflow.com/a/596243 \"\"\" def _linearize ( color : float ) -> float : \"\"\"Converts sRGB color to linear value.\"\"\" if color <= 0.04045 : return color / 12.92 return (( color + 0.055 ) / 1.055 ) ** 2.4 red , green , blue = float ( self . rgb [ 0 ]), float ( self . rgb [ 1 ]), float ( self . rgb [ 2 ]) red /= 255 green /= 255 blue /= 255 red = _linearize ( red ) blue = _linearize ( blue ) green = _linearize ( green ) return 0.2126 * red + 0.7152 * green + 0.0722 * blue def hue_offset ( self , offset : float ) -> Color : \"\"\"Returns the color offset by the given hue.\"\"\" hue , lightness , saturation = colorsys . rgb_to_hls ( self . red / 256 , self . green / 256 , self . blue / 256 ) hue = ( hue + offset ) % 1 return Color . parse ( \";\" . join ( map ( lambda n : str ( int ( 256 * n )), colorsys . hls_to_rgb ( hue , lightness , saturation ), ) ), background = self . background , localize = False , ) @cached_property def brightness ( self ) -> float : \"\"\"Returns the perceived \"brightness\" of a color. From https://stackoverflow.com/a/56678483 \"\"\" if self . luminance <= ( 216 / 24389 ): brightness = self . luminance * ( 24389 / 27 ) else : brightness = self . luminance ** ( 1 / 3 ) * 116 - 16 return brightness / 100 @cached_property def complement ( self ) -> Color : \"\"\"Returns the complement of this color.\"\"\" if self . hue == 0.0 : return ( Color . parse ( \"#FFFFFF\" ) if self . lightness == 0.0 else Color . parse ( \"#000000\" ) ) return self . hue_offset ( 0.5 ) @cached_property def triadic ( self ) -> tuple [ Color , Color , Color ]: \"\"\"Computes the triadic group this color is in. Triadic colors are 3-way complements of eachother. Returns: This color, the first triadic element and the second one. \"\"\" return self , self . hue_offset ( 1 / 3 ), self . hue_offset ( 2 / 3 ) @cached_property def tetradic ( self ) -> tuple [ Color , Color , Color , Color ]: \"\"\"Computes the tetradic group this color is in. Tetradic colors are 4-way complements of eachother. Returns: This color, the first tetradic element and the second one. \"\"\" return self , self . hue_offset ( 1 / 4 ), self . complement , self . hue_offset ( 3 / 4 ) @cached_property def analogous ( self ) -> tuple [ Color , Color , Color ]: \"\"\"Computes the analogous group this colors is in. Analogous colors are located next to eachother on the color wheel. Returns: The color to the left, this color and the color to the right. \"\"\" return self . hue_offset ( - 1 / 12 ), self , self . hue_offset ( 1 / 12 ) @cached_property def contrast ( self ) -> Color : \"\"\"Returns a color (black or white) that complies with the W3C contrast ratio guidelines.\"\"\" if self . luminance > 0.179 : return Color . parse ( \"#000000\" ) . blend_complement ( 0.05 ) return Color . parse ( \"#FFFFFF\" ) . blend_complement ( 0.05 ) def blend ( self , other : Color , alpha : float = 0.5 , localize : bool = False ) -> Color : \"\"\"Blends a color into another one. Args: other: The color to blend with. alpha: How much the other color should influence the outcome. localize: If set, the returned color will returned its localized version by running `get_localized` on it before returning. Returns: A `Color` that is the result of the blending. \"\"\" red1 , green1 , blue1 = self . rgb red2 , green2 , blue2 = other . rgb blended : Color = RGBColor . from_rgb ( ( int ( red1 + ( red2 - red1 ) * alpha ), int ( green1 + ( green2 - green1 ) * alpha ), int ( blue1 + ( blue2 - blue1 ) * alpha ), ) ) if localize : blended = blended . get_localized () return blended def blend_complement ( self , alpha : float = 0.5 ) -> Color : \"\"\"Blends this color with its complement. See `Color.blend`. \"\"\" return self . blend ( self . complement , alpha ) def blend_contrast ( self , alpha : float = 0.5 ) -> Color : \"\"\"Blends this color with its contrast pair. See `Color.blend`. \"\"\" return self . blend ( self . contrast , alpha ) def darken ( self , alpha : float = 0.5 ) -> Color : \"\"\"Darkens the color by blending it with black, using the alpha provided.\"\"\" return self . blend ( Color . parse ( \"#000000\" ), alpha ) def lighten ( self , alpha : float = 0.5 ) -> Color : \"\"\"Lightens the color by blending it with white, using the alpha provided.\"\"\" return self . blend ( Color . parse ( \"#FFFFFF\" ), alpha ) @classmethod def parse ( cls , text : str , background : bool = False , # pylint: disable=redefined-outer-name localize : bool = True , use_cache : bool = False , ) -> Color : \"\"\"Uses `str_to_color` to parse some text into a `Color`.\"\"\" return str_to_color ( text = text , is_background = background , localize = localize , use_cache = use_cache , ) def __call__ ( self , text : str , reset : bool = True ) -> str : \"\"\"Colors the given string.\"\"\" buff = self . sequence + text if reset : buff += reset_style () return buff def get_localized ( self ) -> Color : \"\"\"Creates a terminal-capability local Color instance. This method essentially allows for graceful degradation of colors in the terminal. \"\"\" system = terminal . colorsystem if self . system <= system : return self colortype = SYSTEM_TO_TYPE [ system ] local = colortype . from_rgb ( self . rgb ) local . background = self . background return local __call__ ( text , reset = True ) Colors the given string. Source code in pytermgui/colors.py 493 494 495 496 497 498 499 500 def __call__ ( self , text : str , reset : bool = True ) -> str : \"\"\"Colors the given string.\"\"\" buff = self . sequence + text if reset : buff += reset_style () return buff __format__ ( spec ) Formats the color by the given specification. Source code in pytermgui/colors.py 165 166 167 168 169 170 171 172 173 174 def __format__ ( self , spec : str ) -> str : \"\"\"Formats the color by the given specification.\"\"\" if spec == \"tim\" : return self . markup if spec == \"seq\" : return self . sequence return repr ( self ) analogous () property cached Computes the analogous group this colors is in. Analogous colors are located next to eachother on the color wheel. Returns: Type Description tuple [ Color , Color , Color ] The color to the left, this color and the color to the right. Source code in pytermgui/colors.py 400 401 402 403 404 405 406 407 408 409 410 @cached_property def analogous ( self ) -> tuple [ Color , Color , Color ]: \"\"\"Computes the analogous group this colors is in. Analogous colors are located next to eachother on the color wheel. Returns: The color to the left, this color and the color to the right. \"\"\" return self . hue_offset ( - 1 / 12 ), self , self . hue_offset ( 1 / 12 ) blend ( other , alpha = 0.5 , localize = False ) Blends a color into another one. Parameters: Name Type Description Default other Color The color to blend with. required alpha float How much the other color should influence the outcome. 0.5 localize bool If set, the returned color will returned its localized version by running get_localized on it before returning. False Returns: Type Description Color A Color that is the result of the blending. Source code in pytermgui/colors.py 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 def blend ( self , other : Color , alpha : float = 0.5 , localize : bool = False ) -> Color : \"\"\"Blends a color into another one. Args: other: The color to blend with. alpha: How much the other color should influence the outcome. localize: If set, the returned color will returned its localized version by running `get_localized` on it before returning. Returns: A `Color` that is the result of the blending. \"\"\" red1 , green1 , blue1 = self . rgb red2 , green2 , blue2 = other . rgb blended : Color = RGBColor . from_rgb ( ( int ( red1 + ( red2 - red1 ) * alpha ), int ( green1 + ( green2 - green1 ) * alpha ), int ( blue1 + ( blue2 - blue1 ) * alpha ), ) ) if localize : blended = blended . get_localized () return blended blend_complement ( alpha = 0.5 ) Blends this color with its complement. See Color.blend . Source code in pytermgui/colors.py 450 451 452 453 454 455 456 def blend_complement ( self , alpha : float = 0.5 ) -> Color : \"\"\"Blends this color with its complement. See `Color.blend`. \"\"\" return self . blend ( self . complement , alpha ) blend_contrast ( alpha = 0.5 ) Blends this color with its contrast pair. See Color.blend . Source code in pytermgui/colors.py 458 459 460 461 462 463 464 def blend_contrast ( self , alpha : float = 0.5 ) -> Color : \"\"\"Blends this color with its contrast pair. See `Color.blend`. \"\"\" return self . blend ( self . contrast , alpha ) blue () property cached Returns the red component of this color. Source code in pytermgui/colors.py 237 238 239 240 241 @cached_property def blue ( self ) -> Number : \"\"\"Returns the red component of this color.\"\"\" return self . rgb [ 2 ] brightness () property cached Returns the perceived \"brightness\" of a color. From https://stackoverflow.com/a/56678483 Source code in pytermgui/colors.py 348 349 350 351 352 353 354 355 356 357 358 359 360 361 @cached_property def brightness ( self ) -> float : \"\"\"Returns the perceived \"brightness\" of a color. From https://stackoverflow.com/a/56678483 \"\"\" if self . luminance <= ( 216 / 24389 ): brightness = self . luminance * ( 24389 / 27 ) else : brightness = self . luminance ** ( 1 / 3 ) * 116 - 16 return brightness / 100 complement () property cached Returns the complement of this color. Source code in pytermgui/colors.py 363 364 365 366 367 368 369 370 371 372 373 374 @cached_property def complement ( self ) -> Color : \"\"\"Returns the complement of this color.\"\"\" if self . hue == 0.0 : return ( Color . parse ( \"#FFFFFF\" ) if self . lightness == 0.0 else Color . parse ( \"#000000\" ) ) return self . hue_offset ( 0.5 ) contrast () property cached Returns a color (black or white) that complies with the W3C contrast ratio guidelines. Source code in pytermgui/colors.py 412 413 414 415 416 417 418 419 @cached_property def contrast ( self ) -> Color : \"\"\"Returns a color (black or white) that complies with the W3C contrast ratio guidelines.\"\"\" if self . luminance > 0.179 : return Color . parse ( \"#000000\" ) . blend_complement ( 0.05 ) return Color . parse ( \"#FFFFFF\" ) . blend_complement ( 0.05 ) darken ( alpha = 0.5 ) Darkens the color by blending it with black, using the alpha provided. Source code in pytermgui/colors.py 466 467 468 469 def darken ( self , alpha : float = 0.5 ) -> Color : \"\"\"Darkens the color by blending it with black, using the alpha provided.\"\"\" return self . blend ( Color . parse ( \"#000000\" ), alpha ) from_hls ( hsl ) classmethod Creates a color from the given HLS. HLS stands for Hue, Lightness & Saturation. It is more commonly known as HSL, but the colorsys library uses HLS instead so that's what we use too. Parameters: Name Type Description Default hsl RGBTriplet The HLS value to base the new color off of. required Source code in pytermgui/colors.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 @classmethod def from_hls ( cls , hsl : RGBTriplet ) -> Color : \"\"\"Creates a color from the given HLS. HLS stands for Hue, Lightness & Saturation. It is more commonly known as HSL, but the `colorsys` library uses HLS instead so that's what we use too. Args: hsl: The HLS value to base the new color off of. \"\"\" rgb = cast ( RGBTriplet , map ( lambda n : int ( 256 * n ), colorsys . hls_to_rgb ( * hsl )), ) return RGBColor . from_rgb ( rgb ) from_rgb ( rgb ) classmethod Creates a color from the given RGB. Parameters: Name Type Description Default rgb RGBTriplet The RGB value to base the new color off of. required Source code in pytermgui/colors.py 176 177 178 179 180 181 182 183 184 @classmethod def from_rgb ( cls , rgb : RGBTriplet ) -> Color : \"\"\"Creates a color from the given RGB. Args: rgb: The RGB value to base the new color off of. \"\"\" return RGBColor . from_rgb ( rgb ) get_default_background () classmethod Gets the terminal emulator's default foreground color. Source code in pytermgui/colors.py 286 287 288 289 290 291 292 293 @classmethod def get_default_background ( cls ) -> Color : \"\"\"Gets the terminal emulator's default foreground color.\"\"\" if cls . default_background is not None : return cls . default_background return _get_palette_color ( \"11\" ) get_default_foreground () classmethod Gets the terminal emulator's default foreground color. Source code in pytermgui/colors.py 277 278 279 280 281 282 283 284 @classmethod def get_default_foreground ( cls ) -> Color : \"\"\"Gets the terminal emulator's default foreground color.\"\"\" if cls . default_foreground is not None : return cls . default_foreground return _get_palette_color ( \"10\" ) get_localized () Creates a terminal-capability local Color instance. This method essentially allows for graceful degradation of colors in the terminal. Source code in pytermgui/colors.py 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 def get_localized ( self ) -> Color : \"\"\"Creates a terminal-capability local Color instance. This method essentially allows for graceful degradation of colors in the terminal. \"\"\" system = terminal . colorsystem if self . system <= system : return self colortype = SYSTEM_TO_TYPE [ system ] local = colortype . from_rgb ( self . rgb ) local . background = self . background return local green () property cached Returns the red component of this color. Source code in pytermgui/colors.py 231 232 233 234 235 @cached_property def green ( self ) -> Number : \"\"\"Returns the red component of this color.\"\"\" return self . rgb [ 1 ] hex () property cached Returns CSS-like HEX representation of this color. Source code in pytermgui/colors.py 267 268 269 270 271 272 273 274 275 @cached_property def hex ( self ) -> str : \"\"\"Returns CSS-like HEX representation of this color.\"\"\" buff = \"#\" for color in self . rgb : buff += f \" { format ( color , 'x' ) : 0>2 } \" return buff hls () property cached Returns the HLS (Hue, Lightness, Saturation) representation of this color. Source code in pytermgui/colors.py 243 244 245 246 247 @cached_property def hls ( self ) -> RGBTriplet : \"\"\"Returns the HLS (Hue, Lightness, Saturation) representation of this color.\"\"\" return colorsys . rgb_to_hls ( self . red / 256 , self . green / 256 , self . blue / 256 ) hue () property cached Returns the hue component of this color. Source code in pytermgui/colors.py 249 250 251 252 253 @cached_property def hue ( self ) -> float : \"\"\"Returns the hue component of this color.\"\"\" return self . hls [ 0 ] hue_offset ( offset ) Returns the color offset by the given hue. Source code in pytermgui/colors.py 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def hue_offset ( self , offset : float ) -> Color : \"\"\"Returns the color offset by the given hue.\"\"\" hue , lightness , saturation = colorsys . rgb_to_hls ( self . red / 256 , self . green / 256 , self . blue / 256 ) hue = ( hue + offset ) % 1 return Color . parse ( \";\" . join ( map ( lambda n : str ( int ( 256 * n )), colorsys . hls_to_rgb ( hue , lightness , saturation ), ) ), background = self . background , localize = False , ) lighten ( alpha = 0.5 ) Lightens the color by blending it with white, using the alpha provided. Source code in pytermgui/colors.py 471 472 473 474 def lighten ( self , alpha : float = 0.5 ) -> Color : \"\"\"Lightens the color by blending it with white, using the alpha provided.\"\"\" return self . blend ( Color . parse ( \"#FFFFFF\" ), alpha ) lightness () property cached Returns the lightness component of this color. Source code in pytermgui/colors.py 255 256 257 258 259 @cached_property def lightness ( self ) -> float : \"\"\"Returns the lightness component of this color.\"\"\" return self . hls [ 1 ] luminance () property cached Returns this color's perceived luminance (brightness). From https://stackoverflow.com/a/596243 Source code in pytermgui/colors.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 @cached_property def luminance ( self ) -> float : \"\"\"Returns this color's perceived luminance (brightness). From https://stackoverflow.com/a/596243 \"\"\" def _linearize ( color : float ) -> float : \"\"\"Converts sRGB color to linear value.\"\"\" if color <= 0.04045 : return color / 12.92 return (( color + 0.055 ) / 1.055 ) ** 2.4 red , green , blue = float ( self . rgb [ 0 ]), float ( self . rgb [ 1 ]), float ( self . rgb [ 2 ]) red /= 255 green /= 255 blue /= 255 red = _linearize ( red ) blue = _linearize ( blue ) green = _linearize ( green ) return 0.2126 * red + 0.7152 * green + 0.0722 * blue markup () property cached Returns the TIM representation of this color. Source code in pytermgui/colors.py 210 211 212 213 214 @cached_property def markup ( self ) -> str : \"\"\"Returns the TIM representation of this color.\"\"\" return ( \"@\" if self . background else \"\" ) + self . value name () property Returns the reverse-parseable name of this color. Source code in pytermgui/colors.py 295 296 297 298 299 @property def name ( self ) -> str : \"\"\"Returns the reverse-parseable name of this color.\"\"\" return ( \"@\" if self . background else \"\" ) + self . value parse ( text , background = False , localize = True , use_cache = False ) classmethod Uses str_to_color to parse some text into a Color . Source code in pytermgui/colors.py 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 @classmethod def parse ( cls , text : str , background : bool = False , # pylint: disable=redefined-outer-name localize : bool = True , use_cache : bool = False , ) -> Color : \"\"\"Uses `str_to_color` to parse some text into a `Color`.\"\"\" return str_to_color ( text = text , is_background = background , localize = localize , use_cache = use_cache , ) red () property cached Returns the red component of this color. Source code in pytermgui/colors.py 225 226 227 228 229 @cached_property def red ( self ) -> Number : \"\"\"Returns the red component of this color.\"\"\" return self . rgb [ 0 ] rgb () property cached Returns this color as a tuple of (red, green, blue) values. Source code in pytermgui/colors.py 216 217 218 219 220 221 222 223 @cached_property def rgb ( self ) -> RGBTriplet : \"\"\"Returns this color as a tuple of (red, green, blue) values.\"\"\" if self . _rgb is None : raise NotImplementedError return self . _rgb saturation () property cached Returns the saturation component of this color. Source code in pytermgui/colors.py 261 262 263 264 265 @cached_property def saturation ( self ) -> float : \"\"\"Returns the saturation component of this color.\"\"\" return self . hls [ 2 ] sequence () property Returns the ANSI sequence representation of the color. Source code in pytermgui/colors.py 204 205 206 207 208 @property def sequence ( self ) -> str : \"\"\"Returns the ANSI sequence representation of the color.\"\"\" raise NotImplementedError tetradic () property cached Computes the tetradic group this color is in. Tetradic colors are 4-way complements of eachother. Returns: Type Description tuple [ Color , Color , Color , Color ] This color, the first tetradic element and the second one. Source code in pytermgui/colors.py 388 389 390 391 392 393 394 395 396 397 398 @cached_property def tetradic ( self ) -> tuple [ Color , Color , Color , Color ]: \"\"\"Computes the tetradic group this color is in. Tetradic colors are 4-way complements of eachother. Returns: This color, the first tetradic element and the second one. \"\"\" return self , self . hue_offset ( 1 / 4 ), self . complement , self . hue_offset ( 3 / 4 ) triadic () property cached Computes the triadic group this color is in. Triadic colors are 3-way complements of eachother. Returns: Type Description tuple [ Color , Color , Color ] This color, the first triadic element and the second one. Source code in pytermgui/colors.py 376 377 378 379 380 381 382 383 384 385 386 @cached_property def triadic ( self ) -> tuple [ Color , Color , Color ]: \"\"\"Computes the triadic group this color is in. Triadic colors are 3-way complements of eachother. Returns: This color, the first triadic element and the second one. \"\"\" return self , self . hue_offset ( 1 / 3 ), self . hue_offset ( 2 / 3 ) GreyscaleRampColor Bases: IndexedColor The color type used for NO_COLOR greyscale ramps. This implementation uses the color's perceived brightness as its base. Source code in pytermgui/colors.py 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 class GreyscaleRampColor ( IndexedColor ): \"\"\"The color type used for NO_COLOR greyscale ramps. This implementation uses the color's perceived brightness as its base. \"\"\" @classmethod def from_rgb ( cls , rgb : RGBTriplet ) -> GreyscaleRampColor : \"\"\"Gets a greyscale color based on the given color's luminance.\"\"\" color = cls ( \"0\" ) setattr ( color , \"_rgb\" , rgb ) index = int ( 232 + color . brightness * 23 ) color . value = str ( index ) return color from_rgb ( rgb ) classmethod Gets a greyscale color based on the given color's luminance. Source code in pytermgui/colors.py 706 707 708 709 710 711 712 713 714 715 716 @classmethod def from_rgb ( cls , rgb : RGBTriplet ) -> GreyscaleRampColor : \"\"\"Gets a greyscale color based on the given color's luminance.\"\"\" color = cls ( \"0\" ) setattr ( color , \"_rgb\" , rgb ) index = int ( 232 + color . brightness * 23 ) color . value = str ( index ) return color HEXColor dataclass Bases: RGBColor An arbitrary, CSS-like HEX color. Source code in pytermgui/colors.py 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 @dataclass class HEXColor ( RGBColor ): \"\"\"An arbitrary, CSS-like HEX color.\"\"\" system = ColorSystem . TRUE def __post_init__ ( self ) -> None : \"\"\"Ensures data validity.\"\"\" data = self . value if data . startswith ( \"#\" ): data = data [ 1 :] indices = ( 0 , 2 ), ( 2 , 4 ), ( 4 , 6 ) rgb = [] for start , end in indices : value = data [ start : end ] rgb . append ( int ( value , base = 16 )) self . _rgb = rgb [ 0 ], rgb [ 1 ], rgb [ 2 ] assert len ( self . _rgb ) == 3 __post_init__ () Ensures data validity. Source code in pytermgui/colors.py 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 def __post_init__ ( self ) -> None : \"\"\"Ensures data validity.\"\"\" data = self . value if data . startswith ( \"#\" ): data = data [ 1 :] indices = ( 0 , 2 ), ( 2 , 4 ), ( 4 , 6 ) rgb = [] for start , end in indices : value = data [ start : end ] rgb . append ( int ( value , base = 16 )) self . _rgb = rgb [ 0 ], rgb [ 1 ], rgb [ 2 ] assert len ( self . _rgb ) == 3 IndexedColor dataclass Bases: Color A color representing an index into the xterm-256 color palette. Source code in pytermgui/colors.py 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 @dataclass ( repr = False ) class IndexedColor ( Color ): \"\"\"A color representing an index into the xterm-256 color palette.\"\"\" system = ColorSystem . EIGHT_BIT def __post_init__ ( self ) -> None : \"\"\"Ensures data validity.\"\"\" if not self . value . isdigit (): raise ValueError ( f \"IndexedColor value has to be numerical, got { self . value !r} .\" ) if not 0 <= int ( self . value ) < 256 : raise ValueError ( f \"IndexedColor value has to fit in range 0-255, got { self . value !r} .\" ) def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Yields a fancy looking string.\"\"\" yield f \"< { type ( self ) . __name__ } value: { self . value } , preview: \" yield { \"text\" : f \" { self : seq }{ PREVIEW_CHAR } \\x1b [0m\" , \"highlight\" : False } yield \">\" @classmethod def from_rgb ( cls , rgb : RGBTriplet ) -> IndexedColor : \"\"\"Constructs an `IndexedColor` from the closest matching option.\"\"\" if rgb in _COLOR_MATCH_CACHE : color = _COLOR_MATCH_CACHE [ rgb ] assert isinstance ( color , IndexedColor ) return color if terminal . colorsystem == ColorSystem . STANDARD : return StandardColor . from_rgb ( rgb ) # Normalize the color values red , green , blue = ( x / 255 for x in rgb ) # Calculate the eight-bit color index color_num = 16 color_num += 36 * round ( red * 5.0 ) color_num += 6 * round ( green * 5.0 ) color_num += round ( blue * 5.0 ) color = cls ( str ( color_num )) _COLOR_MATCH_CACHE [ rgb ] = color return color @property def sequence ( self ) -> str : r \"\"\"Returns an ANSI sequence representing this color.\"\"\" index = int ( self . value ) return \" \\x1b [\" + ( \"48\" if self . background else \"38\" ) + f \";5; { index } m\" @cached_property def rgb ( self ) -> RGBTriplet : \"\"\"Returns an RGB representation of this color.\"\"\" if self . _rgb is not None : return self . _rgb index = int ( self . value ) rgb = COLOR_TABLE [ index ] return ( rgb [ 0 ], rgb [ 1 ], rgb [ 2 ]) __fancy_repr__ () Yields a fancy looking string. Source code in pytermgui/colors.py 540 541 542 543 544 545 546 547 def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Yields a fancy looking string.\"\"\" yield f \"< { type ( self ) . __name__ } value: { self . value } , preview: \" yield { \"text\" : f \" { self : seq }{ PREVIEW_CHAR } \\x1b [0m\" , \"highlight\" : False } yield \">\" __post_init__ () Ensures data validity. Source code in pytermgui/colors.py 527 528 529 530 531 532 533 534 535 536 537 538 def __post_init__ ( self ) -> None : \"\"\"Ensures data validity.\"\"\" if not self . value . isdigit (): raise ValueError ( f \"IndexedColor value has to be numerical, got { self . value !r} .\" ) if not 0 <= int ( self . value ) < 256 : raise ValueError ( f \"IndexedColor value has to fit in range 0-255, got { self . value !r} .\" ) from_rgb ( rgb ) classmethod Constructs an IndexedColor from the closest matching option. Source code in pytermgui/colors.py 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 @classmethod def from_rgb ( cls , rgb : RGBTriplet ) -> IndexedColor : \"\"\"Constructs an `IndexedColor` from the closest matching option.\"\"\" if rgb in _COLOR_MATCH_CACHE : color = _COLOR_MATCH_CACHE [ rgb ] assert isinstance ( color , IndexedColor ) return color if terminal . colorsystem == ColorSystem . STANDARD : return StandardColor . from_rgb ( rgb ) # Normalize the color values red , green , blue = ( x / 255 for x in rgb ) # Calculate the eight-bit color index color_num = 16 color_num += 36 * round ( red * 5.0 ) color_num += 6 * round ( green * 5.0 ) color_num += round ( blue * 5.0 ) color = cls ( str ( color_num )) _COLOR_MATCH_CACHE [ rgb ] = color return color rgb () property cached Returns an RGB representation of this color. Source code in pytermgui/colors.py 584 585 586 587 588 589 590 591 592 593 594 @cached_property def rgb ( self ) -> RGBTriplet : \"\"\"Returns an RGB representation of this color.\"\"\" if self . _rgb is not None : return self . _rgb index = int ( self . value ) rgb = COLOR_TABLE [ index ] return ( rgb [ 0 ], rgb [ 1 ], rgb [ 2 ]) sequence () property Returns an ANSI sequence representing this color. Source code in pytermgui/colors.py 576 577 578 579 580 581 582 @property def sequence ( self ) -> str : r \"\"\"Returns an ANSI sequence representing this color.\"\"\" index = int ( self . value ) return \" \\x1b [\" + ( \"48\" if self . background else \"38\" ) + f \";5; { index } m\" RGBColor dataclass Bases: Color An arbitrary RGB color. Source code in pytermgui/colors.py 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 @dataclass ( repr = False ) class RGBColor ( Color ): \"\"\"An arbitrary RGB color.\"\"\" system = ColorSystem . TRUE def __post_init__ ( self ) -> None : \"\"\"Ensures data validity.\"\"\" if self . value . count ( \";\" ) != 2 : raise ValueError ( \"Invalid value passed to RGBColor.\" + f \" Format has to be rrr;ggg;bbb, got { self . value !r} .\" ) rgb = tuple ( int ( num ) for num in self . value . split ( \";\" )) self . _rgb = rgb [ 0 ], rgb [ 1 ], rgb [ 2 ] def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Yields a fancy looking string.\"\"\" yield ( f \"< { type ( self ) . __name__ } red: { self . red } , green: { self . green } ,\" + f \" blue: { self . blue } , preview: \" ) yield { \"text\" : f \" { self : seq }{ PREVIEW_CHAR } \\x1b [0m\" , \"highlight\" : False } yield \">\" @classmethod def from_rgb ( cls , rgb : RGBTriplet ) -> RGBColor : \"\"\"Returns an `RGBColor` from the given triplet.\"\"\" return cls ( \";\" . join ( map ( str , rgb ))) @property def red ( self ) -> float : \"\"\"Returns the red component of this color.\"\"\" return self . rgb [ 0 ] @property def green ( self ) -> float : \"\"\"Returns the green component of this color.\"\"\" return self . rgb [ 1 ] @property def blue ( self ) -> float : \"\"\"Returns the blue component of this color.\"\"\" return self . rgb [ 2 ] @property def sequence ( self ) -> str : \"\"\"Returns the ANSI sequence representing this color.\"\"\" return ( \" \\x1b [\" + ( \"48\" if self . background else \"38\" ) + \";2;\" + \";\" . join ( str ( num ) for num in self . rgb ) + \"m\" ) __fancy_repr__ () Yields a fancy looking string. Source code in pytermgui/colors.py 737 738 739 740 741 742 743 744 745 746 747 def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Yields a fancy looking string.\"\"\" yield ( f \"< { type ( self ) . __name__ } red: { self . red } , green: { self . green } ,\" + f \" blue: { self . blue } , preview: \" ) yield { \"text\" : f \" { self : seq }{ PREVIEW_CHAR } \\x1b [0m\" , \"highlight\" : False } yield \">\" __post_init__ () Ensures data validity. Source code in pytermgui/colors.py 725 726 727 728 729 730 731 732 733 734 735 def __post_init__ ( self ) -> None : \"\"\"Ensures data validity.\"\"\" if self . value . count ( \";\" ) != 2 : raise ValueError ( \"Invalid value passed to RGBColor.\" + f \" Format has to be rrr;ggg;bbb, got { self . value !r} .\" ) rgb = tuple ( int ( num ) for num in self . value . split ( \";\" )) self . _rgb = rgb [ 0 ], rgb [ 1 ], rgb [ 2 ] blue () property Returns the blue component of this color. Source code in pytermgui/colors.py 767 768 769 770 771 @property def blue ( self ) -> float : \"\"\"Returns the blue component of this color.\"\"\" return self . rgb [ 2 ] from_rgb ( rgb ) classmethod Returns an RGBColor from the given triplet. Source code in pytermgui/colors.py 749 750 751 752 753 @classmethod def from_rgb ( cls , rgb : RGBTriplet ) -> RGBColor : \"\"\"Returns an `RGBColor` from the given triplet.\"\"\" return cls ( \";\" . join ( map ( str , rgb ))) green () property Returns the green component of this color. Source code in pytermgui/colors.py 761 762 763 764 765 @property def green ( self ) -> float : \"\"\"Returns the green component of this color.\"\"\" return self . rgb [ 1 ] red () property Returns the red component of this color. Source code in pytermgui/colors.py 755 756 757 758 759 @property def red ( self ) -> float : \"\"\"Returns the red component of this color.\"\"\" return self . rgb [ 0 ] sequence () property Returns the ANSI sequence representing this color. Source code in pytermgui/colors.py 773 774 775 776 777 778 779 780 781 782 783 @property def sequence ( self ) -> str : \"\"\"Returns the ANSI sequence representing this color.\"\"\" return ( \" \\x1b [\" + ( \"48\" if self . background else \"38\" ) + \";2;\" + \";\" . join ( str ( num ) for num in self . rgb ) + \"m\" ) StandardColor Bases: IndexedColor A color in the xterm-16 palette. Source code in pytermgui/colors.py 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 class StandardColor ( IndexedColor ): \"\"\"A color in the xterm-16 palette.\"\"\" system = ColorSystem . STANDARD @property def name ( self ) -> str : \"\"\"Returns the markup-compatible name for this color.\"\"\" index = name = int ( self . value ) # Normal colors if 30 <= index <= 47 : name -= 30 elif 90 <= index <= 107 : name -= 82 return ( \"@\" if self . background else \"\" ) + str ( name ) @classmethod def from_ansi ( cls , code : str ) -> StandardColor : \"\"\"Creates a standard color from the given ANSI code. These codes have to be a digit ranging between 31 and 47. \"\"\" if not code . isdigit (): raise ColorSyntaxError ( f \"Standard color codes must be digits, not { code !r} .\" ) code_int = int ( code ) if not 30 <= code_int <= 47 and not 90 <= code_int <= 107 : raise ColorSyntaxError ( f \"Standard color codes must be in the range ]30;47[ or ]90;107[, got { code_int !r} .\" ) is_background = 40 <= code_int <= 47 or 100 <= code_int <= 107 if is_background : code_int -= 10 return cls ( str ( code_int ), background = is_background ) @classmethod def from_rgb ( cls , rgb : RGBTriplet ) -> StandardColor : \"\"\"Creates a color with the closest-matching xterm index, based on rgb. Args: rgb: The target color. \"\"\" if rgb in _COLOR_MATCH_CACHE : color = _COLOR_MATCH_CACHE [ rgb ] if color . system is ColorSystem . STANDARD : assert isinstance ( color , StandardColor ) return color # Find the least-different color in the table index = min ( range ( 16 ), key = lambda i : _get_color_difference ( rgb , COLOR_TABLE [ i ])) if index > 7 : index += 82 else : index += 30 color = cls ( str ( index )) _COLOR_MATCH_CACHE [ rgb ] = color return color @property def sequence ( self ) -> str : r \"\"\"Returns an ANSI sequence representing this color.\"\"\" index = int ( self . value ) if self . background : index += 10 return f \" \\x1b [ { index } m\" @cached_property def rgb ( self ) -> RGBTriplet : \"\"\"Returns an RGB representation of this color.\"\"\" index = int ( self . value ) if 30 <= index <= 47 : index -= 30 elif 90 <= index <= 107 : index -= 82 rgb = COLOR_TABLE [ index ] return ( rgb [ 0 ], rgb [ 1 ], rgb [ 2 ]) from_ansi ( code ) classmethod Creates a standard color from the given ANSI code. These codes have to be a digit ranging between 31 and 47. Source code in pytermgui/colors.py 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 @classmethod def from_ansi ( cls , code : str ) -> StandardColor : \"\"\"Creates a standard color from the given ANSI code. These codes have to be a digit ranging between 31 and 47. \"\"\" if not code . isdigit (): raise ColorSyntaxError ( f \"Standard color codes must be digits, not { code !r} .\" ) code_int = int ( code ) if not 30 <= code_int <= 47 and not 90 <= code_int <= 107 : raise ColorSyntaxError ( f \"Standard color codes must be in the range ]30;47[ or ]90;107[, got { code_int !r} .\" ) is_background = 40 <= code_int <= 47 or 100 <= code_int <= 107 if is_background : code_int -= 10 return cls ( str ( code_int ), background = is_background ) from_rgb ( rgb ) classmethod Creates a color with the closest-matching xterm index, based on rgb. Parameters: Name Type Description Default rgb RGBTriplet The target color. required Source code in pytermgui/colors.py 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 @classmethod def from_rgb ( cls , rgb : RGBTriplet ) -> StandardColor : \"\"\"Creates a color with the closest-matching xterm index, based on rgb. Args: rgb: The target color. \"\"\" if rgb in _COLOR_MATCH_CACHE : color = _COLOR_MATCH_CACHE [ rgb ] if color . system is ColorSystem . STANDARD : assert isinstance ( color , StandardColor ) return color # Find the least-different color in the table index = min ( range ( 16 ), key = lambda i : _get_color_difference ( rgb , COLOR_TABLE [ i ])) if index > 7 : index += 82 else : index += 30 color = cls ( str ( index )) _COLOR_MATCH_CACHE [ rgb ] = color return color name () property Returns the markup-compatible name for this color. Source code in pytermgui/colors.py 602 603 604 605 606 607 608 609 610 611 612 613 614 615 @property def name ( self ) -> str : \"\"\"Returns the markup-compatible name for this color.\"\"\" index = name = int ( self . value ) # Normal colors if 30 <= index <= 47 : name -= 30 elif 90 <= index <= 107 : name -= 82 return ( \"@\" if self . background else \"\" ) + str ( name ) rgb () property cached Returns an RGB representation of this color. Source code in pytermgui/colors.py 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 @cached_property def rgb ( self ) -> RGBTriplet : \"\"\"Returns an RGB representation of this color.\"\"\" index = int ( self . value ) if 30 <= index <= 47 : index -= 30 elif 90 <= index <= 107 : index -= 82 rgb = COLOR_TABLE [ index ] return ( rgb [ 0 ], rgb [ 1 ], rgb [ 2 ]) sequence () property Returns an ANSI sequence representing this color. Source code in pytermgui/colors.py 672 673 674 675 676 677 678 679 680 681 @property def sequence ( self ) -> str : r \"\"\"Returns an ANSI sequence representing this color.\"\"\" index = int ( self . value ) if self . background : index += 10 return f \" \\x1b [ { index } m\" background ( text , color , reset = True ) Sets the background color of the given text. Note that the given color will be forced into background = True . Parameters: Name Type Description Default text str The text to color. required color str | Color The color to use. See pytermgui.colors.str_to_color for accepted str formats. required reset bool Whether the return value should include a reset sequence at the end. True Returns: Type Description str The colored text, including a reset if set. Source code in pytermgui/colors.py 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 def background ( text : str , color : str | Color , reset : bool = True ) -> str : \"\"\"Sets the background color of the given text. Note that the given color will be forced into `background = True`. Args: text: The text to color. color: The color to use. See `pytermgui.colors.str_to_color` for accepted str formats. reset: Whether the return value should include a reset sequence at the end. Returns: The colored text, including a reset if set. \"\"\" if not isinstance ( color , Color ): color = str_to_color ( color ) color . background = True return color ( text , reset = reset ) clear_color_cache () Clears _COLOR_CACHE and _COLOR_MATCH_CACHE . Source code in pytermgui/colors.py 88 89 90 91 92 def clear_color_cache () -> None : \"\"\"Clears `_COLOR_CACHE` and `_COLOR_MATCH_CACHE`.\"\"\" _COLOR_CACHE . clear () _COLOR_MATCH_CACHE . clear () foreground ( text , color , reset = True ) Sets the foreground color of the given text. Note that the given color will be forced into background = True . Parameters: Name Type Description Default text str The text to color. required color str | Color The color to use. See pytermgui.colors.str_to_color for accepted str formats. required reset bool Whether the return value should include a reset sequence at the end. True Returns: Type Description str The colored text, including a reset if set. Source code in pytermgui/colors.py 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 def foreground ( text : str , color : str | Color , reset : bool = True ) -> str : \"\"\"Sets the foreground color of the given text. Note that the given color will be forced into `background = True`. Args: text: The text to color. color: The color to use. See `pytermgui.colors.str_to_color` for accepted str formats. reset: Whether the return value should include a reset sequence at the end. Returns: The colored text, including a reset if set. \"\"\" if not isinstance ( color , Color ): color = str_to_color ( color ) color . background = False return color ( text , reset = reset ) str_to_color ( text , is_background = False , localize = True , use_cache = True ) cached Creates a Color from the given text. Accepted formats: - 0-255: IndexedColor . - 'rrr;ggg;bbb': RGBColor . - '(#)rrggbb': HEXColor . Leading hash is optional. You can also add a leading '@' into the string to make the output represent a background color, such as @#123abc . Parameters: Name Type Description Default text str The string to format from. required is_background bool Whether the output should be forced into a background color. Mostly used internally, when set will take precedence over syntax of leading '@' symbol. False localize bool Whether get_localized should be called on the output color. True use_cache bool Whether caching should be used. True Source code in pytermgui/colors.py 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 @lru_cache ( maxsize = 1024 ) def str_to_color ( text : str , is_background : bool = False , localize : bool = True , use_cache : bool = True , ) -> Color : \"\"\"Creates a `Color` from the given text. Accepted formats: - 0-255: `IndexedColor`. - 'rrr;ggg;bbb': `RGBColor`. - '(#)rrggbb': `HEXColor`. Leading hash is optional. You can also add a leading '@' into the string to make the output represent a background color, such as `@#123abc`. Args: text: The string to format from. is_background: Whether the output should be forced into a background color. Mostly used internally, when set will take precedence over syntax of leading '@' symbol. localize: Whether `get_localized` should be called on the output color. use_cache: Whether caching should be used. \"\"\" def _trim_code ( code : str ) -> str : \"\"\"Trims the given color code.\"\"\" if not all ( char . isdigit () or char in \"m;\" for char in code ): return code is_background = code . startswith ( \"48;\" ) if ( code . startswith ( \"38;5;\" ) or code . startswith ( \"48;5;\" )) or ( code . startswith ( \"38;2;\" ) or code . startswith ( \"48;2;\" ) ): code = code [ 5 :] if code . endswith ( \"m\" ): code = code [: - 1 ] if is_background : code = \"@\" + code return code text = _trim_code ( text ) if not use_cache : str_to_color . cache_clear () if text . startswith ( \"@\" ): is_background = True text = text [ 1 :] if text in NAMED_COLORS : return str_to_color ( str ( NAMED_COLORS [ text ]), is_background = is_background ) color : Color # This code is not pretty, but having these separate branches for each type # should improve the performance by quite a large margin. match = RE_256 . match ( text ) if match is not None : # Note: At the moment, all colors become an `IndexedColor`, due to a large # amount of problems a separated `StandardColor` class caused. Not # sure if there are any real drawbacks to doing it this way, bar the # extra characters that 255 colors use up compared to xterm-16. color = IndexedColor ( match [ 0 ], background = is_background ) return color . get_localized () if localize else color match = RE_HEX . match ( text ) if match is not None : color = HEXColor ( match [ 0 ], background = is_background ) return color . get_localized () if localize else color match = RE_RGB . match ( text ) if match is not None : color = RGBColor ( match [ 0 ], background = is_background ) return color . get_localized () if localize else color raise ColorSyntaxError ( f \"Could not convert { text !r} into a `Color`.\" )","title":"colors"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color","text":"A terminal color. Parameters: Name Type Description Default value str The data contained within this color. required background bool Whether this color will represent a color. False These colors are all formattable. There are currently 2 'spec' strings: - f\"{my_color:tim}\" -> Returns self.markup - f\"{my_color:seq}\" -> Returns self.sequence They can thus be used in TIM strings ptg.tim.parse(\"[{my_color:tim}]Hello\") '[ ]Hello' And in normal, ANSI coded strings: >>> \"{my_color:seq}Hello\" '<my_color.sequence>Hello' Source code in pytermgui/colors.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 @dataclass class Color : # pylint: disable=too-many-public-methods \"\"\"A terminal color. Args: value: The data contained within this color. background: Whether this color will represent a color. These colors are all formattable. There are currently 2 'spec' strings: - f\"{my_color:tim}\" -> Returns self.markup - f\"{my_color:seq}\" -> Returns self.sequence They can thus be used in TIM strings: >>> ptg.tim.parse(\"[{my_color:tim}]Hello\") '[<my_color.markup>]Hello' And in normal, ANSI coded strings: >>> \"{my_color:seq}Hello\" '<my_color.sequence>Hello' \"\"\" value : str background : bool = False system : ColorSystem = field ( init = False ) default_foreground : Color | None = field ( default = None , repr = False ) default_background : Color | None = field ( default = None , repr = False ) _rgb : tuple [ int , int , int ] | None = field ( init = False , default = None , repr = False ) def __format__ ( self , spec : str ) -> str : \"\"\"Formats the color by the given specification.\"\"\" if spec == \"tim\" : return self . markup if spec == \"seq\" : return self . sequence return repr ( self ) @classmethod def from_rgb ( cls , rgb : RGBTriplet ) -> Color : \"\"\"Creates a color from the given RGB. Args: rgb: The RGB value to base the new color off of. \"\"\" return RGBColor . from_rgb ( rgb ) @classmethod def from_hls ( cls , hsl : RGBTriplet ) -> Color : \"\"\"Creates a color from the given HLS. HLS stands for Hue, Lightness & Saturation. It is more commonly known as HSL, but the `colorsys` library uses HLS instead so that's what we use too. Args: hsl: The HLS value to base the new color off of. \"\"\" rgb = cast ( RGBTriplet , map ( lambda n : int ( 256 * n ), colorsys . hls_to_rgb ( * hsl )), ) return RGBColor . from_rgb ( rgb ) @property def sequence ( self ) -> str : \"\"\"Returns the ANSI sequence representation of the color.\"\"\" raise NotImplementedError @cached_property def markup ( self ) -> str : \"\"\"Returns the TIM representation of this color.\"\"\" return ( \"@\" if self . background else \"\" ) + self . value @cached_property def rgb ( self ) -> RGBTriplet : \"\"\"Returns this color as a tuple of (red, green, blue) values.\"\"\" if self . _rgb is None : raise NotImplementedError return self . _rgb @cached_property def red ( self ) -> Number : \"\"\"Returns the red component of this color.\"\"\" return self . rgb [ 0 ] @cached_property def green ( self ) -> Number : \"\"\"Returns the red component of this color.\"\"\" return self . rgb [ 1 ] @cached_property def blue ( self ) -> Number : \"\"\"Returns the red component of this color.\"\"\" return self . rgb [ 2 ] @cached_property def hls ( self ) -> RGBTriplet : \"\"\"Returns the HLS (Hue, Lightness, Saturation) representation of this color.\"\"\" return colorsys . rgb_to_hls ( self . red / 256 , self . green / 256 , self . blue / 256 ) @cached_property def hue ( self ) -> float : \"\"\"Returns the hue component of this color.\"\"\" return self . hls [ 0 ] @cached_property def lightness ( self ) -> float : \"\"\"Returns the lightness component of this color.\"\"\" return self . hls [ 1 ] @cached_property def saturation ( self ) -> float : \"\"\"Returns the saturation component of this color.\"\"\" return self . hls [ 2 ] @cached_property def hex ( self ) -> str : \"\"\"Returns CSS-like HEX representation of this color.\"\"\" buff = \"#\" for color in self . rgb : buff += f \" { format ( color , 'x' ) : 0>2 } \" return buff @classmethod def get_default_foreground ( cls ) -> Color : \"\"\"Gets the terminal emulator's default foreground color.\"\"\" if cls . default_foreground is not None : return cls . default_foreground return _get_palette_color ( \"10\" ) @classmethod def get_default_background ( cls ) -> Color : \"\"\"Gets the terminal emulator's default foreground color.\"\"\" if cls . default_background is not None : return cls . default_background return _get_palette_color ( \"11\" ) @property def name ( self ) -> str : \"\"\"Returns the reverse-parseable name of this color.\"\"\" return ( \"@\" if self . background else \"\" ) + self . value @cached_property def luminance ( self ) -> float : \"\"\"Returns this color's perceived luminance (brightness). From https://stackoverflow.com/a/596243 \"\"\" def _linearize ( color : float ) -> float : \"\"\"Converts sRGB color to linear value.\"\"\" if color <= 0.04045 : return color / 12.92 return (( color + 0.055 ) / 1.055 ) ** 2.4 red , green , blue = float ( self . rgb [ 0 ]), float ( self . rgb [ 1 ]), float ( self . rgb [ 2 ]) red /= 255 green /= 255 blue /= 255 red = _linearize ( red ) blue = _linearize ( blue ) green = _linearize ( green ) return 0.2126 * red + 0.7152 * green + 0.0722 * blue def hue_offset ( self , offset : float ) -> Color : \"\"\"Returns the color offset by the given hue.\"\"\" hue , lightness , saturation = colorsys . rgb_to_hls ( self . red / 256 , self . green / 256 , self . blue / 256 ) hue = ( hue + offset ) % 1 return Color . parse ( \";\" . join ( map ( lambda n : str ( int ( 256 * n )), colorsys . hls_to_rgb ( hue , lightness , saturation ), ) ), background = self . background , localize = False , ) @cached_property def brightness ( self ) -> float : \"\"\"Returns the perceived \"brightness\" of a color. From https://stackoverflow.com/a/56678483 \"\"\" if self . luminance <= ( 216 / 24389 ): brightness = self . luminance * ( 24389 / 27 ) else : brightness = self . luminance ** ( 1 / 3 ) * 116 - 16 return brightness / 100 @cached_property def complement ( self ) -> Color : \"\"\"Returns the complement of this color.\"\"\" if self . hue == 0.0 : return ( Color . parse ( \"#FFFFFF\" ) if self . lightness == 0.0 else Color . parse ( \"#000000\" ) ) return self . hue_offset ( 0.5 ) @cached_property def triadic ( self ) -> tuple [ Color , Color , Color ]: \"\"\"Computes the triadic group this color is in. Triadic colors are 3-way complements of eachother. Returns: This color, the first triadic element and the second one. \"\"\" return self , self . hue_offset ( 1 / 3 ), self . hue_offset ( 2 / 3 ) @cached_property def tetradic ( self ) -> tuple [ Color , Color , Color , Color ]: \"\"\"Computes the tetradic group this color is in. Tetradic colors are 4-way complements of eachother. Returns: This color, the first tetradic element and the second one. \"\"\" return self , self . hue_offset ( 1 / 4 ), self . complement , self . hue_offset ( 3 / 4 ) @cached_property def analogous ( self ) -> tuple [ Color , Color , Color ]: \"\"\"Computes the analogous group this colors is in. Analogous colors are located next to eachother on the color wheel. Returns: The color to the left, this color and the color to the right. \"\"\" return self . hue_offset ( - 1 / 12 ), self , self . hue_offset ( 1 / 12 ) @cached_property def contrast ( self ) -> Color : \"\"\"Returns a color (black or white) that complies with the W3C contrast ratio guidelines.\"\"\" if self . luminance > 0.179 : return Color . parse ( \"#000000\" ) . blend_complement ( 0.05 ) return Color . parse ( \"#FFFFFF\" ) . blend_complement ( 0.05 ) def blend ( self , other : Color , alpha : float = 0.5 , localize : bool = False ) -> Color : \"\"\"Blends a color into another one. Args: other: The color to blend with. alpha: How much the other color should influence the outcome. localize: If set, the returned color will returned its localized version by running `get_localized` on it before returning. Returns: A `Color` that is the result of the blending. \"\"\" red1 , green1 , blue1 = self . rgb red2 , green2 , blue2 = other . rgb blended : Color = RGBColor . from_rgb ( ( int ( red1 + ( red2 - red1 ) * alpha ), int ( green1 + ( green2 - green1 ) * alpha ), int ( blue1 + ( blue2 - blue1 ) * alpha ), ) ) if localize : blended = blended . get_localized () return blended def blend_complement ( self , alpha : float = 0.5 ) -> Color : \"\"\"Blends this color with its complement. See `Color.blend`. \"\"\" return self . blend ( self . complement , alpha ) def blend_contrast ( self , alpha : float = 0.5 ) -> Color : \"\"\"Blends this color with its contrast pair. See `Color.blend`. \"\"\" return self . blend ( self . contrast , alpha ) def darken ( self , alpha : float = 0.5 ) -> Color : \"\"\"Darkens the color by blending it with black, using the alpha provided.\"\"\" return self . blend ( Color . parse ( \"#000000\" ), alpha ) def lighten ( self , alpha : float = 0.5 ) -> Color : \"\"\"Lightens the color by blending it with white, using the alpha provided.\"\"\" return self . blend ( Color . parse ( \"#FFFFFF\" ), alpha ) @classmethod def parse ( cls , text : str , background : bool = False , # pylint: disable=redefined-outer-name localize : bool = True , use_cache : bool = False , ) -> Color : \"\"\"Uses `str_to_color` to parse some text into a `Color`.\"\"\" return str_to_color ( text = text , is_background = background , localize = localize , use_cache = use_cache , ) def __call__ ( self , text : str , reset : bool = True ) -> str : \"\"\"Colors the given string.\"\"\" buff = self . sequence + text if reset : buff += reset_style () return buff def get_localized ( self ) -> Color : \"\"\"Creates a terminal-capability local Color instance. This method essentially allows for graceful degradation of colors in the terminal. \"\"\" system = terminal . colorsystem if self . system <= system : return self colortype = SYSTEM_TO_TYPE [ system ] local = colortype . from_rgb ( self . rgb ) local . background = self . background return local","title":"Color"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.__call__","text":"Colors the given string. Source code in pytermgui/colors.py 493 494 495 496 497 498 499 500 def __call__ ( self , text : str , reset : bool = True ) -> str : \"\"\"Colors the given string.\"\"\" buff = self . sequence + text if reset : buff += reset_style () return buff","title":"__call__()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.__format__","text":"Formats the color by the given specification. Source code in pytermgui/colors.py 165 166 167 168 169 170 171 172 173 174 def __format__ ( self , spec : str ) -> str : \"\"\"Formats the color by the given specification.\"\"\" if spec == \"tim\" : return self . markup if spec == \"seq\" : return self . sequence return repr ( self )","title":"__format__()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.analogous","text":"Computes the analogous group this colors is in. Analogous colors are located next to eachother on the color wheel. Returns: Type Description tuple [ Color , Color , Color ] The color to the left, this color and the color to the right. Source code in pytermgui/colors.py 400 401 402 403 404 405 406 407 408 409 410 @cached_property def analogous ( self ) -> tuple [ Color , Color , Color ]: \"\"\"Computes the analogous group this colors is in. Analogous colors are located next to eachother on the color wheel. Returns: The color to the left, this color and the color to the right. \"\"\" return self . hue_offset ( - 1 / 12 ), self , self . hue_offset ( 1 / 12 )","title":"analogous()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.blend","text":"Blends a color into another one. Parameters: Name Type Description Default other Color The color to blend with. required alpha float How much the other color should influence the outcome. 0.5 localize bool If set, the returned color will returned its localized version by running get_localized on it before returning. False Returns: Type Description Color A Color that is the result of the blending. Source code in pytermgui/colors.py 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 def blend ( self , other : Color , alpha : float = 0.5 , localize : bool = False ) -> Color : \"\"\"Blends a color into another one. Args: other: The color to blend with. alpha: How much the other color should influence the outcome. localize: If set, the returned color will returned its localized version by running `get_localized` on it before returning. Returns: A `Color` that is the result of the blending. \"\"\" red1 , green1 , blue1 = self . rgb red2 , green2 , blue2 = other . rgb blended : Color = RGBColor . from_rgb ( ( int ( red1 + ( red2 - red1 ) * alpha ), int ( green1 + ( green2 - green1 ) * alpha ), int ( blue1 + ( blue2 - blue1 ) * alpha ), ) ) if localize : blended = blended . get_localized () return blended","title":"blend()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.blend_complement","text":"Blends this color with its complement. See Color.blend . Source code in pytermgui/colors.py 450 451 452 453 454 455 456 def blend_complement ( self , alpha : float = 0.5 ) -> Color : \"\"\"Blends this color with its complement. See `Color.blend`. \"\"\" return self . blend ( self . complement , alpha )","title":"blend_complement()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.blend_contrast","text":"Blends this color with its contrast pair. See Color.blend . Source code in pytermgui/colors.py 458 459 460 461 462 463 464 def blend_contrast ( self , alpha : float = 0.5 ) -> Color : \"\"\"Blends this color with its contrast pair. See `Color.blend`. \"\"\" return self . blend ( self . contrast , alpha )","title":"blend_contrast()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.blue","text":"Returns the red component of this color. Source code in pytermgui/colors.py 237 238 239 240 241 @cached_property def blue ( self ) -> Number : \"\"\"Returns the red component of this color.\"\"\" return self . rgb [ 2 ]","title":"blue()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.brightness","text":"Returns the perceived \"brightness\" of a color. From https://stackoverflow.com/a/56678483 Source code in pytermgui/colors.py 348 349 350 351 352 353 354 355 356 357 358 359 360 361 @cached_property def brightness ( self ) -> float : \"\"\"Returns the perceived \"brightness\" of a color. From https://stackoverflow.com/a/56678483 \"\"\" if self . luminance <= ( 216 / 24389 ): brightness = self . luminance * ( 24389 / 27 ) else : brightness = self . luminance ** ( 1 / 3 ) * 116 - 16 return brightness / 100","title":"brightness()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.complement","text":"Returns the complement of this color. Source code in pytermgui/colors.py 363 364 365 366 367 368 369 370 371 372 373 374 @cached_property def complement ( self ) -> Color : \"\"\"Returns the complement of this color.\"\"\" if self . hue == 0.0 : return ( Color . parse ( \"#FFFFFF\" ) if self . lightness == 0.0 else Color . parse ( \"#000000\" ) ) return self . hue_offset ( 0.5 )","title":"complement()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.contrast","text":"Returns a color (black or white) that complies with the W3C contrast ratio guidelines. Source code in pytermgui/colors.py 412 413 414 415 416 417 418 419 @cached_property def contrast ( self ) -> Color : \"\"\"Returns a color (black or white) that complies with the W3C contrast ratio guidelines.\"\"\" if self . luminance > 0.179 : return Color . parse ( \"#000000\" ) . blend_complement ( 0.05 ) return Color . parse ( \"#FFFFFF\" ) . blend_complement ( 0.05 )","title":"contrast()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.darken","text":"Darkens the color by blending it with black, using the alpha provided. Source code in pytermgui/colors.py 466 467 468 469 def darken ( self , alpha : float = 0.5 ) -> Color : \"\"\"Darkens the color by blending it with black, using the alpha provided.\"\"\" return self . blend ( Color . parse ( \"#000000\" ), alpha )","title":"darken()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.from_hls","text":"Creates a color from the given HLS. HLS stands for Hue, Lightness & Saturation. It is more commonly known as HSL, but the colorsys library uses HLS instead so that's what we use too. Parameters: Name Type Description Default hsl RGBTriplet The HLS value to base the new color off of. required Source code in pytermgui/colors.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 @classmethod def from_hls ( cls , hsl : RGBTriplet ) -> Color : \"\"\"Creates a color from the given HLS. HLS stands for Hue, Lightness & Saturation. It is more commonly known as HSL, but the `colorsys` library uses HLS instead so that's what we use too. Args: hsl: The HLS value to base the new color off of. \"\"\" rgb = cast ( RGBTriplet , map ( lambda n : int ( 256 * n ), colorsys . hls_to_rgb ( * hsl )), ) return RGBColor . from_rgb ( rgb )","title":"from_hls()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.from_rgb","text":"Creates a color from the given RGB. Parameters: Name Type Description Default rgb RGBTriplet The RGB value to base the new color off of. required Source code in pytermgui/colors.py 176 177 178 179 180 181 182 183 184 @classmethod def from_rgb ( cls , rgb : RGBTriplet ) -> Color : \"\"\"Creates a color from the given RGB. Args: rgb: The RGB value to base the new color off of. \"\"\" return RGBColor . from_rgb ( rgb )","title":"from_rgb()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.get_default_background","text":"Gets the terminal emulator's default foreground color. Source code in pytermgui/colors.py 286 287 288 289 290 291 292 293 @classmethod def get_default_background ( cls ) -> Color : \"\"\"Gets the terminal emulator's default foreground color.\"\"\" if cls . default_background is not None : return cls . default_background return _get_palette_color ( \"11\" )","title":"get_default_background()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.get_default_foreground","text":"Gets the terminal emulator's default foreground color. Source code in pytermgui/colors.py 277 278 279 280 281 282 283 284 @classmethod def get_default_foreground ( cls ) -> Color : \"\"\"Gets the terminal emulator's default foreground color.\"\"\" if cls . default_foreground is not None : return cls . default_foreground return _get_palette_color ( \"10\" )","title":"get_default_foreground()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.get_localized","text":"Creates a terminal-capability local Color instance. This method essentially allows for graceful degradation of colors in the terminal. Source code in pytermgui/colors.py 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 def get_localized ( self ) -> Color : \"\"\"Creates a terminal-capability local Color instance. This method essentially allows for graceful degradation of colors in the terminal. \"\"\" system = terminal . colorsystem if self . system <= system : return self colortype = SYSTEM_TO_TYPE [ system ] local = colortype . from_rgb ( self . rgb ) local . background = self . background return local","title":"get_localized()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.green","text":"Returns the red component of this color. Source code in pytermgui/colors.py 231 232 233 234 235 @cached_property def green ( self ) -> Number : \"\"\"Returns the red component of this color.\"\"\" return self . rgb [ 1 ]","title":"green()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.hex","text":"Returns CSS-like HEX representation of this color. Source code in pytermgui/colors.py 267 268 269 270 271 272 273 274 275 @cached_property def hex ( self ) -> str : \"\"\"Returns CSS-like HEX representation of this color.\"\"\" buff = \"#\" for color in self . rgb : buff += f \" { format ( color , 'x' ) : 0>2 } \" return buff","title":"hex()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.hls","text":"Returns the HLS (Hue, Lightness, Saturation) representation of this color. Source code in pytermgui/colors.py 243 244 245 246 247 @cached_property def hls ( self ) -> RGBTriplet : \"\"\"Returns the HLS (Hue, Lightness, Saturation) representation of this color.\"\"\" return colorsys . rgb_to_hls ( self . red / 256 , self . green / 256 , self . blue / 256 )","title":"hls()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.hue","text":"Returns the hue component of this color. Source code in pytermgui/colors.py 249 250 251 252 253 @cached_property def hue ( self ) -> float : \"\"\"Returns the hue component of this color.\"\"\" return self . hls [ 0 ]","title":"hue()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.hue_offset","text":"Returns the color offset by the given hue. Source code in pytermgui/colors.py 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def hue_offset ( self , offset : float ) -> Color : \"\"\"Returns the color offset by the given hue.\"\"\" hue , lightness , saturation = colorsys . rgb_to_hls ( self . red / 256 , self . green / 256 , self . blue / 256 ) hue = ( hue + offset ) % 1 return Color . parse ( \";\" . join ( map ( lambda n : str ( int ( 256 * n )), colorsys . hls_to_rgb ( hue , lightness , saturation ), ) ), background = self . background , localize = False , )","title":"hue_offset()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.lighten","text":"Lightens the color by blending it with white, using the alpha provided. Source code in pytermgui/colors.py 471 472 473 474 def lighten ( self , alpha : float = 0.5 ) -> Color : \"\"\"Lightens the color by blending it with white, using the alpha provided.\"\"\" return self . blend ( Color . parse ( \"#FFFFFF\" ), alpha )","title":"lighten()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.lightness","text":"Returns the lightness component of this color. Source code in pytermgui/colors.py 255 256 257 258 259 @cached_property def lightness ( self ) -> float : \"\"\"Returns the lightness component of this color.\"\"\" return self . hls [ 1 ]","title":"lightness()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.luminance","text":"Returns this color's perceived luminance (brightness). From https://stackoverflow.com/a/596243 Source code in pytermgui/colors.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 @cached_property def luminance ( self ) -> float : \"\"\"Returns this color's perceived luminance (brightness). From https://stackoverflow.com/a/596243 \"\"\" def _linearize ( color : float ) -> float : \"\"\"Converts sRGB color to linear value.\"\"\" if color <= 0.04045 : return color / 12.92 return (( color + 0.055 ) / 1.055 ) ** 2.4 red , green , blue = float ( self . rgb [ 0 ]), float ( self . rgb [ 1 ]), float ( self . rgb [ 2 ]) red /= 255 green /= 255 blue /= 255 red = _linearize ( red ) blue = _linearize ( blue ) green = _linearize ( green ) return 0.2126 * red + 0.7152 * green + 0.0722 * blue","title":"luminance()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.markup","text":"Returns the TIM representation of this color. Source code in pytermgui/colors.py 210 211 212 213 214 @cached_property def markup ( self ) -> str : \"\"\"Returns the TIM representation of this color.\"\"\" return ( \"@\" if self . background else \"\" ) + self . value","title":"markup()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.name","text":"Returns the reverse-parseable name of this color. Source code in pytermgui/colors.py 295 296 297 298 299 @property def name ( self ) -> str : \"\"\"Returns the reverse-parseable name of this color.\"\"\" return ( \"@\" if self . background else \"\" ) + self . value","title":"name()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.parse","text":"Uses str_to_color to parse some text into a Color . Source code in pytermgui/colors.py 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 @classmethod def parse ( cls , text : str , background : bool = False , # pylint: disable=redefined-outer-name localize : bool = True , use_cache : bool = False , ) -> Color : \"\"\"Uses `str_to_color` to parse some text into a `Color`.\"\"\" return str_to_color ( text = text , is_background = background , localize = localize , use_cache = use_cache , )","title":"parse()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.red","text":"Returns the red component of this color. Source code in pytermgui/colors.py 225 226 227 228 229 @cached_property def red ( self ) -> Number : \"\"\"Returns the red component of this color.\"\"\" return self . rgb [ 0 ]","title":"red()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.rgb","text":"Returns this color as a tuple of (red, green, blue) values. Source code in pytermgui/colors.py 216 217 218 219 220 221 222 223 @cached_property def rgb ( self ) -> RGBTriplet : \"\"\"Returns this color as a tuple of (red, green, blue) values.\"\"\" if self . _rgb is None : raise NotImplementedError return self . _rgb","title":"rgb()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.saturation","text":"Returns the saturation component of this color. Source code in pytermgui/colors.py 261 262 263 264 265 @cached_property def saturation ( self ) -> float : \"\"\"Returns the saturation component of this color.\"\"\" return self . hls [ 2 ]","title":"saturation()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.sequence","text":"Returns the ANSI sequence representation of the color. Source code in pytermgui/colors.py 204 205 206 207 208 @property def sequence ( self ) -> str : \"\"\"Returns the ANSI sequence representation of the color.\"\"\" raise NotImplementedError","title":"sequence()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.tetradic","text":"Computes the tetradic group this color is in. Tetradic colors are 4-way complements of eachother. Returns: Type Description tuple [ Color , Color , Color , Color ] This color, the first tetradic element and the second one. Source code in pytermgui/colors.py 388 389 390 391 392 393 394 395 396 397 398 @cached_property def tetradic ( self ) -> tuple [ Color , Color , Color , Color ]: \"\"\"Computes the tetradic group this color is in. Tetradic colors are 4-way complements of eachother. Returns: This color, the first tetradic element and the second one. \"\"\" return self , self . hue_offset ( 1 / 4 ), self . complement , self . hue_offset ( 3 / 4 )","title":"tetradic()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.triadic","text":"Computes the triadic group this color is in. Triadic colors are 3-way complements of eachother. Returns: Type Description tuple [ Color , Color , Color ] This color, the first triadic element and the second one. Source code in pytermgui/colors.py 376 377 378 379 380 381 382 383 384 385 386 @cached_property def triadic ( self ) -> tuple [ Color , Color , Color ]: \"\"\"Computes the triadic group this color is in. Triadic colors are 3-way complements of eachother. Returns: This color, the first triadic element and the second one. \"\"\" return self , self . hue_offset ( 1 / 3 ), self . hue_offset ( 2 / 3 )","title":"triadic()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.GreyscaleRampColor","text":"Bases: IndexedColor The color type used for NO_COLOR greyscale ramps. This implementation uses the color's perceived brightness as its base. Source code in pytermgui/colors.py 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 class GreyscaleRampColor ( IndexedColor ): \"\"\"The color type used for NO_COLOR greyscale ramps. This implementation uses the color's perceived brightness as its base. \"\"\" @classmethod def from_rgb ( cls , rgb : RGBTriplet ) -> GreyscaleRampColor : \"\"\"Gets a greyscale color based on the given color's luminance.\"\"\" color = cls ( \"0\" ) setattr ( color , \"_rgb\" , rgb ) index = int ( 232 + color . brightness * 23 ) color . value = str ( index ) return color","title":"GreyscaleRampColor"},{"location":"reference/pytermgui/colors/#pytermgui.colors.GreyscaleRampColor.from_rgb","text":"Gets a greyscale color based on the given color's luminance. Source code in pytermgui/colors.py 706 707 708 709 710 711 712 713 714 715 716 @classmethod def from_rgb ( cls , rgb : RGBTriplet ) -> GreyscaleRampColor : \"\"\"Gets a greyscale color based on the given color's luminance.\"\"\" color = cls ( \"0\" ) setattr ( color , \"_rgb\" , rgb ) index = int ( 232 + color . brightness * 23 ) color . value = str ( index ) return color","title":"from_rgb()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.HEXColor","text":"Bases: RGBColor An arbitrary, CSS-like HEX color. Source code in pytermgui/colors.py 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 @dataclass class HEXColor ( RGBColor ): \"\"\"An arbitrary, CSS-like HEX color.\"\"\" system = ColorSystem . TRUE def __post_init__ ( self ) -> None : \"\"\"Ensures data validity.\"\"\" data = self . value if data . startswith ( \"#\" ): data = data [ 1 :] indices = ( 0 , 2 ), ( 2 , 4 ), ( 4 , 6 ) rgb = [] for start , end in indices : value = data [ start : end ] rgb . append ( int ( value , base = 16 )) self . _rgb = rgb [ 0 ], rgb [ 1 ], rgb [ 2 ] assert len ( self . _rgb ) == 3","title":"HEXColor"},{"location":"reference/pytermgui/colors/#pytermgui.colors.HEXColor.__post_init__","text":"Ensures data validity. Source code in pytermgui/colors.py 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 def __post_init__ ( self ) -> None : \"\"\"Ensures data validity.\"\"\" data = self . value if data . startswith ( \"#\" ): data = data [ 1 :] indices = ( 0 , 2 ), ( 2 , 4 ), ( 4 , 6 ) rgb = [] for start , end in indices : value = data [ start : end ] rgb . append ( int ( value , base = 16 )) self . _rgb = rgb [ 0 ], rgb [ 1 ], rgb [ 2 ] assert len ( self . _rgb ) == 3","title":"__post_init__()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.IndexedColor","text":"Bases: Color A color representing an index into the xterm-256 color palette. Source code in pytermgui/colors.py 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 @dataclass ( repr = False ) class IndexedColor ( Color ): \"\"\"A color representing an index into the xterm-256 color palette.\"\"\" system = ColorSystem . EIGHT_BIT def __post_init__ ( self ) -> None : \"\"\"Ensures data validity.\"\"\" if not self . value . isdigit (): raise ValueError ( f \"IndexedColor value has to be numerical, got { self . value !r} .\" ) if not 0 <= int ( self . value ) < 256 : raise ValueError ( f \"IndexedColor value has to fit in range 0-255, got { self . value !r} .\" ) def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Yields a fancy looking string.\"\"\" yield f \"< { type ( self ) . __name__ } value: { self . value } , preview: \" yield { \"text\" : f \" { self : seq }{ PREVIEW_CHAR } \\x1b [0m\" , \"highlight\" : False } yield \">\" @classmethod def from_rgb ( cls , rgb : RGBTriplet ) -> IndexedColor : \"\"\"Constructs an `IndexedColor` from the closest matching option.\"\"\" if rgb in _COLOR_MATCH_CACHE : color = _COLOR_MATCH_CACHE [ rgb ] assert isinstance ( color , IndexedColor ) return color if terminal . colorsystem == ColorSystem . STANDARD : return StandardColor . from_rgb ( rgb ) # Normalize the color values red , green , blue = ( x / 255 for x in rgb ) # Calculate the eight-bit color index color_num = 16 color_num += 36 * round ( red * 5.0 ) color_num += 6 * round ( green * 5.0 ) color_num += round ( blue * 5.0 ) color = cls ( str ( color_num )) _COLOR_MATCH_CACHE [ rgb ] = color return color @property def sequence ( self ) -> str : r \"\"\"Returns an ANSI sequence representing this color.\"\"\" index = int ( self . value ) return \" \\x1b [\" + ( \"48\" if self . background else \"38\" ) + f \";5; { index } m\" @cached_property def rgb ( self ) -> RGBTriplet : \"\"\"Returns an RGB representation of this color.\"\"\" if self . _rgb is not None : return self . _rgb index = int ( self . value ) rgb = COLOR_TABLE [ index ] return ( rgb [ 0 ], rgb [ 1 ], rgb [ 2 ])","title":"IndexedColor"},{"location":"reference/pytermgui/colors/#pytermgui.colors.IndexedColor.__fancy_repr__","text":"Yields a fancy looking string. Source code in pytermgui/colors.py 540 541 542 543 544 545 546 547 def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Yields a fancy looking string.\"\"\" yield f \"< { type ( self ) . __name__ } value: { self . value } , preview: \" yield { \"text\" : f \" { self : seq }{ PREVIEW_CHAR } \\x1b [0m\" , \"highlight\" : False } yield \">\"","title":"__fancy_repr__()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.IndexedColor.__post_init__","text":"Ensures data validity. Source code in pytermgui/colors.py 527 528 529 530 531 532 533 534 535 536 537 538 def __post_init__ ( self ) -> None : \"\"\"Ensures data validity.\"\"\" if not self . value . isdigit (): raise ValueError ( f \"IndexedColor value has to be numerical, got { self . value !r} .\" ) if not 0 <= int ( self . value ) < 256 : raise ValueError ( f \"IndexedColor value has to fit in range 0-255, got { self . value !r} .\" )","title":"__post_init__()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.IndexedColor.from_rgb","text":"Constructs an IndexedColor from the closest matching option. Source code in pytermgui/colors.py 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 @classmethod def from_rgb ( cls , rgb : RGBTriplet ) -> IndexedColor : \"\"\"Constructs an `IndexedColor` from the closest matching option.\"\"\" if rgb in _COLOR_MATCH_CACHE : color = _COLOR_MATCH_CACHE [ rgb ] assert isinstance ( color , IndexedColor ) return color if terminal . colorsystem == ColorSystem . STANDARD : return StandardColor . from_rgb ( rgb ) # Normalize the color values red , green , blue = ( x / 255 for x in rgb ) # Calculate the eight-bit color index color_num = 16 color_num += 36 * round ( red * 5.0 ) color_num += 6 * round ( green * 5.0 ) color_num += round ( blue * 5.0 ) color = cls ( str ( color_num )) _COLOR_MATCH_CACHE [ rgb ] = color return color","title":"from_rgb()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.IndexedColor.rgb","text":"Returns an RGB representation of this color. Source code in pytermgui/colors.py 584 585 586 587 588 589 590 591 592 593 594 @cached_property def rgb ( self ) -> RGBTriplet : \"\"\"Returns an RGB representation of this color.\"\"\" if self . _rgb is not None : return self . _rgb index = int ( self . value ) rgb = COLOR_TABLE [ index ] return ( rgb [ 0 ], rgb [ 1 ], rgb [ 2 ])","title":"rgb()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.IndexedColor.sequence","text":"Returns an ANSI sequence representing this color. Source code in pytermgui/colors.py 576 577 578 579 580 581 582 @property def sequence ( self ) -> str : r \"\"\"Returns an ANSI sequence representing this color.\"\"\" index = int ( self . value ) return \" \\x1b [\" + ( \"48\" if self . background else \"38\" ) + f \";5; { index } m\"","title":"sequence()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.RGBColor","text":"Bases: Color An arbitrary RGB color. Source code in pytermgui/colors.py 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 @dataclass ( repr = False ) class RGBColor ( Color ): \"\"\"An arbitrary RGB color.\"\"\" system = ColorSystem . TRUE def __post_init__ ( self ) -> None : \"\"\"Ensures data validity.\"\"\" if self . value . count ( \";\" ) != 2 : raise ValueError ( \"Invalid value passed to RGBColor.\" + f \" Format has to be rrr;ggg;bbb, got { self . value !r} .\" ) rgb = tuple ( int ( num ) for num in self . value . split ( \";\" )) self . _rgb = rgb [ 0 ], rgb [ 1 ], rgb [ 2 ] def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Yields a fancy looking string.\"\"\" yield ( f \"< { type ( self ) . __name__ } red: { self . red } , green: { self . green } ,\" + f \" blue: { self . blue } , preview: \" ) yield { \"text\" : f \" { self : seq }{ PREVIEW_CHAR } \\x1b [0m\" , \"highlight\" : False } yield \">\" @classmethod def from_rgb ( cls , rgb : RGBTriplet ) -> RGBColor : \"\"\"Returns an `RGBColor` from the given triplet.\"\"\" return cls ( \";\" . join ( map ( str , rgb ))) @property def red ( self ) -> float : \"\"\"Returns the red component of this color.\"\"\" return self . rgb [ 0 ] @property def green ( self ) -> float : \"\"\"Returns the green component of this color.\"\"\" return self . rgb [ 1 ] @property def blue ( self ) -> float : \"\"\"Returns the blue component of this color.\"\"\" return self . rgb [ 2 ] @property def sequence ( self ) -> str : \"\"\"Returns the ANSI sequence representing this color.\"\"\" return ( \" \\x1b [\" + ( \"48\" if self . background else \"38\" ) + \";2;\" + \";\" . join ( str ( num ) for num in self . rgb ) + \"m\" )","title":"RGBColor"},{"location":"reference/pytermgui/colors/#pytermgui.colors.RGBColor.__fancy_repr__","text":"Yields a fancy looking string. Source code in pytermgui/colors.py 737 738 739 740 741 742 743 744 745 746 747 def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Yields a fancy looking string.\"\"\" yield ( f \"< { type ( self ) . __name__ } red: { self . red } , green: { self . green } ,\" + f \" blue: { self . blue } , preview: \" ) yield { \"text\" : f \" { self : seq }{ PREVIEW_CHAR } \\x1b [0m\" , \"highlight\" : False } yield \">\"","title":"__fancy_repr__()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.RGBColor.__post_init__","text":"Ensures data validity. Source code in pytermgui/colors.py 725 726 727 728 729 730 731 732 733 734 735 def __post_init__ ( self ) -> None : \"\"\"Ensures data validity.\"\"\" if self . value . count ( \";\" ) != 2 : raise ValueError ( \"Invalid value passed to RGBColor.\" + f \" Format has to be rrr;ggg;bbb, got { self . value !r} .\" ) rgb = tuple ( int ( num ) for num in self . value . split ( \";\" )) self . _rgb = rgb [ 0 ], rgb [ 1 ], rgb [ 2 ]","title":"__post_init__()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.RGBColor.blue","text":"Returns the blue component of this color. Source code in pytermgui/colors.py 767 768 769 770 771 @property def blue ( self ) -> float : \"\"\"Returns the blue component of this color.\"\"\" return self . rgb [ 2 ]","title":"blue()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.RGBColor.from_rgb","text":"Returns an RGBColor from the given triplet. Source code in pytermgui/colors.py 749 750 751 752 753 @classmethod def from_rgb ( cls , rgb : RGBTriplet ) -> RGBColor : \"\"\"Returns an `RGBColor` from the given triplet.\"\"\" return cls ( \";\" . join ( map ( str , rgb )))","title":"from_rgb()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.RGBColor.green","text":"Returns the green component of this color. Source code in pytermgui/colors.py 761 762 763 764 765 @property def green ( self ) -> float : \"\"\"Returns the green component of this color.\"\"\" return self . rgb [ 1 ]","title":"green()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.RGBColor.red","text":"Returns the red component of this color. Source code in pytermgui/colors.py 755 756 757 758 759 @property def red ( self ) -> float : \"\"\"Returns the red component of this color.\"\"\" return self . rgb [ 0 ]","title":"red()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.RGBColor.sequence","text":"Returns the ANSI sequence representing this color. Source code in pytermgui/colors.py 773 774 775 776 777 778 779 780 781 782 783 @property def sequence ( self ) -> str : \"\"\"Returns the ANSI sequence representing this color.\"\"\" return ( \" \\x1b [\" + ( \"48\" if self . background else \"38\" ) + \";2;\" + \";\" . join ( str ( num ) for num in self . rgb ) + \"m\" )","title":"sequence()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.StandardColor","text":"Bases: IndexedColor A color in the xterm-16 palette. Source code in pytermgui/colors.py 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 class StandardColor ( IndexedColor ): \"\"\"A color in the xterm-16 palette.\"\"\" system = ColorSystem . STANDARD @property def name ( self ) -> str : \"\"\"Returns the markup-compatible name for this color.\"\"\" index = name = int ( self . value ) # Normal colors if 30 <= index <= 47 : name -= 30 elif 90 <= index <= 107 : name -= 82 return ( \"@\" if self . background else \"\" ) + str ( name ) @classmethod def from_ansi ( cls , code : str ) -> StandardColor : \"\"\"Creates a standard color from the given ANSI code. These codes have to be a digit ranging between 31 and 47. \"\"\" if not code . isdigit (): raise ColorSyntaxError ( f \"Standard color codes must be digits, not { code !r} .\" ) code_int = int ( code ) if not 30 <= code_int <= 47 and not 90 <= code_int <= 107 : raise ColorSyntaxError ( f \"Standard color codes must be in the range ]30;47[ or ]90;107[, got { code_int !r} .\" ) is_background = 40 <= code_int <= 47 or 100 <= code_int <= 107 if is_background : code_int -= 10 return cls ( str ( code_int ), background = is_background ) @classmethod def from_rgb ( cls , rgb : RGBTriplet ) -> StandardColor : \"\"\"Creates a color with the closest-matching xterm index, based on rgb. Args: rgb: The target color. \"\"\" if rgb in _COLOR_MATCH_CACHE : color = _COLOR_MATCH_CACHE [ rgb ] if color . system is ColorSystem . STANDARD : assert isinstance ( color , StandardColor ) return color # Find the least-different color in the table index = min ( range ( 16 ), key = lambda i : _get_color_difference ( rgb , COLOR_TABLE [ i ])) if index > 7 : index += 82 else : index += 30 color = cls ( str ( index )) _COLOR_MATCH_CACHE [ rgb ] = color return color @property def sequence ( self ) -> str : r \"\"\"Returns an ANSI sequence representing this color.\"\"\" index = int ( self . value ) if self . background : index += 10 return f \" \\x1b [ { index } m\" @cached_property def rgb ( self ) -> RGBTriplet : \"\"\"Returns an RGB representation of this color.\"\"\" index = int ( self . value ) if 30 <= index <= 47 : index -= 30 elif 90 <= index <= 107 : index -= 82 rgb = COLOR_TABLE [ index ] return ( rgb [ 0 ], rgb [ 1 ], rgb [ 2 ])","title":"StandardColor"},{"location":"reference/pytermgui/colors/#pytermgui.colors.StandardColor.from_ansi","text":"Creates a standard color from the given ANSI code. These codes have to be a digit ranging between 31 and 47. Source code in pytermgui/colors.py 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 @classmethod def from_ansi ( cls , code : str ) -> StandardColor : \"\"\"Creates a standard color from the given ANSI code. These codes have to be a digit ranging between 31 and 47. \"\"\" if not code . isdigit (): raise ColorSyntaxError ( f \"Standard color codes must be digits, not { code !r} .\" ) code_int = int ( code ) if not 30 <= code_int <= 47 and not 90 <= code_int <= 107 : raise ColorSyntaxError ( f \"Standard color codes must be in the range ]30;47[ or ]90;107[, got { code_int !r} .\" ) is_background = 40 <= code_int <= 47 or 100 <= code_int <= 107 if is_background : code_int -= 10 return cls ( str ( code_int ), background = is_background )","title":"from_ansi()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.StandardColor.from_rgb","text":"Creates a color with the closest-matching xterm index, based on rgb. Parameters: Name Type Description Default rgb RGBTriplet The target color. required Source code in pytermgui/colors.py 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 @classmethod def from_rgb ( cls , rgb : RGBTriplet ) -> StandardColor : \"\"\"Creates a color with the closest-matching xterm index, based on rgb. Args: rgb: The target color. \"\"\" if rgb in _COLOR_MATCH_CACHE : color = _COLOR_MATCH_CACHE [ rgb ] if color . system is ColorSystem . STANDARD : assert isinstance ( color , StandardColor ) return color # Find the least-different color in the table index = min ( range ( 16 ), key = lambda i : _get_color_difference ( rgb , COLOR_TABLE [ i ])) if index > 7 : index += 82 else : index += 30 color = cls ( str ( index )) _COLOR_MATCH_CACHE [ rgb ] = color return color","title":"from_rgb()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.StandardColor.name","text":"Returns the markup-compatible name for this color. Source code in pytermgui/colors.py 602 603 604 605 606 607 608 609 610 611 612 613 614 615 @property def name ( self ) -> str : \"\"\"Returns the markup-compatible name for this color.\"\"\" index = name = int ( self . value ) # Normal colors if 30 <= index <= 47 : name -= 30 elif 90 <= index <= 107 : name -= 82 return ( \"@\" if self . background else \"\" ) + str ( name )","title":"name()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.StandardColor.rgb","text":"Returns an RGB representation of this color. Source code in pytermgui/colors.py 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 @cached_property def rgb ( self ) -> RGBTriplet : \"\"\"Returns an RGB representation of this color.\"\"\" index = int ( self . value ) if 30 <= index <= 47 : index -= 30 elif 90 <= index <= 107 : index -= 82 rgb = COLOR_TABLE [ index ] return ( rgb [ 0 ], rgb [ 1 ], rgb [ 2 ])","title":"rgb()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.StandardColor.sequence","text":"Returns an ANSI sequence representing this color. Source code in pytermgui/colors.py 672 673 674 675 676 677 678 679 680 681 @property def sequence ( self ) -> str : r \"\"\"Returns an ANSI sequence representing this color.\"\"\" index = int ( self . value ) if self . background : index += 10 return f \" \\x1b [ { index } m\"","title":"sequence()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.background","text":"Sets the background color of the given text. Note that the given color will be forced into background = True . Parameters: Name Type Description Default text str The text to color. required color str | Color The color to use. See pytermgui.colors.str_to_color for accepted str formats. required reset bool Whether the return value should include a reset sequence at the end. True Returns: Type Description str The colored text, including a reset if set. Source code in pytermgui/colors.py 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 def background ( text : str , color : str | Color , reset : bool = True ) -> str : \"\"\"Sets the background color of the given text. Note that the given color will be forced into `background = True`. Args: text: The text to color. color: The color to use. See `pytermgui.colors.str_to_color` for accepted str formats. reset: Whether the return value should include a reset sequence at the end. Returns: The colored text, including a reset if set. \"\"\" if not isinstance ( color , Color ): color = str_to_color ( color ) color . background = True return color ( text , reset = reset )","title":"background()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.clear_color_cache","text":"Clears _COLOR_CACHE and _COLOR_MATCH_CACHE . Source code in pytermgui/colors.py 88 89 90 91 92 def clear_color_cache () -> None : \"\"\"Clears `_COLOR_CACHE` and `_COLOR_MATCH_CACHE`.\"\"\" _COLOR_CACHE . clear () _COLOR_MATCH_CACHE . clear ()","title":"clear_color_cache()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.foreground","text":"Sets the foreground color of the given text. Note that the given color will be forced into background = True . Parameters: Name Type Description Default text str The text to color. required color str | Color The color to use. See pytermgui.colors.str_to_color for accepted str formats. required reset bool Whether the return value should include a reset sequence at the end. True Returns: Type Description str The colored text, including a reset if set. Source code in pytermgui/colors.py 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 def foreground ( text : str , color : str | Color , reset : bool = True ) -> str : \"\"\"Sets the foreground color of the given text. Note that the given color will be forced into `background = True`. Args: text: The text to color. color: The color to use. See `pytermgui.colors.str_to_color` for accepted str formats. reset: Whether the return value should include a reset sequence at the end. Returns: The colored text, including a reset if set. \"\"\" if not isinstance ( color , Color ): color = str_to_color ( color ) color . background = False return color ( text , reset = reset )","title":"foreground()"},{"location":"reference/pytermgui/colors/#pytermgui.colors.str_to_color","text":"Creates a Color from the given text. Accepted formats: - 0-255: IndexedColor . - 'rrr;ggg;bbb': RGBColor . - '(#)rrggbb': HEXColor . Leading hash is optional. You can also add a leading '@' into the string to make the output represent a background color, such as @#123abc . Parameters: Name Type Description Default text str The string to format from. required is_background bool Whether the output should be forced into a background color. Mostly used internally, when set will take precedence over syntax of leading '@' symbol. False localize bool Whether get_localized should be called on the output color. True use_cache bool Whether caching should be used. True Source code in pytermgui/colors.py 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 @lru_cache ( maxsize = 1024 ) def str_to_color ( text : str , is_background : bool = False , localize : bool = True , use_cache : bool = True , ) -> Color : \"\"\"Creates a `Color` from the given text. Accepted formats: - 0-255: `IndexedColor`. - 'rrr;ggg;bbb': `RGBColor`. - '(#)rrggbb': `HEXColor`. Leading hash is optional. You can also add a leading '@' into the string to make the output represent a background color, such as `@#123abc`. Args: text: The string to format from. is_background: Whether the output should be forced into a background color. Mostly used internally, when set will take precedence over syntax of leading '@' symbol. localize: Whether `get_localized` should be called on the output color. use_cache: Whether caching should be used. \"\"\" def _trim_code ( code : str ) -> str : \"\"\"Trims the given color code.\"\"\" if not all ( char . isdigit () or char in \"m;\" for char in code ): return code is_background = code . startswith ( \"48;\" ) if ( code . startswith ( \"38;5;\" ) or code . startswith ( \"48;5;\" )) or ( code . startswith ( \"38;2;\" ) or code . startswith ( \"48;2;\" ) ): code = code [ 5 :] if code . endswith ( \"m\" ): code = code [: - 1 ] if is_background : code = \"@\" + code return code text = _trim_code ( text ) if not use_cache : str_to_color . cache_clear () if text . startswith ( \"@\" ): is_background = True text = text [ 1 :] if text in NAMED_COLORS : return str_to_color ( str ( NAMED_COLORS [ text ]), is_background = is_background ) color : Color # This code is not pretty, but having these separate branches for each type # should improve the performance by quite a large margin. match = RE_256 . match ( text ) if match is not None : # Note: At the moment, all colors become an `IndexedColor`, due to a large # amount of problems a separated `StandardColor` class caused. Not # sure if there are any real drawbacks to doing it this way, bar the # extra characters that 255 colors use up compared to xterm-16. color = IndexedColor ( match [ 0 ], background = is_background ) return color . get_localized () if localize else color match = RE_HEX . match ( text ) if match is not None : color = HEXColor ( match [ 0 ], background = is_background ) return color . get_localized () if localize else color match = RE_RGB . match ( text ) if match is not None : color = RGBColor ( match [ 0 ], background = is_background ) return color . get_localized () if localize else color raise ColorSyntaxError ( f \"Could not convert { text !r} into a `Color`.\" )","title":"str_to_color()"},{"location":"reference/pytermgui/context_managers/","text":"Ease-of-use context-manager classes & functions. There isn't much (or any) additional functionality provided in this module, most things are nicer-packaged combinations to already available methods from pytermgui.ansi_interface . alt_buffer ( echo = False , cursor = True ) Creates non-scrollable alt-buffer. This is useful for retrieving original terminal state after program end. Parameters: Name Type Description Default echo bool Whether unset_echo should be called on startup. False cursor bool Whether hide_cursor should be called on startup. True Source code in pytermgui/context_managers.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @contextmanager def alt_buffer ( echo : bool = False , cursor : bool = True ) -> Generator [ None , None , None ]: \"\"\"Creates non-scrollable alt-buffer. This is useful for retrieving original terminal state after program end. Args: echo: Whether `unset_echo` should be called on startup. cursor: Whether `hide_cursor` should be called on startup. \"\"\" terminal = get_terminal () try : set_alt_buffer () if not echo and name == \"posix\" and not terminal . is_interactive (): unset_echo () if not cursor : hide_cursor () yield finally : unset_alt_buffer () if not echo and name == \"posix\" and not terminal . is_interactive (): set_echo () cursor_up () if not cursor : show_cursor () cursor_up () cursor_at ( pos ) Gets callable to print at pos , incrementing y on every print. Parameters: Name Type Description Default pos tuple [ int , int ] The position to start printing at. Follows the order (columns, rows). required Yields: Type Description Callable [..., None] A callable printing function. This function forwards all arguments to print , Callable [..., None] but positions the cursor before doing so. After every call, the y position is Callable [..., None] incremented. Source code in pytermgui/context_managers.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @contextmanager def cursor_at ( pos : tuple [ int , int ]) -> Generator [ Callable [ ... , None ], None , None ]: \"\"\"Gets callable to print at `pos`, incrementing `y` on every print. Args: pos: The position to start printing at. Follows the order (columns, rows). Yields: A callable printing function. This function forwards all arguments to `print`, but positions the cursor before doing so. After every call, the y position is incremented. \"\"\" offset = 0 posx , posy = pos def printer ( * args : Any , ** kwargs : Any ) -> None : \"\"\"Print to posx, current y\"\"\" nonlocal offset print_to (( posx , posy + offset ), * args , ** kwargs ) offset += 1 try : save_cursor () yield printer finally : restore_cursor () mouse_handler ( events , method = 'decimal_xterm' ) Return a mouse handler function See help(report_mouse) for help about all of the methods. Parameters: Name Type Description Default events list [ str ] A list of pytermgui.ansi_interface.report_mouse events. required method str The method to use for reporting. Only decimal_urxvt and decimal_xterm are currently supported. 'decimal_xterm' Example use: import pytermgui as ptg with ptg . mouse_handler ([ \"press\" , \"hover\" ]) as mouse : while True : event = mouse ( ptg . getch ()) print ( type ( event )) print ( event . action ) print ( event . position ) 'pytermgui.ansi_interface.MouseEvent' 'pytermgui.ansi_interface.MouseAction.LEFT_CLICK' ( 33 , 55 ) Source code in pytermgui/context_managers.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 @contextmanager def mouse_handler ( events : list [ str ], method : str = \"decimal_xterm\" ) -> Generator [ MouseTranslator | None , None , None ]: \"\"\"Return a mouse handler function See `help(report_mouse)` for help about all of the methods. Args: events: A list of `pytermgui.ansi_interface.report_mouse` events. method: The method to use for reporting. Only `decimal_urxvt` and `decimal_xterm` are currently supported. Example use: ```python3 import pytermgui as ptg with ptg.mouse_handler([\"press\", \"hover\"]) as mouse: while True: event = mouse(ptg.getch()) print(type(event)) print(event.action) print(event.position) 'pytermgui.ansi_interface.MouseEvent' 'pytermgui.ansi_interface.MouseAction.LEFT_CLICK' (33, 55) ``` \"\"\" event = None try : for event in events : report_mouse ( event , method = method ) yield lambda code : translate_mouse ( code , method = method ) finally : if event is not None : report_mouse ( event , method = method , stop = True )","title":"context_managers"},{"location":"reference/pytermgui/context_managers/#pytermgui.context_managers.alt_buffer","text":"Creates non-scrollable alt-buffer. This is useful for retrieving original terminal state after program end. Parameters: Name Type Description Default echo bool Whether unset_echo should be called on startup. False cursor bool Whether hide_cursor should be called on startup. True Source code in pytermgui/context_managers.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @contextmanager def alt_buffer ( echo : bool = False , cursor : bool = True ) -> Generator [ None , None , None ]: \"\"\"Creates non-scrollable alt-buffer. This is useful for retrieving original terminal state after program end. Args: echo: Whether `unset_echo` should be called on startup. cursor: Whether `hide_cursor` should be called on startup. \"\"\" terminal = get_terminal () try : set_alt_buffer () if not echo and name == \"posix\" and not terminal . is_interactive (): unset_echo () if not cursor : hide_cursor () yield finally : unset_alt_buffer () if not echo and name == \"posix\" and not terminal . is_interactive (): set_echo () cursor_up () if not cursor : show_cursor () cursor_up ()","title":"alt_buffer()"},{"location":"reference/pytermgui/context_managers/#pytermgui.context_managers.cursor_at","text":"Gets callable to print at pos , incrementing y on every print. Parameters: Name Type Description Default pos tuple [ int , int ] The position to start printing at. Follows the order (columns, rows). required Yields: Type Description Callable [..., None] A callable printing function. This function forwards all arguments to print , Callable [..., None] but positions the cursor before doing so. After every call, the y position is Callable [..., None] incremented. Source code in pytermgui/context_managers.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @contextmanager def cursor_at ( pos : tuple [ int , int ]) -> Generator [ Callable [ ... , None ], None , None ]: \"\"\"Gets callable to print at `pos`, incrementing `y` on every print. Args: pos: The position to start printing at. Follows the order (columns, rows). Yields: A callable printing function. This function forwards all arguments to `print`, but positions the cursor before doing so. After every call, the y position is incremented. \"\"\" offset = 0 posx , posy = pos def printer ( * args : Any , ** kwargs : Any ) -> None : \"\"\"Print to posx, current y\"\"\" nonlocal offset print_to (( posx , posy + offset ), * args , ** kwargs ) offset += 1 try : save_cursor () yield printer finally : restore_cursor ()","title":"cursor_at()"},{"location":"reference/pytermgui/context_managers/#pytermgui.context_managers.mouse_handler","text":"Return a mouse handler function See help(report_mouse) for help about all of the methods. Parameters: Name Type Description Default events list [ str ] A list of pytermgui.ansi_interface.report_mouse events. required method str The method to use for reporting. Only decimal_urxvt and decimal_xterm are currently supported. 'decimal_xterm' Example use: import pytermgui as ptg with ptg . mouse_handler ([ \"press\" , \"hover\" ]) as mouse : while True : event = mouse ( ptg . getch ()) print ( type ( event )) print ( event . action ) print ( event . position ) 'pytermgui.ansi_interface.MouseEvent' 'pytermgui.ansi_interface.MouseAction.LEFT_CLICK' ( 33 , 55 ) Source code in pytermgui/context_managers.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 @contextmanager def mouse_handler ( events : list [ str ], method : str = \"decimal_xterm\" ) -> Generator [ MouseTranslator | None , None , None ]: \"\"\"Return a mouse handler function See `help(report_mouse)` for help about all of the methods. Args: events: A list of `pytermgui.ansi_interface.report_mouse` events. method: The method to use for reporting. Only `decimal_urxvt` and `decimal_xterm` are currently supported. Example use: ```python3 import pytermgui as ptg with ptg.mouse_handler([\"press\", \"hover\"]) as mouse: while True: event = mouse(ptg.getch()) print(type(event)) print(event.action) print(event.position) 'pytermgui.ansi_interface.MouseEvent' 'pytermgui.ansi_interface.MouseAction.LEFT_CLICK' (33, 55) ``` \"\"\" event = None try : for event in events : report_mouse ( event , method = method ) yield lambda code : translate_mouse ( code , method = method ) finally : if event is not None : report_mouse ( event , method = method , stop = True )","title":"mouse_handler()"},{"location":"reference/pytermgui/enums/","text":"This module provides commonly used enumerations for the library. It also has a class implementing Enum-s with default values. All Enums below subclass it, meaning you can use their get_default() methods to get the globally set default value. To modify defaults, use the defaults dictionary. CenteringPolicy Bases: DefaultEnum Policies to center Container according to. Source code in pytermgui/enums.py 59 60 61 62 63 64 class CenteringPolicy ( DefaultEnum ): \"\"\"Policies to center `Container` according to.\"\"\" ALL = _auto () VERTICAL = _auto () HORIZONTAL = _auto () DefaultEnum Bases: IntEnum An Enum class that can return its default value. Source code in pytermgui/enums.py 35 36 37 38 39 40 41 42 class DefaultEnum ( IntEnum ): \"\"\"An Enum class that can return its default value.\"\"\" @classmethod def get_default ( cls ) -> IntEnum | None : \"\"\"Get default value\"\"\" return defaults . get ( cls ) get_default () classmethod Get default value Source code in pytermgui/enums.py 38 39 40 41 42 @classmethod def get_default ( cls ) -> IntEnum | None : \"\"\"Get default value\"\"\" return defaults . get ( cls ) HorizontalAlignment Bases: DefaultEnum Policies to align widgets by. These are applied by the parent object, and are relative to them. Source code in pytermgui/enums.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class HorizontalAlignment ( DefaultEnum ): \"\"\"Policies to align widgets by. These are applied by the parent object, and are relative to them.\"\"\" LEFT = 0 \"\"\"Align widget to the left edge.\"\"\" CENTER = 1 \"\"\"Center widget in the available width.\"\"\" RIGHT = 2 \"\"\"Align widget to the right edge.\"\"\" CENTER = 1 class-attribute Center widget in the available width. LEFT = 0 class-attribute Align widget to the left edge. RIGHT = 2 class-attribute Align widget to the right edge. Overflow Bases: DefaultEnum Overflow policies implemented by Container. Source code in pytermgui/enums.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class Overflow ( DefaultEnum ): \"\"\"Overflow policies implemented by Container.\"\"\" HIDE = 0 \"\"\"Stop gathering lines once there is no room left.\"\"\" SCROLL = 1 \"\"\"Allow scrolling when there is too many lines.\"\"\" RESIZE = 2 \"\"\"Resize parent to fit with the new lines. Note: When applied to a window, this prevents resizing its height using the bottom border. \"\"\" # TODO: Implement Overflow.AUTO AUTO = 9999 \"\"\"NotImplemented\"\"\" AUTO = 9999 class-attribute NotImplemented HIDE = 0 class-attribute Stop gathering lines once there is no room left. RESIZE = 2 class-attribute Resize parent to fit with the new lines. Note When applied to a window, this prevents resizing its height using the bottom border. SCROLL = 1 class-attribute Allow scrolling when there is too many lines. SizePolicy Bases: DefaultEnum Values according to which Widget sizes are assigned. Source code in pytermgui/enums.py 45 46 47 48 49 50 51 52 53 54 55 56 class SizePolicy ( DefaultEnum ): \"\"\"Values according to which Widget sizes are assigned.\"\"\" FILL = 0 \"\"\"Inner widget will take up as much width as possible.\"\"\" STATIC = 1 \"\"\"Inner widget will take up an exact amount of width.\"\"\" RELATIVE = 2 \"\"\"Inner widget will take up widget.relative_width * available space.\"\"\" FILL = 0 class-attribute Inner widget will take up as much width as possible. RELATIVE = 2 class-attribute Inner widget will take up widget.relative_width * available space. STATIC = 1 class-attribute Inner widget will take up an exact amount of width. VerticalAlignment Bases: DefaultEnum Vertical alignment options for widgets. Source code in pytermgui/enums.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class VerticalAlignment ( DefaultEnum ): \"\"\"Vertical alignment options for widgets.\"\"\" TOP = 0 \"\"\"Align widgets to the top\"\"\" CENTER = 1 \"\"\"Align widgets in the center, with equal* padding on the top and bottom. Note: When the available height is not divisible by 2, the extra line of padding is added to the bottom. \"\"\" BOTTOM = 2 \"\"\"Align widgets to the bottom.\"\"\" BOTTOM = 2 class-attribute Align widgets to the bottom. CENTER = 1 class-attribute Align widgets in the center, with equal* padding on the top and bottom. Note When the available height is not divisible by 2, the extra line of padding is added to the bottom. TOP = 0 class-attribute Align widgets to the top WidgetChange Bases: Enum The type of change that happened within a widget. Source code in pytermgui/enums.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 class WidgetChange ( Enum ): \"\"\"The type of change that happened within a widget.\"\"\" LINES = _auto () \"\"\"The result of `get_lines` has changed, but size changes didn't happen.\"\"\" SIZE = _auto () \"\"\"Both WIDTH and HEIGHT has changed.\"\"\" WIDTH = _auto () \"\"\"The width of the widget changed, possibly involving LINES type changes.\"\"\" HEIGHT = _auto () \"\"\"The height of the widget changed, possibly involving LINES type changes.\"\"\" HEIGHT = _auto () class-attribute The height of the widget changed, possibly involving LINES type changes. LINES = _auto () class-attribute The result of get_lines has changed, but size changes didn't happen. SIZE = _auto () class-attribute Both WIDTH and HEIGHT has changed. WIDTH = _auto () class-attribute The width of the widget changed, possibly involving LINES type changes.","title":"enums"},{"location":"reference/pytermgui/enums/#pytermgui.enums.CenteringPolicy","text":"Bases: DefaultEnum Policies to center Container according to. Source code in pytermgui/enums.py 59 60 61 62 63 64 class CenteringPolicy ( DefaultEnum ): \"\"\"Policies to center `Container` according to.\"\"\" ALL = _auto () VERTICAL = _auto () HORIZONTAL = _auto ()","title":"CenteringPolicy"},{"location":"reference/pytermgui/enums/#pytermgui.enums.DefaultEnum","text":"Bases: IntEnum An Enum class that can return its default value. Source code in pytermgui/enums.py 35 36 37 38 39 40 41 42 class DefaultEnum ( IntEnum ): \"\"\"An Enum class that can return its default value.\"\"\" @classmethod def get_default ( cls ) -> IntEnum | None : \"\"\"Get default value\"\"\" return defaults . get ( cls )","title":"DefaultEnum"},{"location":"reference/pytermgui/enums/#pytermgui.enums.DefaultEnum.get_default","text":"Get default value Source code in pytermgui/enums.py 38 39 40 41 42 @classmethod def get_default ( cls ) -> IntEnum | None : \"\"\"Get default value\"\"\" return defaults . get ( cls )","title":"get_default()"},{"location":"reference/pytermgui/enums/#pytermgui.enums.HorizontalAlignment","text":"Bases: DefaultEnum Policies to align widgets by. These are applied by the parent object, and are relative to them. Source code in pytermgui/enums.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class HorizontalAlignment ( DefaultEnum ): \"\"\"Policies to align widgets by. These are applied by the parent object, and are relative to them.\"\"\" LEFT = 0 \"\"\"Align widget to the left edge.\"\"\" CENTER = 1 \"\"\"Center widget in the available width.\"\"\" RIGHT = 2 \"\"\"Align widget to the right edge.\"\"\"","title":"HorizontalAlignment"},{"location":"reference/pytermgui/enums/#pytermgui.enums.HorizontalAlignment.CENTER","text":"Center widget in the available width.","title":"CENTER"},{"location":"reference/pytermgui/enums/#pytermgui.enums.HorizontalAlignment.LEFT","text":"Align widget to the left edge.","title":"LEFT"},{"location":"reference/pytermgui/enums/#pytermgui.enums.HorizontalAlignment.RIGHT","text":"Align widget to the right edge.","title":"RIGHT"},{"location":"reference/pytermgui/enums/#pytermgui.enums.Overflow","text":"Bases: DefaultEnum Overflow policies implemented by Container. Source code in pytermgui/enums.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class Overflow ( DefaultEnum ): \"\"\"Overflow policies implemented by Container.\"\"\" HIDE = 0 \"\"\"Stop gathering lines once there is no room left.\"\"\" SCROLL = 1 \"\"\"Allow scrolling when there is too many lines.\"\"\" RESIZE = 2 \"\"\"Resize parent to fit with the new lines. Note: When applied to a window, this prevents resizing its height using the bottom border. \"\"\" # TODO: Implement Overflow.AUTO AUTO = 9999 \"\"\"NotImplemented\"\"\"","title":"Overflow"},{"location":"reference/pytermgui/enums/#pytermgui.enums.Overflow.AUTO","text":"NotImplemented","title":"AUTO"},{"location":"reference/pytermgui/enums/#pytermgui.enums.Overflow.HIDE","text":"Stop gathering lines once there is no room left.","title":"HIDE"},{"location":"reference/pytermgui/enums/#pytermgui.enums.Overflow.RESIZE","text":"Resize parent to fit with the new lines. Note When applied to a window, this prevents resizing its height using the bottom border.","title":"RESIZE"},{"location":"reference/pytermgui/enums/#pytermgui.enums.Overflow.SCROLL","text":"Allow scrolling when there is too many lines.","title":"SCROLL"},{"location":"reference/pytermgui/enums/#pytermgui.enums.SizePolicy","text":"Bases: DefaultEnum Values according to which Widget sizes are assigned. Source code in pytermgui/enums.py 45 46 47 48 49 50 51 52 53 54 55 56 class SizePolicy ( DefaultEnum ): \"\"\"Values according to which Widget sizes are assigned.\"\"\" FILL = 0 \"\"\"Inner widget will take up as much width as possible.\"\"\" STATIC = 1 \"\"\"Inner widget will take up an exact amount of width.\"\"\" RELATIVE = 2 \"\"\"Inner widget will take up widget.relative_width * available space.\"\"\"","title":"SizePolicy"},{"location":"reference/pytermgui/enums/#pytermgui.enums.SizePolicy.FILL","text":"Inner widget will take up as much width as possible.","title":"FILL"},{"location":"reference/pytermgui/enums/#pytermgui.enums.SizePolicy.RELATIVE","text":"Inner widget will take up widget.relative_width * available space.","title":"RELATIVE"},{"location":"reference/pytermgui/enums/#pytermgui.enums.SizePolicy.STATIC","text":"Inner widget will take up an exact amount of width.","title":"STATIC"},{"location":"reference/pytermgui/enums/#pytermgui.enums.VerticalAlignment","text":"Bases: DefaultEnum Vertical alignment options for widgets. Source code in pytermgui/enums.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class VerticalAlignment ( DefaultEnum ): \"\"\"Vertical alignment options for widgets.\"\"\" TOP = 0 \"\"\"Align widgets to the top\"\"\" CENTER = 1 \"\"\"Align widgets in the center, with equal* padding on the top and bottom. Note: When the available height is not divisible by 2, the extra line of padding is added to the bottom. \"\"\" BOTTOM = 2 \"\"\"Align widgets to the bottom.\"\"\"","title":"VerticalAlignment"},{"location":"reference/pytermgui/enums/#pytermgui.enums.VerticalAlignment.BOTTOM","text":"Align widgets to the bottom.","title":"BOTTOM"},{"location":"reference/pytermgui/enums/#pytermgui.enums.VerticalAlignment.CENTER","text":"Align widgets in the center, with equal* padding on the top and bottom. Note When the available height is not divisible by 2, the extra line of padding is added to the bottom.","title":"CENTER"},{"location":"reference/pytermgui/enums/#pytermgui.enums.VerticalAlignment.TOP","text":"Align widgets to the top","title":"TOP"},{"location":"reference/pytermgui/enums/#pytermgui.enums.WidgetChange","text":"Bases: Enum The type of change that happened within a widget. Source code in pytermgui/enums.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 class WidgetChange ( Enum ): \"\"\"The type of change that happened within a widget.\"\"\" LINES = _auto () \"\"\"The result of `get_lines` has changed, but size changes didn't happen.\"\"\" SIZE = _auto () \"\"\"Both WIDTH and HEIGHT has changed.\"\"\" WIDTH = _auto () \"\"\"The width of the widget changed, possibly involving LINES type changes.\"\"\" HEIGHT = _auto () \"\"\"The height of the widget changed, possibly involving LINES type changes.\"\"\"","title":"WidgetChange"},{"location":"reference/pytermgui/enums/#pytermgui.enums.WidgetChange.HEIGHT","text":"The height of the widget changed, possibly involving LINES type changes.","title":"HEIGHT"},{"location":"reference/pytermgui/enums/#pytermgui.enums.WidgetChange.LINES","text":"The result of get_lines has changed, but size changes didn't happen.","title":"LINES"},{"location":"reference/pytermgui/enums/#pytermgui.enums.WidgetChange.SIZE","text":"Both WIDTH and HEIGHT has changed.","title":"SIZE"},{"location":"reference/pytermgui/enums/#pytermgui.enums.WidgetChange.WIDTH","text":"The width of the widget changed, possibly involving LINES type changes.","title":"WIDTH"},{"location":"reference/pytermgui/exceptions/","text":"Custom Exception-s used in pytermgui. AnsiSyntaxError Bases: ParserSyntaxError Raised when parsed ANSI text contains an error. Source code in pytermgui/exceptions.py 90 91 92 93 class AnsiSyntaxError ( ParserSyntaxError ): \"\"\"Raised when parsed ANSI text contains an error.\"\"\" _delimiters = ( \" \\\\ x1b[\" , \"m\" ) ColorSyntaxError Bases: Exception Raised when a color string could not be parsed into a pytermgui.colors.Color Source code in pytermgui/exceptions.py 29 30 class ColorSyntaxError ( Exception ): \"\"\"Raised when a color string could not be parsed into a `pytermgui.colors.Color`\"\"\" LineLengthError Bases: Exception Raised when a widget line is not the expected length. Source code in pytermgui/exceptions.py 25 26 class LineLengthError ( Exception ): \"\"\"Raised when a widget line is not the expected length.\"\"\" MarkupSyntaxError Bases: ParserSyntaxError Raised when parsed markup text contains an error. Source code in pytermgui/exceptions.py 84 85 86 87 class MarkupSyntaxError ( ParserSyntaxError ): \"\"\"Raised when parsed markup text contains an error.\"\"\" _delimiters = ( \"[\" , \"]\" ) ParserSyntaxError dataclass Bases: Exception Parent exception for unparsable strings. This exception takes some basic parameters, and formats a message depending on the _delimiters value. This has to be supplied by each child, while the rest of the arguments are to be given at construction. Source code in pytermgui/exceptions.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 @dataclass class ParserSyntaxError ( Exception ): \"\"\"Parent exception for unparsable strings. This exception takes some basic parameters, and formats a message depending on the _delimiters value. This has to be supplied by each child, while the rest of the arguments are to be given at construction.\"\"\" tag : str cause : str context : str _delimiters : tuple [ str , str ] = field ( init = False ) @property def message ( self ) -> str : \"\"\"Create message from tag, context and cause.\"\"\" msg = f 'Tag \" { self . tag } \" ' if self . context != \"\" : index = self . context . find ( self . tag ) escaped_context = repr ( self . context ) . strip ( \"'\" ) if len ( self . context ) > 50 : escaped_context = ( \"...\" + ascii ( self . context ) . strip ( \"'\" )[ max ( index - 25 , 0 ) : index + 25 ] + \"...\" ) highlighted = escaped_context . replace ( self . tag , \" \\x1b [31m \\x1b [1m\" + self . tag + \" \\x1b [0m\" , 1 ) msg += f 'in string \" { highlighted } \" ' return f \" { msg }{ self . cause } .\" def escape_message ( self ) -> str : \"\"\"Return message with markup tags escaped.\"\"\" char = self . _delimiters [ 0 ] return self . message . replace ( char , \" \\\\ \" + char ) def __str__ ( self ) -> str : \"\"\"Show message.\"\"\" return self . message __str__ () Show message. Source code in pytermgui/exceptions.py 78 79 80 81 def __str__ ( self ) -> str : \"\"\"Show message.\"\"\" return self . message escape_message () Return message with markup tags escaped. Source code in pytermgui/exceptions.py 72 73 74 75 76 def escape_message ( self ) -> str : \"\"\"Return message with markup tags escaped.\"\"\" char = self . _delimiters [ 0 ] return self . message . replace ( char , \" \\\\ \" + char ) message () property Create message from tag, context and cause. Source code in pytermgui/exceptions.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @property def message ( self ) -> str : \"\"\"Create message from tag, context and cause.\"\"\" msg = f 'Tag \" { self . tag } \" ' if self . context != \"\" : index = self . context . find ( self . tag ) escaped_context = repr ( self . context ) . strip ( \"'\" ) if len ( self . context ) > 50 : escaped_context = ( \"...\" + ascii ( self . context ) . strip ( \"'\" )[ max ( index - 25 , 0 ) : index + 25 ] + \"...\" ) highlighted = escaped_context . replace ( self . tag , \" \\x1b [31m \\x1b [1m\" + self . tag + \" \\x1b [0m\" , 1 ) msg += f 'in string \" { highlighted } \" ' return f \" { msg }{ self . cause } .\" TimeoutException Bases: Exception Raised when an action has timed out. Source code in pytermgui/exceptions.py 17 18 class TimeoutException ( Exception ): \"\"\"Raised when an action has timed out.\"\"\" WidthExceededError Bases: Exception Raised when an element's width is larger than the screen. Source code in pytermgui/exceptions.py 21 22 class WidthExceededError ( Exception ): \"\"\"Raised when an element's width is larger than the screen.\"\"\"","title":"exceptions"},{"location":"reference/pytermgui/exceptions/#pytermgui.exceptions.AnsiSyntaxError","text":"Bases: ParserSyntaxError Raised when parsed ANSI text contains an error. Source code in pytermgui/exceptions.py 90 91 92 93 class AnsiSyntaxError ( ParserSyntaxError ): \"\"\"Raised when parsed ANSI text contains an error.\"\"\" _delimiters = ( \" \\\\ x1b[\" , \"m\" )","title":"AnsiSyntaxError"},{"location":"reference/pytermgui/exceptions/#pytermgui.exceptions.ColorSyntaxError","text":"Bases: Exception Raised when a color string could not be parsed into a pytermgui.colors.Color Source code in pytermgui/exceptions.py 29 30 class ColorSyntaxError ( Exception ): \"\"\"Raised when a color string could not be parsed into a `pytermgui.colors.Color`\"\"\"","title":"ColorSyntaxError"},{"location":"reference/pytermgui/exceptions/#pytermgui.exceptions.LineLengthError","text":"Bases: Exception Raised when a widget line is not the expected length. Source code in pytermgui/exceptions.py 25 26 class LineLengthError ( Exception ): \"\"\"Raised when a widget line is not the expected length.\"\"\"","title":"LineLengthError"},{"location":"reference/pytermgui/exceptions/#pytermgui.exceptions.MarkupSyntaxError","text":"Bases: ParserSyntaxError Raised when parsed markup text contains an error. Source code in pytermgui/exceptions.py 84 85 86 87 class MarkupSyntaxError ( ParserSyntaxError ): \"\"\"Raised when parsed markup text contains an error.\"\"\" _delimiters = ( \"[\" , \"]\" )","title":"MarkupSyntaxError"},{"location":"reference/pytermgui/exceptions/#pytermgui.exceptions.ParserSyntaxError","text":"Bases: Exception Parent exception for unparsable strings. This exception takes some basic parameters, and formats a message depending on the _delimiters value. This has to be supplied by each child, while the rest of the arguments are to be given at construction. Source code in pytermgui/exceptions.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 @dataclass class ParserSyntaxError ( Exception ): \"\"\"Parent exception for unparsable strings. This exception takes some basic parameters, and formats a message depending on the _delimiters value. This has to be supplied by each child, while the rest of the arguments are to be given at construction.\"\"\" tag : str cause : str context : str _delimiters : tuple [ str , str ] = field ( init = False ) @property def message ( self ) -> str : \"\"\"Create message from tag, context and cause.\"\"\" msg = f 'Tag \" { self . tag } \" ' if self . context != \"\" : index = self . context . find ( self . tag ) escaped_context = repr ( self . context ) . strip ( \"'\" ) if len ( self . context ) > 50 : escaped_context = ( \"...\" + ascii ( self . context ) . strip ( \"'\" )[ max ( index - 25 , 0 ) : index + 25 ] + \"...\" ) highlighted = escaped_context . replace ( self . tag , \" \\x1b [31m \\x1b [1m\" + self . tag + \" \\x1b [0m\" , 1 ) msg += f 'in string \" { highlighted } \" ' return f \" { msg }{ self . cause } .\" def escape_message ( self ) -> str : \"\"\"Return message with markup tags escaped.\"\"\" char = self . _delimiters [ 0 ] return self . message . replace ( char , \" \\\\ \" + char ) def __str__ ( self ) -> str : \"\"\"Show message.\"\"\" return self . message","title":"ParserSyntaxError"},{"location":"reference/pytermgui/exceptions/#pytermgui.exceptions.ParserSyntaxError.__str__","text":"Show message. Source code in pytermgui/exceptions.py 78 79 80 81 def __str__ ( self ) -> str : \"\"\"Show message.\"\"\" return self . message","title":"__str__()"},{"location":"reference/pytermgui/exceptions/#pytermgui.exceptions.ParserSyntaxError.escape_message","text":"Return message with markup tags escaped. Source code in pytermgui/exceptions.py 72 73 74 75 76 def escape_message ( self ) -> str : \"\"\"Return message with markup tags escaped.\"\"\" char = self . _delimiters [ 0 ] return self . message . replace ( char , \" \\\\ \" + char )","title":"escape_message()"},{"location":"reference/pytermgui/exceptions/#pytermgui.exceptions.ParserSyntaxError.message","text":"Create message from tag, context and cause. Source code in pytermgui/exceptions.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @property def message ( self ) -> str : \"\"\"Create message from tag, context and cause.\"\"\" msg = f 'Tag \" { self . tag } \" ' if self . context != \"\" : index = self . context . find ( self . tag ) escaped_context = repr ( self . context ) . strip ( \"'\" ) if len ( self . context ) > 50 : escaped_context = ( \"...\" + ascii ( self . context ) . strip ( \"'\" )[ max ( index - 25 , 0 ) : index + 25 ] + \"...\" ) highlighted = escaped_context . replace ( self . tag , \" \\x1b [31m \\x1b [1m\" + self . tag + \" \\x1b [0m\" , 1 ) msg += f 'in string \" { highlighted } \" ' return f \" { msg }{ self . cause } .\"","title":"message()"},{"location":"reference/pytermgui/exceptions/#pytermgui.exceptions.TimeoutException","text":"Bases: Exception Raised when an action has timed out. Source code in pytermgui/exceptions.py 17 18 class TimeoutException ( Exception ): \"\"\"Raised when an action has timed out.\"\"\"","title":"TimeoutException"},{"location":"reference/pytermgui/exceptions/#pytermgui.exceptions.WidthExceededError","text":"Bases: Exception Raised when an element's width is larger than the screen. Source code in pytermgui/exceptions.py 21 22 class WidthExceededError ( Exception ): \"\"\"Raised when an element's width is larger than the screen.\"\"\"","title":"WidthExceededError"},{"location":"reference/pytermgui/exporters/","text":"This module provides various methods and utilities to turn TIM into HTML & SVG. prettify_xml ( xml ) Prettifies some XML. Source code in pytermgui/exporters.py 106 107 108 109 110 111 112 def prettify_xml ( xml : str ) -> str : \"\"\"Prettifies some XML.\"\"\" dom = md . parseString ( xml ) pretty_xml = dom . toprettyxml () return \" \\n \" . join ([ s for s in pretty_xml . splitlines ()[ 1 :] if s . strip () != \"\" ]) to_html ( obj , prefix = None , inline_styles = False , include_background = True , vertical_offset = 0.0 , horizontal_offset = 0.0 , formatter = HTML_FORMAT , joiner = ' \\n ' ) Creates a static HTML representation of the given object. Note that the output HTML will not be very attractive or easy to read. This is because these files probably aren't meant to be read by a human anyways, so file sizes are more important. If you do care about the visual style of the output, you can run it through some prettifiers to get the result you are looking for. Parameters: Name Type Description Default obj Widget | StyledText | str The object to represent. Takes either a Widget or some markup text. required prefix str | None The prefix included in the generated classes, e.g. instead of ptg-0 , you would get ptg-my-prefix-0 . None inline_styles bool If set, styles will be set for each span using the inline style argument, otherwise a full style section is constructed. False include_background bool Whether to include the terminal's background color in the output. True Source code in pytermgui/exporters.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 def to_html ( # pylint: disable=too-many-arguments, too-many-locals obj : Widget | StyledText | str , prefix : str | None = None , inline_styles : bool = False , include_background : bool = True , vertical_offset : float = 0.0 , horizontal_offset : float = 0.0 , formatter : str = HTML_FORMAT , joiner : str = \" \\n \" , ) -> str : \"\"\"Creates a static HTML representation of the given object. Note that the output HTML will not be very attractive or easy to read. This is because these files probably aren't meant to be read by a human anyways, so file sizes are more important. If you do care about the visual style of the output, you can run it through some prettifiers to get the result you are looking for. Args: obj: The object to represent. Takes either a Widget or some markup text. prefix: The prefix included in the generated classes, e.g. instead of `ptg-0`, you would get `ptg-my-prefix-0`. inline_styles: If set, styles will be set for each span using the inline `style` argument, otherwise a full style section is constructed. include_background: Whether to include the terminal's background color in the output. \"\"\" document_styles : list [ list [ str ]] = [] if isinstance ( obj , Widget ): data = obj . get_lines () elif isinstance ( obj , str ): data = obj . splitlines () else : data = str ( obj ) . splitlines () lines = [] for dataline in data : line = \"\" for span , styles in _get_spans ( dataline , vertical_offset , horizontal_offset , include_background ): index = _generate_index_in ( document_styles , styles ) if index == len ( document_styles ): document_styles . append ( styles ) if inline_styles : stylesheet = \";\" . join ( styles ) line += span . format ( f \" styles=' { stylesheet } '\" ) else : line += span . format ( \" class='\" + _get_cls ( prefix , index ) + \"'\" ) # Close any previously not closed divs line += \"</div>\" * ( line . count ( \"<div\" ) - line . count ( \"</div\" )) lines . append ( line ) stylesheet = \"\" if not inline_styles : stylesheet = _generate_stylesheet ( document_styles , prefix ) document = formatter . format ( foreground = Color . get_default_foreground () . hex , background = Color . get_default_background () . hex if include_background else \"\" , content = joiner . join ( lines ), styles = stylesheet , font_size = FONT_SIZE , ) return document to_svg ( obj , prefix = None , chrome = True , inline_styles = False , title = 'PyTermGUI' , formatter = SVG_FORMAT ) Creates an SVG screenshot of the given object. This screenshot tries to mimick what the Kitty terminal looks like on MacOS, complete with the menu buttons and drop shadow. The title argument will be displayed in the window's top bar. Parameters: Name Type Description Default obj Widget | StyledText | str The object to represent. Takes either a Widget or some markup text. required prefix str | None The prefix included in the generated classes, e.g. instead of ptg-0 , you would get ptg-my-prefix-0 . None chrome bool Sets the visibility of the window \"chrome\", e.g. the part of the SVG that mimicks the outside border of a terminal. True inline_styles bool If set, styles will be set for each span using the inline style argument, otherwise a full style section is constructed. False title str A string to display in the top bar of the fake terminal. 'PyTermGUI' formatter str The formatting string to use. Inspect pytermgui.exporters.SVG_FORMAT to see all of its arguments. SVG_FORMAT Source code in pytermgui/exporters.py 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 def to_svg ( # pylint: disable=too-many-locals, too-many-arguments, too-many-statements obj : Widget | StyledText | str , prefix : str | None = None , chrome : bool = True , inline_styles : bool = False , title : str = \"PyTermGUI\" , formatter : str = SVG_FORMAT , ) -> str : \"\"\"Creates an SVG screenshot of the given object. This screenshot tries to mimick what the Kitty terminal looks like on MacOS, complete with the menu buttons and drop shadow. The `title` argument will be displayed in the window's top bar. Args: obj: The object to represent. Takes either a Widget or some markup text. prefix: The prefix included in the generated classes, e.g. instead of `ptg-0`, you would get `ptg-my-prefix-0`. chrome: Sets the visibility of the window \"chrome\", e.g. the part of the SVG that mimicks the outside border of a terminal. inline_styles: If set, styles will be set for each span using the inline `style` argument, otherwise a full style section is constructed. title: A string to display in the top bar of the fake terminal. formatter: The formatting string to use. Inspect `pytermgui.exporters.SVG_FORMAT` to see all of its arguments. \"\"\" def _is_block ( text : str ) -> bool : \"\"\"Determines whether the given text only contains block characters. These characters reside in the unicode range of 9600-9631, which is what we test against. \"\"\" return all ( 9600 <= ord ( char ) <= 9631 for char in text ) prefix = prefix if prefix is not None else \"ptg\" terminal = get_terminal () default_fore = Color . get_default_foreground () . hex default_back = Color . get_default_background () . hex text = \"\" lines = 1 cursor_x = cursor_y = 0.0 document_styles : list [ list [ str ]] = [] # We manually set all text to have an alignment-baseline of # text-after-edge to avoid block characters rendering in the # wrong place (not at the top of their \"box\"), but with that # our background rects will be rendered in the wrong place too, # so this is used to offset that. baseline_offset = 0.17 * FONT_HEIGHT if isinstance ( obj , Widget ): obj = \" \\n \" . join ( obj . get_lines ()) elif isinstance ( obj , StyledText ): obj = str ( obj ) for plain in tim . group_styles ( obj ): should_newline = False pos , back , styles = _handle_tokens_svg ( plain , default_fore , default_back ) index = _generate_index_in ( document_styles , styles ) if index == len ( document_styles ): document_styles . append ( styles ) style_attr = ( f \"class=' { prefix } ' style=' { ';' . join ( styles ) } '\" if inline_styles else f \"class=' { prefix } { _get_cls ( prefix , index ) } '\" ) # Manual positioning if pos is not None : cursor_x = pos [ 0 ] * FONT_WIDTH - 10 cursor_y = pos [ 1 ] * FONT_HEIGHT - 15 for line in plain . plain . splitlines (): text_len = len ( line ) * FONT_WIDTH if should_newline : cursor_y += FONT_HEIGHT cursor_x = 0 lines += 1 if lines > terminal . height : break text += _make_tag ( \"rect\" , x = cursor_x , y = cursor_y - ( baseline_offset if not _is_block ( line ) else 0 ), fill = back or default_back , width = round ( text_len * 1.02 , 4 ), height = round ( FONT_HEIGHT * 1.08 , 4 ), ) text += _make_tag ( \"text\" , _escape_text ( line ), dy = \"-0.25em\" , x = cursor_x , y = cursor_y + FONT_SIZE , textLength = text_len , raw = style_attr , ) cursor_x += text_len should_newline = True if lines > terminal . height : break if plain . plain . endswith ( \" \\n \" ): cursor_y += FONT_HEIGHT cursor_x = 0 lines += 1 stylesheet = \"\" if inline_styles else _generate_stylesheet ( document_styles , prefix ) terminal_width = round ( terminal . width * FONT_WIDTH + 2 * TEXT_MARGIN_LEFT , 4 ) terminal_height = round ( terminal . height * FONT_HEIGHT + ( 2 if chrome else 1 ) * TEXT_MARGIN_TOP , 4 ) total_width = terminal_width + ( 2 * SVG_MARGIN_LEFT if chrome else 0 ) total_height = terminal_height + ( 2 * SVG_MARGIN_TOP if chrome else 0 ) if chrome : transform = ( f \"translate( { TEXT_MARGIN_LEFT + SVG_MARGIN_LEFT } , \" + f \" { TEXT_MARGIN_TOP + SVG_MARGIN_TOP } )\" ) chrome_part = f \"\"\"<g> <rect x=\" { SVG_MARGIN_LEFT } \" y=\" { SVG_MARGIN_TOP } \" rx=\"9px\" ry=\"9px\" stroke-width=\"1px\" stroke-linejoin=\"round\" width=\" { terminal_width } \" height=\" { terminal_height } \" fill=\" { default_back } \" /> <circle cx=\" { SVG_MARGIN_LEFT + 15 } \" cy=\" { SVG_MARGIN_TOP + 15 } \" r=\"6\" fill=\"#ff6159\"/> <circle cx=\" { SVG_MARGIN_LEFT + 35 } \" cy=\" { SVG_MARGIN_TOP + 15 } \" r=\"6\" fill=\"#ffbd2e\"/> <circle cx=\" { SVG_MARGIN_LEFT + 55 } \" cy=\" { SVG_MARGIN_TOP + 15 } \" r=\"6\" fill=\"#28c941\"/> <text x=\" { terminal_width // 2 } \" y=\" { SVG_MARGIN_TOP + FONT_HEIGHT } \" text-anchor=\"middle\" class=\" { prefix } -title\"> { title } </text> </g> \"\"\" else : transform = \"translate(16, 16)\" chrome_part = f \"\"\"<rect width=\" { total_width } \" height=\" { total_height } \" fill=\" { default_back } \" />\"\"\" output = _make_tag ( \"g\" , text , transform = transform ) + \" \\n \" return prettify_xml ( formatter . format ( # Dimensions total_width = round ( total_width , 4 ), total_height = round ( total_height , 4 ), terminal_width = terminal_width * 1.02 , terminal_height = terminal_height - 15 , # Styles background = default_back , stylesheet = stylesheet , # Code code = output , prefix = prefix , chrome = chrome_part , ) ) token_to_css ( token , invert = False ) Finds the CSS representation of a token. Parameters: Name Type Description Default token Token The token to represent. required invert bool If set, the role of background & foreground colors are flipped. False Source code in pytermgui/exporters.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 def token_to_css ( token : Token , invert : bool = False ) -> str : \"\"\"Finds the CSS representation of a token. Args: token: The token to represent. invert: If set, the role of background & foreground colors are flipped. \"\"\" if Token . is_color ( token ): color = token . color style = \"color:\" + color . hex if invert : color . background = not color . background if color . background : style = \"background-\" + style return style if token . is_style () and token . value in _STYLE_TO_CSS : return _STYLE_TO_CSS [ token . value ] return \"\"","title":"exporters"},{"location":"reference/pytermgui/exporters/#pytermgui.exporters.prettify_xml","text":"Prettifies some XML. Source code in pytermgui/exporters.py 106 107 108 109 110 111 112 def prettify_xml ( xml : str ) -> str : \"\"\"Prettifies some XML.\"\"\" dom = md . parseString ( xml ) pretty_xml = dom . toprettyxml () return \" \\n \" . join ([ s for s in pretty_xml . splitlines ()[ 1 :] if s . strip () != \"\" ])","title":"prettify_xml()"},{"location":"reference/pytermgui/exporters/#pytermgui.exporters.to_html","text":"Creates a static HTML representation of the given object. Note that the output HTML will not be very attractive or easy to read. This is because these files probably aren't meant to be read by a human anyways, so file sizes are more important. If you do care about the visual style of the output, you can run it through some prettifiers to get the result you are looking for. Parameters: Name Type Description Default obj Widget | StyledText | str The object to represent. Takes either a Widget or some markup text. required prefix str | None The prefix included in the generated classes, e.g. instead of ptg-0 , you would get ptg-my-prefix-0 . None inline_styles bool If set, styles will be set for each span using the inline style argument, otherwise a full style section is constructed. False include_background bool Whether to include the terminal's background color in the output. True Source code in pytermgui/exporters.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 def to_html ( # pylint: disable=too-many-arguments, too-many-locals obj : Widget | StyledText | str , prefix : str | None = None , inline_styles : bool = False , include_background : bool = True , vertical_offset : float = 0.0 , horizontal_offset : float = 0.0 , formatter : str = HTML_FORMAT , joiner : str = \" \\n \" , ) -> str : \"\"\"Creates a static HTML representation of the given object. Note that the output HTML will not be very attractive or easy to read. This is because these files probably aren't meant to be read by a human anyways, so file sizes are more important. If you do care about the visual style of the output, you can run it through some prettifiers to get the result you are looking for. Args: obj: The object to represent. Takes either a Widget or some markup text. prefix: The prefix included in the generated classes, e.g. instead of `ptg-0`, you would get `ptg-my-prefix-0`. inline_styles: If set, styles will be set for each span using the inline `style` argument, otherwise a full style section is constructed. include_background: Whether to include the terminal's background color in the output. \"\"\" document_styles : list [ list [ str ]] = [] if isinstance ( obj , Widget ): data = obj . get_lines () elif isinstance ( obj , str ): data = obj . splitlines () else : data = str ( obj ) . splitlines () lines = [] for dataline in data : line = \"\" for span , styles in _get_spans ( dataline , vertical_offset , horizontal_offset , include_background ): index = _generate_index_in ( document_styles , styles ) if index == len ( document_styles ): document_styles . append ( styles ) if inline_styles : stylesheet = \";\" . join ( styles ) line += span . format ( f \" styles=' { stylesheet } '\" ) else : line += span . format ( \" class='\" + _get_cls ( prefix , index ) + \"'\" ) # Close any previously not closed divs line += \"</div>\" * ( line . count ( \"<div\" ) - line . count ( \"</div\" )) lines . append ( line ) stylesheet = \"\" if not inline_styles : stylesheet = _generate_stylesheet ( document_styles , prefix ) document = formatter . format ( foreground = Color . get_default_foreground () . hex , background = Color . get_default_background () . hex if include_background else \"\" , content = joiner . join ( lines ), styles = stylesheet , font_size = FONT_SIZE , ) return document","title":"to_html()"},{"location":"reference/pytermgui/exporters/#pytermgui.exporters.to_svg","text":"Creates an SVG screenshot of the given object. This screenshot tries to mimick what the Kitty terminal looks like on MacOS, complete with the menu buttons and drop shadow. The title argument will be displayed in the window's top bar. Parameters: Name Type Description Default obj Widget | StyledText | str The object to represent. Takes either a Widget or some markup text. required prefix str | None The prefix included in the generated classes, e.g. instead of ptg-0 , you would get ptg-my-prefix-0 . None chrome bool Sets the visibility of the window \"chrome\", e.g. the part of the SVG that mimicks the outside border of a terminal. True inline_styles bool If set, styles will be set for each span using the inline style argument, otherwise a full style section is constructed. False title str A string to display in the top bar of the fake terminal. 'PyTermGUI' formatter str The formatting string to use. Inspect pytermgui.exporters.SVG_FORMAT to see all of its arguments. SVG_FORMAT Source code in pytermgui/exporters.py 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 def to_svg ( # pylint: disable=too-many-locals, too-many-arguments, too-many-statements obj : Widget | StyledText | str , prefix : str | None = None , chrome : bool = True , inline_styles : bool = False , title : str = \"PyTermGUI\" , formatter : str = SVG_FORMAT , ) -> str : \"\"\"Creates an SVG screenshot of the given object. This screenshot tries to mimick what the Kitty terminal looks like on MacOS, complete with the menu buttons and drop shadow. The `title` argument will be displayed in the window's top bar. Args: obj: The object to represent. Takes either a Widget or some markup text. prefix: The prefix included in the generated classes, e.g. instead of `ptg-0`, you would get `ptg-my-prefix-0`. chrome: Sets the visibility of the window \"chrome\", e.g. the part of the SVG that mimicks the outside border of a terminal. inline_styles: If set, styles will be set for each span using the inline `style` argument, otherwise a full style section is constructed. title: A string to display in the top bar of the fake terminal. formatter: The formatting string to use. Inspect `pytermgui.exporters.SVG_FORMAT` to see all of its arguments. \"\"\" def _is_block ( text : str ) -> bool : \"\"\"Determines whether the given text only contains block characters. These characters reside in the unicode range of 9600-9631, which is what we test against. \"\"\" return all ( 9600 <= ord ( char ) <= 9631 for char in text ) prefix = prefix if prefix is not None else \"ptg\" terminal = get_terminal () default_fore = Color . get_default_foreground () . hex default_back = Color . get_default_background () . hex text = \"\" lines = 1 cursor_x = cursor_y = 0.0 document_styles : list [ list [ str ]] = [] # We manually set all text to have an alignment-baseline of # text-after-edge to avoid block characters rendering in the # wrong place (not at the top of their \"box\"), but with that # our background rects will be rendered in the wrong place too, # so this is used to offset that. baseline_offset = 0.17 * FONT_HEIGHT if isinstance ( obj , Widget ): obj = \" \\n \" . join ( obj . get_lines ()) elif isinstance ( obj , StyledText ): obj = str ( obj ) for plain in tim . group_styles ( obj ): should_newline = False pos , back , styles = _handle_tokens_svg ( plain , default_fore , default_back ) index = _generate_index_in ( document_styles , styles ) if index == len ( document_styles ): document_styles . append ( styles ) style_attr = ( f \"class=' { prefix } ' style=' { ';' . join ( styles ) } '\" if inline_styles else f \"class=' { prefix } { _get_cls ( prefix , index ) } '\" ) # Manual positioning if pos is not None : cursor_x = pos [ 0 ] * FONT_WIDTH - 10 cursor_y = pos [ 1 ] * FONT_HEIGHT - 15 for line in plain . plain . splitlines (): text_len = len ( line ) * FONT_WIDTH if should_newline : cursor_y += FONT_HEIGHT cursor_x = 0 lines += 1 if lines > terminal . height : break text += _make_tag ( \"rect\" , x = cursor_x , y = cursor_y - ( baseline_offset if not _is_block ( line ) else 0 ), fill = back or default_back , width = round ( text_len * 1.02 , 4 ), height = round ( FONT_HEIGHT * 1.08 , 4 ), ) text += _make_tag ( \"text\" , _escape_text ( line ), dy = \"-0.25em\" , x = cursor_x , y = cursor_y + FONT_SIZE , textLength = text_len , raw = style_attr , ) cursor_x += text_len should_newline = True if lines > terminal . height : break if plain . plain . endswith ( \" \\n \" ): cursor_y += FONT_HEIGHT cursor_x = 0 lines += 1 stylesheet = \"\" if inline_styles else _generate_stylesheet ( document_styles , prefix ) terminal_width = round ( terminal . width * FONT_WIDTH + 2 * TEXT_MARGIN_LEFT , 4 ) terminal_height = round ( terminal . height * FONT_HEIGHT + ( 2 if chrome else 1 ) * TEXT_MARGIN_TOP , 4 ) total_width = terminal_width + ( 2 * SVG_MARGIN_LEFT if chrome else 0 ) total_height = terminal_height + ( 2 * SVG_MARGIN_TOP if chrome else 0 ) if chrome : transform = ( f \"translate( { TEXT_MARGIN_LEFT + SVG_MARGIN_LEFT } , \" + f \" { TEXT_MARGIN_TOP + SVG_MARGIN_TOP } )\" ) chrome_part = f \"\"\"<g> <rect x=\" { SVG_MARGIN_LEFT } \" y=\" { SVG_MARGIN_TOP } \" rx=\"9px\" ry=\"9px\" stroke-width=\"1px\" stroke-linejoin=\"round\" width=\" { terminal_width } \" height=\" { terminal_height } \" fill=\" { default_back } \" /> <circle cx=\" { SVG_MARGIN_LEFT + 15 } \" cy=\" { SVG_MARGIN_TOP + 15 } \" r=\"6\" fill=\"#ff6159\"/> <circle cx=\" { SVG_MARGIN_LEFT + 35 } \" cy=\" { SVG_MARGIN_TOP + 15 } \" r=\"6\" fill=\"#ffbd2e\"/> <circle cx=\" { SVG_MARGIN_LEFT + 55 } \" cy=\" { SVG_MARGIN_TOP + 15 } \" r=\"6\" fill=\"#28c941\"/> <text x=\" { terminal_width // 2 } \" y=\" { SVG_MARGIN_TOP + FONT_HEIGHT } \" text-anchor=\"middle\" class=\" { prefix } -title\"> { title } </text> </g> \"\"\" else : transform = \"translate(16, 16)\" chrome_part = f \"\"\"<rect width=\" { total_width } \" height=\" { total_height } \" fill=\" { default_back } \" />\"\"\" output = _make_tag ( \"g\" , text , transform = transform ) + \" \\n \" return prettify_xml ( formatter . format ( # Dimensions total_width = round ( total_width , 4 ), total_height = round ( total_height , 4 ), terminal_width = terminal_width * 1.02 , terminal_height = terminal_height - 15 , # Styles background = default_back , stylesheet = stylesheet , # Code code = output , prefix = prefix , chrome = chrome_part , ) )","title":"to_svg()"},{"location":"reference/pytermgui/exporters/#pytermgui.exporters.token_to_css","text":"Finds the CSS representation of a token. Parameters: Name Type Description Default token Token The token to represent. required invert bool If set, the role of background & foreground colors are flipped. False Source code in pytermgui/exporters.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 def token_to_css ( token : Token , invert : bool = False ) -> str : \"\"\"Finds the CSS representation of a token. Args: token: The token to represent. invert: If set, the role of background & foreground colors are flipped. \"\"\" if Token . is_color ( token ): color = token . color style = \"color:\" + color . hex if invert : color . background = not color . background if color . background : style = \"background-\" + style return style if token . is_style () and token . value in _STYLE_TO_CSS : return _STYLE_TO_CSS [ token . value ] return \"\"","title":"token_to_css()"},{"location":"reference/pytermgui/fancy_repr/","text":"The __fancy_repl__ protocol. SupportsFancyRepr Bases: Protocol An object that supports the __fancy_repr__ dunder. Source code in pytermgui/fancy_repr.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class SupportsFancyRepr ( Protocol ): # pylint: disable=too-few-public-methods \"\"\"An object that supports the `__fancy_repr__` dunder.\"\"\" def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Yields some fancy text. Each value yielded can be one of two types. If a dictionary is yielded, it will be assumed to have `text` and `highlight` fields. `text` will be the string included in the repr, and `highlight` will be a boolean describing whether the part should be highlighted. At the moment highlighting is done by `highlight_python`, but this might be configurable once more highlighters are available. If a `str` is yielded, it is assumed to be a shorthand for: {\"text\": <your_text>, \"highlight\": True} \"\"\" __fancy_repr__ () Yields some fancy text. Each value yielded can be one of two types. If a dictionary is yielded, it will be assumed to have text and highlight fields. text will be the string included in the repr, and highlight will be a boolean describing whether the part should be highlighted. At the moment highlighting is done by highlight_python , but this might be configurable once more highlighters are available. If a str is yielded, it is assumed to be a shorthand for: {\"text\": <your_text>, \"highlight\": True} Source code in pytermgui/fancy_repr.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Yields some fancy text. Each value yielded can be one of two types. If a dictionary is yielded, it will be assumed to have `text` and `highlight` fields. `text` will be the string included in the repr, and `highlight` will be a boolean describing whether the part should be highlighted. At the moment highlighting is done by `highlight_python`, but this might be configurable once more highlighters are available. If a `str` is yielded, it is assumed to be a shorthand for: {\"text\": <your_text>, \"highlight\": True} \"\"\" build_fancy_repr ( obj ) Interprets objects with the __fancy_repr__ protocol. Source code in pytermgui/fancy_repr.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def build_fancy_repr ( obj : SupportsFancyRepr ) -> str : \"\"\"Interprets objects with the `__fancy_repr__` protocol.\"\"\" output = \"\" for item in obj . __fancy_repr__ (): if isinstance ( item , str ): output += highlight_python ( item ) continue text = item [ \"text\" ] assert isinstance ( text , str ) highlight = item [ \"highlight\" ] if highlight : text = highlight_python ( text ) output += text return output supports_fancy_repr ( obj ) Determines whether the given object supports the fancy repl protocol. Source code in pytermgui/fancy_repr.py 37 38 39 40 def supports_fancy_repr ( obj : object ) -> bool : \"\"\"Determines whether the given object supports the fancy repl protocol.\"\"\" return hasattr ( obj , \"__fancy_repr__\" ) and not isinstance ( obj , type )","title":"fancy_repr"},{"location":"reference/pytermgui/fancy_repr/#pytermgui.fancy_repr.SupportsFancyRepr","text":"Bases: Protocol An object that supports the __fancy_repr__ dunder. Source code in pytermgui/fancy_repr.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class SupportsFancyRepr ( Protocol ): # pylint: disable=too-few-public-methods \"\"\"An object that supports the `__fancy_repr__` dunder.\"\"\" def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Yields some fancy text. Each value yielded can be one of two types. If a dictionary is yielded, it will be assumed to have `text` and `highlight` fields. `text` will be the string included in the repr, and `highlight` will be a boolean describing whether the part should be highlighted. At the moment highlighting is done by `highlight_python`, but this might be configurable once more highlighters are available. If a `str` is yielded, it is assumed to be a shorthand for: {\"text\": <your_text>, \"highlight\": True} \"\"\"","title":"SupportsFancyRepr"},{"location":"reference/pytermgui/fancy_repr/#pytermgui.fancy_repr.SupportsFancyRepr.__fancy_repr__","text":"Yields some fancy text. Each value yielded can be one of two types. If a dictionary is yielded, it will be assumed to have text and highlight fields. text will be the string included in the repr, and highlight will be a boolean describing whether the part should be highlighted. At the moment highlighting is done by highlight_python , but this might be configurable once more highlighters are available. If a str is yielded, it is assumed to be a shorthand for: {\"text\": <your_text>, \"highlight\": True} Source code in pytermgui/fancy_repr.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Yields some fancy text. Each value yielded can be one of two types. If a dictionary is yielded, it will be assumed to have `text` and `highlight` fields. `text` will be the string included in the repr, and `highlight` will be a boolean describing whether the part should be highlighted. At the moment highlighting is done by `highlight_python`, but this might be configurable once more highlighters are available. If a `str` is yielded, it is assumed to be a shorthand for: {\"text\": <your_text>, \"highlight\": True} \"\"\"","title":"__fancy_repr__()"},{"location":"reference/pytermgui/fancy_repr/#pytermgui.fancy_repr.build_fancy_repr","text":"Interprets objects with the __fancy_repr__ protocol. Source code in pytermgui/fancy_repr.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def build_fancy_repr ( obj : SupportsFancyRepr ) -> str : \"\"\"Interprets objects with the `__fancy_repr__` protocol.\"\"\" output = \"\" for item in obj . __fancy_repr__ (): if isinstance ( item , str ): output += highlight_python ( item ) continue text = item [ \"text\" ] assert isinstance ( text , str ) highlight = item [ \"highlight\" ] if highlight : text = highlight_python ( text ) output += text return output","title":"build_fancy_repr()"},{"location":"reference/pytermgui/fancy_repr/#pytermgui.fancy_repr.supports_fancy_repr","text":"Determines whether the given object supports the fancy repl protocol. Source code in pytermgui/fancy_repr.py 37 38 39 40 def supports_fancy_repr ( obj : object ) -> bool : \"\"\"Determines whether the given object supports the fancy repl protocol.\"\"\" return hasattr ( obj , \"__fancy_repr__\" ) and not isinstance ( obj , type )","title":"supports_fancy_repr()"},{"location":"reference/pytermgui/file_loaders/","text":"Description This module provides the library with the capability to load files into Widget-s. It provides a FileLoader base class, which is then subclassed by various filetype- specific parsers with their own parse method. The job of this method is to take the file contents as a string, and create a valid json tree out of it. You can \"run\" a PTG YAML file by calling ptg -f <filename> in your terminal. To use any YAML related features, the optional dependency PyYAML is required. Implementation details The main method of these classes is load , which takes a file-like object or a string, parses it and returns a WidgetNamespace instance. This can then be used to access all custom Widget definitions in the datafile. This module highly depends on the serializer module. Each file loader uses its own Serializer instance, but optionally take a pre-instantiated Serializer at construction. As with that module, this one depends on it \"knowing\" all types of Widget-s you are loading. If you have custom Widget subclass you would like to use in file-based definitions, use the FileLoader.register method, passing in your custom class as the sole argument. File structure Regardless of filetype, all loaded files must follow a specific structure: root |- config | |_ custom global widget configuration | |- markup | |_ custom markup definitions | |- boxes | |_ custom box definitions | |_ widgets |_ custom widget definitions The loading follows the order config -> markup -> boxes -> widgets. It is not necessary to provide all sections. Example of usage # -- data.yaml -- markup : label-style : '141 @61 bold' boxes : WINDOW_BOX : [ \"left --- right\" , \"left x right\" , \"left --- right\" , ] config : Window : styles : border : '[@79]{item}' box : SINGLE Label : styles : value : '[label-style]{item}' widgets : MyWindow : type : Window box : WINDOW_BOX widgets : Label : value : '[210 bold]This is a title' Label : {} Splitter : widgets : - Label : parent_align : 0 value : 'This is an option' - Button : label : \"Press me!\" Label : {} Label : value : '[label-style]{item}' # -- loader.py -- import pytermgui as ptg with ptg . YamlLoader () as loader , open ( \"data.yaml\" , \"r\" ) as datafile : namespace = loader . load ( datafile ) with ptg . WindowManager () as manager : manager . add ( namespace . MyWindow ) manager . run () # Alternatively, one could run `ptg -f \"data.yaml\"` to display all widgets defined. # See `ptg -h`. FileLoader Bases: ABC Base class for file loader objects. These allow users to load pytermgui content from a specific filetype, with each filetype having their own loaders. To use custom widgets with children of this class, you need to call FileLoader.register . Source code in pytermgui/file_loaders.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 class FileLoader ( ABC ): \"\"\"Base class for file loader objects. These allow users to load pytermgui content from a specific filetype, with each filetype having their own loaders. To use custom widgets with children of this class, you need to call `FileLoader.register`.\"\"\" serializer : Serializer \"\"\"Object-specific serializer instance. In order to use a specific, already created instance you need to pass it on `FileLoader` construction.\"\"\" @abstractmethod def parse ( self , data : str ) -> dict [ Any , Any ]: \"\"\"Parses string into a dictionary used by `pytermgui.serializer.Serializer`. This dictionary follows the structure defined above. \"\"\" def __init__ ( self , serializer : Serializer | None = None ) -> None : \"\"\"Initialize FileLoader. Args: serializer: An optional `pytermgui.serializer.Serializer` instance. If not provided, one is instantiated for every FileLoader instance. \"\"\" if serializer is None : serializer = Serializer () self . serializer = serializer def __enter__ ( self ) -> FileLoader : \"\"\"Starts context manager.\"\"\" return self def __exit__ ( self , _ : Any , exception : Exception , __ : Any ) -> bool : \"\"\"Ends context manager.\"\"\" if exception is not None : raise exception def register ( self , cls : Type [ widgets_m . Widget ]) -> None : \"\"\"Registers a widget to the serializer. Args: cls: The widget type to register. \"\"\" self . serializer . register ( cls ) def bind ( self , name : str , method : Callable [ ... , Any ]) -> None : \"\"\"Binds a name to a method. Args: name: The name of the method, as referenced in the loaded files. method: The callable to bind. \"\"\" self . serializer . bind ( name , method ) def load_str ( self , data : str ) -> WidgetNamespace : \"\"\"Creates a `WidgetNamespace` from string data. To parse the data, we use `FileLoader.parse`. To implement custom formats, subclass `FileLoader` with your own `parse` implementation. Args: data: The data to parse. Returns: A WidgetNamespace created from the provided data. \"\"\" parsed = self . parse ( data ) # Get & load config data config_data = parsed . get ( \"config\" ) if config_data is not None : namespace = WidgetNamespace . from_config ( config_data , loader = self ) else : namespace = WidgetNamespace . from_config ({}, loader = self ) # Create aliases for key , value in ( parsed . get ( \"markup\" ) or {}) . items (): tim . alias ( key , value ) # Create boxes for name , inner in ( parsed . get ( \"boxes\" ) or {}) . items (): self . serializer . register_box ( name , widgets_m . boxes . Box ( inner )) # Create widgets for name , inner in ( parsed . get ( \"widgets\" ) or {}) . items (): widget_type = inner . get ( \"type\" ) or name box_name = inner . get ( \"box\" ) box = None if box_name is not None and box_name in namespace . boxes : box = namespace . boxes [ box_name ] del inner [ \"box\" ] try : namespace . widgets [ name ] = self . serializer . from_dict ( inner , widget_type = widget_type ) except AttributeError as error : raise ValueError ( f 'Could not load \" { name } \" from data: \\n { json . dumps ( inner , indent = 2 ) } ' ) from error if box is not None : namespace . widgets [ name ] . box = box return namespace def load ( self , data : str | IO ) -> WidgetNamespace : \"\"\"Loads data from a string or a file. When an IO object is passed, its data is extracted as a string. This string can then be passed to `load_str`. Args: data: Either a string or file stream to load data from. Returns: A WidgetNamespace with the data loaded. \"\"\" if not isinstance ( data , str ): data = data . read () assert isinstance ( data , str ) return self . load_str ( data ) __enter__ () Starts context manager. Source code in pytermgui/file_loaders.py 287 288 289 290 def __enter__ ( self ) -> FileLoader : \"\"\"Starts context manager.\"\"\" return self __exit__ ( _ , exception , __ ) Ends context manager. Source code in pytermgui/file_loaders.py 292 293 294 295 296 def __exit__ ( self , _ : Any , exception : Exception , __ : Any ) -> bool : \"\"\"Ends context manager.\"\"\" if exception is not None : raise exception __init__ ( serializer = None ) Initialize FileLoader. Parameters: Name Type Description Default serializer Serializer | None An optional pytermgui.serializer.Serializer instance. If not provided, one is instantiated for every FileLoader instance. None Source code in pytermgui/file_loaders.py 274 275 276 277 278 279 280 281 282 283 284 285 def __init__ ( self , serializer : Serializer | None = None ) -> None : \"\"\"Initialize FileLoader. Args: serializer: An optional `pytermgui.serializer.Serializer` instance. If not provided, one is instantiated for every FileLoader instance. \"\"\" if serializer is None : serializer = Serializer () self . serializer = serializer bind ( name , method ) Binds a name to a method. Parameters: Name Type Description Default name str The name of the method, as referenced in the loaded files. required method Callable [..., Any ] The callable to bind. required Source code in pytermgui/file_loaders.py 307 308 309 310 311 312 313 314 315 316 def bind ( self , name : str , method : Callable [ ... , Any ]) -> None : \"\"\"Binds a name to a method. Args: name: The name of the method, as referenced in the loaded files. method: The callable to bind. \"\"\" self . serializer . bind ( name , method ) load ( data ) Loads data from a string or a file. When an IO object is passed, its data is extracted as a string. This string can then be passed to load_str . Parameters: Name Type Description Default data str | IO Either a string or file stream to load data from. required Returns: Type Description WidgetNamespace A WidgetNamespace with the data loaded. Source code in pytermgui/file_loaders.py 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def load ( self , data : str | IO ) -> WidgetNamespace : \"\"\"Loads data from a string or a file. When an IO object is passed, its data is extracted as a string. This string can then be passed to `load_str`. Args: data: Either a string or file stream to load data from. Returns: A WidgetNamespace with the data loaded. \"\"\" if not isinstance ( data , str ): data = data . read () assert isinstance ( data , str ) return self . load_str ( data ) load_str ( data ) Creates a WidgetNamespace from string data. To parse the data, we use FileLoader.parse . To implement custom formats, subclass FileLoader with your own parse implementation. Parameters: Name Type Description Default data str The data to parse. required Returns: Type Description WidgetNamespace A WidgetNamespace created from the provided data. Source code in pytermgui/file_loaders.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 def load_str ( self , data : str ) -> WidgetNamespace : \"\"\"Creates a `WidgetNamespace` from string data. To parse the data, we use `FileLoader.parse`. To implement custom formats, subclass `FileLoader` with your own `parse` implementation. Args: data: The data to parse. Returns: A WidgetNamespace created from the provided data. \"\"\" parsed = self . parse ( data ) # Get & load config data config_data = parsed . get ( \"config\" ) if config_data is not None : namespace = WidgetNamespace . from_config ( config_data , loader = self ) else : namespace = WidgetNamespace . from_config ({}, loader = self ) # Create aliases for key , value in ( parsed . get ( \"markup\" ) or {}) . items (): tim . alias ( key , value ) # Create boxes for name , inner in ( parsed . get ( \"boxes\" ) or {}) . items (): self . serializer . register_box ( name , widgets_m . boxes . Box ( inner )) # Create widgets for name , inner in ( parsed . get ( \"widgets\" ) or {}) . items (): widget_type = inner . get ( \"type\" ) or name box_name = inner . get ( \"box\" ) box = None if box_name is not None and box_name in namespace . boxes : box = namespace . boxes [ box_name ] del inner [ \"box\" ] try : namespace . widgets [ name ] = self . serializer . from_dict ( inner , widget_type = widget_type ) except AttributeError as error : raise ValueError ( f 'Could not load \" { name } \" from data: \\n { json . dumps ( inner , indent = 2 ) } ' ) from error if box is not None : namespace . widgets [ name ] . box = box return namespace parse ( data ) abstractmethod Parses string into a dictionary used by pytermgui.serializer.Serializer . This dictionary follows the structure defined above. Source code in pytermgui/file_loaders.py 267 268 269 270 271 272 @abstractmethod def parse ( self , data : str ) -> dict [ Any , Any ]: \"\"\"Parses string into a dictionary used by `pytermgui.serializer.Serializer`. This dictionary follows the structure defined above. \"\"\" register ( cls ) Registers a widget to the serializer. Parameters: Name Type Description Default cls Type [ widgets_m . Widget ] The widget type to register. required Source code in pytermgui/file_loaders.py 298 299 300 301 302 303 304 305 def register ( self , cls : Type [ widgets_m . Widget ]) -> None : \"\"\"Registers a widget to the serializer. Args: cls: The widget type to register. \"\"\" self . serializer . register ( cls ) JsonLoader Bases: FileLoader JSON specific loader subclass. Source code in pytermgui/file_loaders.py 393 394 395 396 397 398 399 400 401 402 403 404 405 406 class JsonLoader ( FileLoader ): \"\"\"JSON specific loader subclass.\"\"\" def parse ( self , data : str ) -> dict [ Any , Any ]: \"\"\"Parse JSON str. Args: data: JSON formatted string. Returns: Loadable dictionary. \"\"\" return json . loads ( data ) parse ( data ) Parse JSON str. Parameters: Name Type Description Default data str JSON formatted string. required Returns: Type Description dict [ Any , Any ] Loadable dictionary. Source code in pytermgui/file_loaders.py 396 397 398 399 400 401 402 403 404 405 406 def parse ( self , data : str ) -> dict [ Any , Any ]: \"\"\"Parse JSON str. Args: data: JSON formatted string. Returns: Loadable dictionary. \"\"\" return json . loads ( data ) WidgetNamespace dataclass Class to hold data on loaded namespace. Source code in pytermgui/file_loaders.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 @dataclass class WidgetNamespace : \"\"\"Class to hold data on loaded namespace.\"\"\" # No clue why `widgets` is seen as undefined here, # but not in the code below. It only seems to happen # in certain pylint configs as well. config : dict [ Type [ widgets_m . Widget ], dict [ str , Any ] # pylint: disable=undefined-variable ] widgets : dict [ str , widgets_m . Widget ] boxes : dict [ str , widgets_m . boxes . Box ] = field ( default_factory = dict ) @classmethod def from_config ( cls , data : dict [ Any , Any ], loader : FileLoader ) -> WidgetNamespace : \"\"\"Creates a namespace from config data. Args: data: A dictionary of config data. loader: The `FileLoader` instance that should be used. Returns: A new WidgetNamespace with the given config. \"\"\" namespace = WidgetNamespace ({}, {}) for name , config in data . items (): obj = loader . serializer . known_widgets . get ( name ) if obj is None : raise KeyError ( f \"Unknown widget type { name } .\" ) namespace . config [ obj ] = { \"styles\" : obj . styles , \"chars\" : obj . chars . copy (), } for category , inner in config . items (): value : str | widgets_m . styles . MarkupFormatter if category not in namespace . config [ obj ]: setattr ( obj , category , inner ) continue for key , value in inner . items (): namespace . config [ obj ][ category ][ key ] = value namespace . apply_config () return namespace @staticmethod def _apply_section ( widget : Type [ widgets_m . Widget ], title : str , section : dict [ str , str ] ) -> None : \"\"\"Applies configuration section to the widget.\"\"\" for key , value in section . items (): if title == \"styles\" : widget . set_style ( key , value ) continue widget . set_char ( key , value ) def apply_to ( self , widget : widgets_m . Widget ) -> None : \"\"\"Applies namespace config to the widget. Args: widget: The widget in question. \"\"\" def _apply_sections ( data : dict [ str , dict [ str , str ]], widget : widgets_m . Widget ) -> None : \"\"\"Applies sections from data to the widget.\"\"\" for title , section in data . items (): self . _apply_section ( type ( widget ), title , section ) data = self . config . get ( type ( widget )) if data is None : return _apply_sections ( data , widget ) if hasattr ( widget , \"_widgets\" ): for inner in widget : inner_section = self . config . get ( type ( inner )) if inner_section is None : continue _apply_sections ( inner_section , inner ) def apply_config ( self ) -> None : \"\"\"Apply self.config to current namespace.\"\"\" for widget , settings in self . config . items (): for title , section in settings . items (): self . _apply_section ( widget , title , section ) def __getattr__ ( self , attr : str ) -> widgets_m . Widget : \"\"\"Get widget by name from widget list.\"\"\" if attr in self . widgets : return self . widgets [ attr ] return self . __dict__ [ attr ] __getattr__ ( attr ) Get widget by name from widget list. Source code in pytermgui/file_loaders.py 246 247 248 249 250 251 252 def __getattr__ ( self , attr : str ) -> widgets_m . Widget : \"\"\"Get widget by name from widget list.\"\"\" if attr in self . widgets : return self . widgets [ attr ] return self . __dict__ [ attr ] apply_config () Apply self.config to current namespace. Source code in pytermgui/file_loaders.py 239 240 241 242 243 244 def apply_config ( self ) -> None : \"\"\"Apply self.config to current namespace.\"\"\" for widget , settings in self . config . items (): for title , section in settings . items (): self . _apply_section ( widget , title , section ) apply_to ( widget ) Applies namespace config to the widget. Parameters: Name Type Description Default widget widgets_m . Widget The widget in question. required Source code in pytermgui/file_loaders.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def apply_to ( self , widget : widgets_m . Widget ) -> None : \"\"\"Applies namespace config to the widget. Args: widget: The widget in question. \"\"\" def _apply_sections ( data : dict [ str , dict [ str , str ]], widget : widgets_m . Widget ) -> None : \"\"\"Applies sections from data to the widget.\"\"\" for title , section in data . items (): self . _apply_section ( type ( widget ), title , section ) data = self . config . get ( type ( widget )) if data is None : return _apply_sections ( data , widget ) if hasattr ( widget , \"_widgets\" ): for inner in widget : inner_section = self . config . get ( type ( inner )) if inner_section is None : continue _apply_sections ( inner_section , inner ) from_config ( data , loader ) classmethod Creates a namespace from config data. Parameters: Name Type Description Default data dict [ Any , Any ] A dictionary of config data. required loader FileLoader The FileLoader instance that should be used. required Returns: Type Description WidgetNamespace A new WidgetNamespace with the given config. Source code in pytermgui/file_loaders.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 @classmethod def from_config ( cls , data : dict [ Any , Any ], loader : FileLoader ) -> WidgetNamespace : \"\"\"Creates a namespace from config data. Args: data: A dictionary of config data. loader: The `FileLoader` instance that should be used. Returns: A new WidgetNamespace with the given config. \"\"\" namespace = WidgetNamespace ({}, {}) for name , config in data . items (): obj = loader . serializer . known_widgets . get ( name ) if obj is None : raise KeyError ( f \"Unknown widget type { name } .\" ) namespace . config [ obj ] = { \"styles\" : obj . styles , \"chars\" : obj . chars . copy (), } for category , inner in config . items (): value : str | widgets_m . styles . MarkupFormatter if category not in namespace . config [ obj ]: setattr ( obj , category , inner ) continue for key , value in inner . items (): namespace . config [ obj ][ category ][ key ] = value namespace . apply_config () return namespace YamlLoader Bases: FileLoader YAML specific loader subclass. Source code in pytermgui/file_loaders.py 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 class YamlLoader ( FileLoader ): \"\"\"YAML specific loader subclass.\"\"\" def __init__ ( self , serializer : Serializer | None = None ) -> None : \"\"\"Initialize object, check for installation of PyYAML.\"\"\" if YAML_ERROR is not None : raise RuntimeError ( \"YAML implementation module not found. Please install `PyYAML` to use `YamlLoader`.\" ) from YAML_ERROR super () . __init__ () def parse ( self , data : str ) -> dict [ Any , Any ]: \"\"\"Parse YAML str. Args: data: YAML formatted string. Returns: Loadable dictionary. \"\"\" assert yaml is not None return yaml . safe_load ( data ) __init__ ( serializer = None ) Initialize object, check for installation of PyYAML. Source code in pytermgui/file_loaders.py 412 413 414 415 416 417 418 419 420 def __init__ ( self , serializer : Serializer | None = None ) -> None : \"\"\"Initialize object, check for installation of PyYAML.\"\"\" if YAML_ERROR is not None : raise RuntimeError ( \"YAML implementation module not found. Please install `PyYAML` to use `YamlLoader`.\" ) from YAML_ERROR super () . __init__ () parse ( data ) Parse YAML str. Parameters: Name Type Description Default data str YAML formatted string. required Returns: Type Description dict [ Any , Any ] Loadable dictionary. Source code in pytermgui/file_loaders.py 422 423 424 425 426 427 428 429 430 431 432 433 def parse ( self , data : str ) -> dict [ Any , Any ]: \"\"\"Parse YAML str. Args: data: YAML formatted string. Returns: Loadable dictionary. \"\"\" assert yaml is not None return yaml . safe_load ( data )","title":"file_loaders"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders--description","text":"This module provides the library with the capability to load files into Widget-s. It provides a FileLoader base class, which is then subclassed by various filetype- specific parsers with their own parse method. The job of this method is to take the file contents as a string, and create a valid json tree out of it. You can \"run\" a PTG YAML file by calling ptg -f <filename> in your terminal. To use any YAML related features, the optional dependency PyYAML is required.","title":"Description"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders--implementation-details","text":"The main method of these classes is load , which takes a file-like object or a string, parses it and returns a WidgetNamespace instance. This can then be used to access all custom Widget definitions in the datafile. This module highly depends on the serializer module. Each file loader uses its own Serializer instance, but optionally take a pre-instantiated Serializer at construction. As with that module, this one depends on it \"knowing\" all types of Widget-s you are loading. If you have custom Widget subclass you would like to use in file-based definitions, use the FileLoader.register method, passing in your custom class as the sole argument.","title":"Implementation details"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders--file-structure","text":"Regardless of filetype, all loaded files must follow a specific structure: root |- config | |_ custom global widget configuration | |- markup | |_ custom markup definitions | |- boxes | |_ custom box definitions | |_ widgets |_ custom widget definitions The loading follows the order config -> markup -> boxes -> widgets. It is not necessary to provide all sections.","title":"File structure"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders--example-of-usage","text":"# -- data.yaml -- markup : label-style : '141 @61 bold' boxes : WINDOW_BOX : [ \"left --- right\" , \"left x right\" , \"left --- right\" , ] config : Window : styles : border : '[@79]{item}' box : SINGLE Label : styles : value : '[label-style]{item}' widgets : MyWindow : type : Window box : WINDOW_BOX widgets : Label : value : '[210 bold]This is a title' Label : {} Splitter : widgets : - Label : parent_align : 0 value : 'This is an option' - Button : label : \"Press me!\" Label : {} Label : value : '[label-style]{item}' # -- loader.py -- import pytermgui as ptg with ptg . YamlLoader () as loader , open ( \"data.yaml\" , \"r\" ) as datafile : namespace = loader . load ( datafile ) with ptg . WindowManager () as manager : manager . add ( namespace . MyWindow ) manager . run () # Alternatively, one could run `ptg -f \"data.yaml\"` to display all widgets defined. # See `ptg -h`.","title":"Example of usage"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.FileLoader","text":"Bases: ABC Base class for file loader objects. These allow users to load pytermgui content from a specific filetype, with each filetype having their own loaders. To use custom widgets with children of this class, you need to call FileLoader.register . Source code in pytermgui/file_loaders.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 class FileLoader ( ABC ): \"\"\"Base class for file loader objects. These allow users to load pytermgui content from a specific filetype, with each filetype having their own loaders. To use custom widgets with children of this class, you need to call `FileLoader.register`.\"\"\" serializer : Serializer \"\"\"Object-specific serializer instance. In order to use a specific, already created instance you need to pass it on `FileLoader` construction.\"\"\" @abstractmethod def parse ( self , data : str ) -> dict [ Any , Any ]: \"\"\"Parses string into a dictionary used by `pytermgui.serializer.Serializer`. This dictionary follows the structure defined above. \"\"\" def __init__ ( self , serializer : Serializer | None = None ) -> None : \"\"\"Initialize FileLoader. Args: serializer: An optional `pytermgui.serializer.Serializer` instance. If not provided, one is instantiated for every FileLoader instance. \"\"\" if serializer is None : serializer = Serializer () self . serializer = serializer def __enter__ ( self ) -> FileLoader : \"\"\"Starts context manager.\"\"\" return self def __exit__ ( self , _ : Any , exception : Exception , __ : Any ) -> bool : \"\"\"Ends context manager.\"\"\" if exception is not None : raise exception def register ( self , cls : Type [ widgets_m . Widget ]) -> None : \"\"\"Registers a widget to the serializer. Args: cls: The widget type to register. \"\"\" self . serializer . register ( cls ) def bind ( self , name : str , method : Callable [ ... , Any ]) -> None : \"\"\"Binds a name to a method. Args: name: The name of the method, as referenced in the loaded files. method: The callable to bind. \"\"\" self . serializer . bind ( name , method ) def load_str ( self , data : str ) -> WidgetNamespace : \"\"\"Creates a `WidgetNamespace` from string data. To parse the data, we use `FileLoader.parse`. To implement custom formats, subclass `FileLoader` with your own `parse` implementation. Args: data: The data to parse. Returns: A WidgetNamespace created from the provided data. \"\"\" parsed = self . parse ( data ) # Get & load config data config_data = parsed . get ( \"config\" ) if config_data is not None : namespace = WidgetNamespace . from_config ( config_data , loader = self ) else : namespace = WidgetNamespace . from_config ({}, loader = self ) # Create aliases for key , value in ( parsed . get ( \"markup\" ) or {}) . items (): tim . alias ( key , value ) # Create boxes for name , inner in ( parsed . get ( \"boxes\" ) or {}) . items (): self . serializer . register_box ( name , widgets_m . boxes . Box ( inner )) # Create widgets for name , inner in ( parsed . get ( \"widgets\" ) or {}) . items (): widget_type = inner . get ( \"type\" ) or name box_name = inner . get ( \"box\" ) box = None if box_name is not None and box_name in namespace . boxes : box = namespace . boxes [ box_name ] del inner [ \"box\" ] try : namespace . widgets [ name ] = self . serializer . from_dict ( inner , widget_type = widget_type ) except AttributeError as error : raise ValueError ( f 'Could not load \" { name } \" from data: \\n { json . dumps ( inner , indent = 2 ) } ' ) from error if box is not None : namespace . widgets [ name ] . box = box return namespace def load ( self , data : str | IO ) -> WidgetNamespace : \"\"\"Loads data from a string or a file. When an IO object is passed, its data is extracted as a string. This string can then be passed to `load_str`. Args: data: Either a string or file stream to load data from. Returns: A WidgetNamespace with the data loaded. \"\"\" if not isinstance ( data , str ): data = data . read () assert isinstance ( data , str ) return self . load_str ( data )","title":"FileLoader"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.FileLoader.__enter__","text":"Starts context manager. Source code in pytermgui/file_loaders.py 287 288 289 290 def __enter__ ( self ) -> FileLoader : \"\"\"Starts context manager.\"\"\" return self","title":"__enter__()"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.FileLoader.__exit__","text":"Ends context manager. Source code in pytermgui/file_loaders.py 292 293 294 295 296 def __exit__ ( self , _ : Any , exception : Exception , __ : Any ) -> bool : \"\"\"Ends context manager.\"\"\" if exception is not None : raise exception","title":"__exit__()"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.FileLoader.__init__","text":"Initialize FileLoader. Parameters: Name Type Description Default serializer Serializer | None An optional pytermgui.serializer.Serializer instance. If not provided, one is instantiated for every FileLoader instance. None Source code in pytermgui/file_loaders.py 274 275 276 277 278 279 280 281 282 283 284 285 def __init__ ( self , serializer : Serializer | None = None ) -> None : \"\"\"Initialize FileLoader. Args: serializer: An optional `pytermgui.serializer.Serializer` instance. If not provided, one is instantiated for every FileLoader instance. \"\"\" if serializer is None : serializer = Serializer () self . serializer = serializer","title":"__init__()"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.FileLoader.bind","text":"Binds a name to a method. Parameters: Name Type Description Default name str The name of the method, as referenced in the loaded files. required method Callable [..., Any ] The callable to bind. required Source code in pytermgui/file_loaders.py 307 308 309 310 311 312 313 314 315 316 def bind ( self , name : str , method : Callable [ ... , Any ]) -> None : \"\"\"Binds a name to a method. Args: name: The name of the method, as referenced in the loaded files. method: The callable to bind. \"\"\" self . serializer . bind ( name , method )","title":"bind()"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.FileLoader.load","text":"Loads data from a string or a file. When an IO object is passed, its data is extracted as a string. This string can then be passed to load_str . Parameters: Name Type Description Default data str | IO Either a string or file stream to load data from. required Returns: Type Description WidgetNamespace A WidgetNamespace with the data loaded. Source code in pytermgui/file_loaders.py 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def load ( self , data : str | IO ) -> WidgetNamespace : \"\"\"Loads data from a string or a file. When an IO object is passed, its data is extracted as a string. This string can then be passed to `load_str`. Args: data: Either a string or file stream to load data from. Returns: A WidgetNamespace with the data loaded. \"\"\" if not isinstance ( data , str ): data = data . read () assert isinstance ( data , str ) return self . load_str ( data )","title":"load()"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.FileLoader.load_str","text":"Creates a WidgetNamespace from string data. To parse the data, we use FileLoader.parse . To implement custom formats, subclass FileLoader with your own parse implementation. Parameters: Name Type Description Default data str The data to parse. required Returns: Type Description WidgetNamespace A WidgetNamespace created from the provided data. Source code in pytermgui/file_loaders.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 def load_str ( self , data : str ) -> WidgetNamespace : \"\"\"Creates a `WidgetNamespace` from string data. To parse the data, we use `FileLoader.parse`. To implement custom formats, subclass `FileLoader` with your own `parse` implementation. Args: data: The data to parse. Returns: A WidgetNamespace created from the provided data. \"\"\" parsed = self . parse ( data ) # Get & load config data config_data = parsed . get ( \"config\" ) if config_data is not None : namespace = WidgetNamespace . from_config ( config_data , loader = self ) else : namespace = WidgetNamespace . from_config ({}, loader = self ) # Create aliases for key , value in ( parsed . get ( \"markup\" ) or {}) . items (): tim . alias ( key , value ) # Create boxes for name , inner in ( parsed . get ( \"boxes\" ) or {}) . items (): self . serializer . register_box ( name , widgets_m . boxes . Box ( inner )) # Create widgets for name , inner in ( parsed . get ( \"widgets\" ) or {}) . items (): widget_type = inner . get ( \"type\" ) or name box_name = inner . get ( \"box\" ) box = None if box_name is not None and box_name in namespace . boxes : box = namespace . boxes [ box_name ] del inner [ \"box\" ] try : namespace . widgets [ name ] = self . serializer . from_dict ( inner , widget_type = widget_type ) except AttributeError as error : raise ValueError ( f 'Could not load \" { name } \" from data: \\n { json . dumps ( inner , indent = 2 ) } ' ) from error if box is not None : namespace . widgets [ name ] . box = box return namespace","title":"load_str()"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.FileLoader.parse","text":"Parses string into a dictionary used by pytermgui.serializer.Serializer . This dictionary follows the structure defined above. Source code in pytermgui/file_loaders.py 267 268 269 270 271 272 @abstractmethod def parse ( self , data : str ) -> dict [ Any , Any ]: \"\"\"Parses string into a dictionary used by `pytermgui.serializer.Serializer`. This dictionary follows the structure defined above. \"\"\"","title":"parse()"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.FileLoader.register","text":"Registers a widget to the serializer. Parameters: Name Type Description Default cls Type [ widgets_m . Widget ] The widget type to register. required Source code in pytermgui/file_loaders.py 298 299 300 301 302 303 304 305 def register ( self , cls : Type [ widgets_m . Widget ]) -> None : \"\"\"Registers a widget to the serializer. Args: cls: The widget type to register. \"\"\" self . serializer . register ( cls )","title":"register()"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.JsonLoader","text":"Bases: FileLoader JSON specific loader subclass. Source code in pytermgui/file_loaders.py 393 394 395 396 397 398 399 400 401 402 403 404 405 406 class JsonLoader ( FileLoader ): \"\"\"JSON specific loader subclass.\"\"\" def parse ( self , data : str ) -> dict [ Any , Any ]: \"\"\"Parse JSON str. Args: data: JSON formatted string. Returns: Loadable dictionary. \"\"\" return json . loads ( data )","title":"JsonLoader"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.JsonLoader.parse","text":"Parse JSON str. Parameters: Name Type Description Default data str JSON formatted string. required Returns: Type Description dict [ Any , Any ] Loadable dictionary. Source code in pytermgui/file_loaders.py 396 397 398 399 400 401 402 403 404 405 406 def parse ( self , data : str ) -> dict [ Any , Any ]: \"\"\"Parse JSON str. Args: data: JSON formatted string. Returns: Loadable dictionary. \"\"\" return json . loads ( data )","title":"parse()"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.WidgetNamespace","text":"Class to hold data on loaded namespace. Source code in pytermgui/file_loaders.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 @dataclass class WidgetNamespace : \"\"\"Class to hold data on loaded namespace.\"\"\" # No clue why `widgets` is seen as undefined here, # but not in the code below. It only seems to happen # in certain pylint configs as well. config : dict [ Type [ widgets_m . Widget ], dict [ str , Any ] # pylint: disable=undefined-variable ] widgets : dict [ str , widgets_m . Widget ] boxes : dict [ str , widgets_m . boxes . Box ] = field ( default_factory = dict ) @classmethod def from_config ( cls , data : dict [ Any , Any ], loader : FileLoader ) -> WidgetNamespace : \"\"\"Creates a namespace from config data. Args: data: A dictionary of config data. loader: The `FileLoader` instance that should be used. Returns: A new WidgetNamespace with the given config. \"\"\" namespace = WidgetNamespace ({}, {}) for name , config in data . items (): obj = loader . serializer . known_widgets . get ( name ) if obj is None : raise KeyError ( f \"Unknown widget type { name } .\" ) namespace . config [ obj ] = { \"styles\" : obj . styles , \"chars\" : obj . chars . copy (), } for category , inner in config . items (): value : str | widgets_m . styles . MarkupFormatter if category not in namespace . config [ obj ]: setattr ( obj , category , inner ) continue for key , value in inner . items (): namespace . config [ obj ][ category ][ key ] = value namespace . apply_config () return namespace @staticmethod def _apply_section ( widget : Type [ widgets_m . Widget ], title : str , section : dict [ str , str ] ) -> None : \"\"\"Applies configuration section to the widget.\"\"\" for key , value in section . items (): if title == \"styles\" : widget . set_style ( key , value ) continue widget . set_char ( key , value ) def apply_to ( self , widget : widgets_m . Widget ) -> None : \"\"\"Applies namespace config to the widget. Args: widget: The widget in question. \"\"\" def _apply_sections ( data : dict [ str , dict [ str , str ]], widget : widgets_m . Widget ) -> None : \"\"\"Applies sections from data to the widget.\"\"\" for title , section in data . items (): self . _apply_section ( type ( widget ), title , section ) data = self . config . get ( type ( widget )) if data is None : return _apply_sections ( data , widget ) if hasattr ( widget , \"_widgets\" ): for inner in widget : inner_section = self . config . get ( type ( inner )) if inner_section is None : continue _apply_sections ( inner_section , inner ) def apply_config ( self ) -> None : \"\"\"Apply self.config to current namespace.\"\"\" for widget , settings in self . config . items (): for title , section in settings . items (): self . _apply_section ( widget , title , section ) def __getattr__ ( self , attr : str ) -> widgets_m . Widget : \"\"\"Get widget by name from widget list.\"\"\" if attr in self . widgets : return self . widgets [ attr ] return self . __dict__ [ attr ]","title":"WidgetNamespace"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.WidgetNamespace.__getattr__","text":"Get widget by name from widget list. Source code in pytermgui/file_loaders.py 246 247 248 249 250 251 252 def __getattr__ ( self , attr : str ) -> widgets_m . Widget : \"\"\"Get widget by name from widget list.\"\"\" if attr in self . widgets : return self . widgets [ attr ] return self . __dict__ [ attr ]","title":"__getattr__()"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.WidgetNamespace.apply_config","text":"Apply self.config to current namespace. Source code in pytermgui/file_loaders.py 239 240 241 242 243 244 def apply_config ( self ) -> None : \"\"\"Apply self.config to current namespace.\"\"\" for widget , settings in self . config . items (): for title , section in settings . items (): self . _apply_section ( widget , title , section )","title":"apply_config()"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.WidgetNamespace.apply_to","text":"Applies namespace config to the widget. Parameters: Name Type Description Default widget widgets_m . Widget The widget in question. required Source code in pytermgui/file_loaders.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def apply_to ( self , widget : widgets_m . Widget ) -> None : \"\"\"Applies namespace config to the widget. Args: widget: The widget in question. \"\"\" def _apply_sections ( data : dict [ str , dict [ str , str ]], widget : widgets_m . Widget ) -> None : \"\"\"Applies sections from data to the widget.\"\"\" for title , section in data . items (): self . _apply_section ( type ( widget ), title , section ) data = self . config . get ( type ( widget )) if data is None : return _apply_sections ( data , widget ) if hasattr ( widget , \"_widgets\" ): for inner in widget : inner_section = self . config . get ( type ( inner )) if inner_section is None : continue _apply_sections ( inner_section , inner )","title":"apply_to()"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.WidgetNamespace.from_config","text":"Creates a namespace from config data. Parameters: Name Type Description Default data dict [ Any , Any ] A dictionary of config data. required loader FileLoader The FileLoader instance that should be used. required Returns: Type Description WidgetNamespace A new WidgetNamespace with the given config. Source code in pytermgui/file_loaders.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 @classmethod def from_config ( cls , data : dict [ Any , Any ], loader : FileLoader ) -> WidgetNamespace : \"\"\"Creates a namespace from config data. Args: data: A dictionary of config data. loader: The `FileLoader` instance that should be used. Returns: A new WidgetNamespace with the given config. \"\"\" namespace = WidgetNamespace ({}, {}) for name , config in data . items (): obj = loader . serializer . known_widgets . get ( name ) if obj is None : raise KeyError ( f \"Unknown widget type { name } .\" ) namespace . config [ obj ] = { \"styles\" : obj . styles , \"chars\" : obj . chars . copy (), } for category , inner in config . items (): value : str | widgets_m . styles . MarkupFormatter if category not in namespace . config [ obj ]: setattr ( obj , category , inner ) continue for key , value in inner . items (): namespace . config [ obj ][ category ][ key ] = value namespace . apply_config () return namespace","title":"from_config()"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.YamlLoader","text":"Bases: FileLoader YAML specific loader subclass. Source code in pytermgui/file_loaders.py 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 class YamlLoader ( FileLoader ): \"\"\"YAML specific loader subclass.\"\"\" def __init__ ( self , serializer : Serializer | None = None ) -> None : \"\"\"Initialize object, check for installation of PyYAML.\"\"\" if YAML_ERROR is not None : raise RuntimeError ( \"YAML implementation module not found. Please install `PyYAML` to use `YamlLoader`.\" ) from YAML_ERROR super () . __init__ () def parse ( self , data : str ) -> dict [ Any , Any ]: \"\"\"Parse YAML str. Args: data: YAML formatted string. Returns: Loadable dictionary. \"\"\" assert yaml is not None return yaml . safe_load ( data )","title":"YamlLoader"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.YamlLoader.__init__","text":"Initialize object, check for installation of PyYAML. Source code in pytermgui/file_loaders.py 412 413 414 415 416 417 418 419 420 def __init__ ( self , serializer : Serializer | None = None ) -> None : \"\"\"Initialize object, check for installation of PyYAML.\"\"\" if YAML_ERROR is not None : raise RuntimeError ( \"YAML implementation module not found. Please install `PyYAML` to use `YamlLoader`.\" ) from YAML_ERROR super () . __init__ ()","title":"__init__()"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.YamlLoader.parse","text":"Parse YAML str. Parameters: Name Type Description Default data str YAML formatted string. required Returns: Type Description dict [ Any , Any ] Loadable dictionary. Source code in pytermgui/file_loaders.py 422 423 424 425 426 427 428 429 430 431 432 433 def parse ( self , data : str ) -> dict [ Any , Any ]: \"\"\"Parse YAML str. Args: data: YAML formatted string. Returns: Loadable dictionary. \"\"\" assert yaml is not None return yaml . safe_load ( data )","title":"parse()"},{"location":"reference/pytermgui/helpers/","text":"Helper methods and functions for pytermgui. break_line ( line , limit , non_first_limit = None , fill = None ) Breaks a line into a list[str] with maximum limit length per line. It keeps ongoing ANSI sequences between lines, and inserts a reset sequence at the end of each style-containing line. At the moment it splits strings exactly on the limit, and not on word boundaries. That functionality would be preferred, so it will end up being implemented at some point. Parameters: Name Type Description Default line str The line to split. May or may not contain ANSI sequences. required limit int The maximum amount of characters allowed in each line, excluding non-printing sequences. required non_first_limit int | None The limit after the first line. If not given, defaults to limit . None Source code in pytermgui/helpers.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def break_line ( # pylint: disable=too-many-branches line : str , limit : int , non_first_limit : int | None = None , fill : str | None = None ) -> Iterator [ str ]: \"\"\"Breaks a line into a `list[str]` with maximum `limit` length per line. It keeps ongoing ANSI sequences between lines, and inserts a reset sequence at the end of each style-containing line. At the moment it splits strings exactly on the limit, and not on word boundaries. That functionality would be preferred, so it will end up being implemented at some point. Args: line: The line to split. May or may not contain ANSI sequences. limit: The maximum amount of characters allowed in each line, excluding non-printing sequences. non_first_limit: The limit after the first line. If not given, defaults to `limit`. \"\"\" if line in [ \"\" , \" \\x1b [0m\" ]: yield \"\" return def _pad_and_link ( line : str , link : str | None ) -> str : count = limit - real_length ( line ) if link is not None : line = LINK_TEMPLATE . format ( uri = link , label = line ) if fill is None : return line line += count * fill return line used = 0 current = \"\" sequences = \"\" if non_first_limit is None : non_first_limit = limit parsers = PARSERS link = None for token in tokenize_ansi ( line ): if token . is_plain (): for char in token . value : if char == \" \\n \" or used >= limit : if sequences != \"\" : current += \" \\x1b [0m\" yield _pad_and_link ( current , link ) link = None current = sequences used = 0 limit = non_first_limit if char != \" \\n \" : current += char used += 1 # If the link wasn't yielded along with its token, remove and add it # to current manually. if link is not None : current = current [: - len ( token . value )] current += LINK_TEMPLATE . format ( uri = link , label = token . value ) link = None continue if token . value == \"/\" : sequences = \" \\x1b [0m\" if len ( current ) > 0 : current += sequences continue if token . is_hyperlink (): link = token . value continue sequence = parsers [ type ( token )]( token , {}, lambda : line ) # type: ignore sequences += sequence current += sequence if current == \"\" : return if sequences != \"\" and not current . endswith ( \" \\x1b [0m\" ): current += \" \\x1b [0m\" yield _pad_and_link ( current , link )","title":"helpers"},{"location":"reference/pytermgui/helpers/#pytermgui.helpers.break_line","text":"Breaks a line into a list[str] with maximum limit length per line. It keeps ongoing ANSI sequences between lines, and inserts a reset sequence at the end of each style-containing line. At the moment it splits strings exactly on the limit, and not on word boundaries. That functionality would be preferred, so it will end up being implemented at some point. Parameters: Name Type Description Default line str The line to split. May or may not contain ANSI sequences. required limit int The maximum amount of characters allowed in each line, excluding non-printing sequences. required non_first_limit int | None The limit after the first line. If not given, defaults to limit . None Source code in pytermgui/helpers.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def break_line ( # pylint: disable=too-many-branches line : str , limit : int , non_first_limit : int | None = None , fill : str | None = None ) -> Iterator [ str ]: \"\"\"Breaks a line into a `list[str]` with maximum `limit` length per line. It keeps ongoing ANSI sequences between lines, and inserts a reset sequence at the end of each style-containing line. At the moment it splits strings exactly on the limit, and not on word boundaries. That functionality would be preferred, so it will end up being implemented at some point. Args: line: The line to split. May or may not contain ANSI sequences. limit: The maximum amount of characters allowed in each line, excluding non-printing sequences. non_first_limit: The limit after the first line. If not given, defaults to `limit`. \"\"\" if line in [ \"\" , \" \\x1b [0m\" ]: yield \"\" return def _pad_and_link ( line : str , link : str | None ) -> str : count = limit - real_length ( line ) if link is not None : line = LINK_TEMPLATE . format ( uri = link , label = line ) if fill is None : return line line += count * fill return line used = 0 current = \"\" sequences = \"\" if non_first_limit is None : non_first_limit = limit parsers = PARSERS link = None for token in tokenize_ansi ( line ): if token . is_plain (): for char in token . value : if char == \" \\n \" or used >= limit : if sequences != \"\" : current += \" \\x1b [0m\" yield _pad_and_link ( current , link ) link = None current = sequences used = 0 limit = non_first_limit if char != \" \\n \" : current += char used += 1 # If the link wasn't yielded along with its token, remove and add it # to current manually. if link is not None : current = current [: - len ( token . value )] current += LINK_TEMPLATE . format ( uri = link , label = token . value ) link = None continue if token . value == \"/\" : sequences = \" \\x1b [0m\" if len ( current ) > 0 : current += sequences continue if token . is_hyperlink (): link = token . value continue sequence = parsers [ type ( token )]( token , {}, lambda : line ) # type: ignore sequences += sequence current += sequence if current == \"\" : return if sequences != \"\" and not current . endswith ( \" \\x1b [0m\" ): current += \" \\x1b [0m\" yield _pad_and_link ( current , link )","title":"break_line()"},{"location":"reference/pytermgui/highlighters/","text":"This module provides the Highlighter class, and some pre-configured instances. Highlighter Bases: Protocol The protocol for highlighters. Source code in pytermgui/highlighters.py 26 27 28 29 30 31 32 33 34 35 36 class Highlighter ( Protocol ): # pylint: disable=too-few-public-methods \"\"\"The protocol for highlighters.\"\"\" def __call__ ( self , text : str , cache : bool = True ) -> str : \"\"\"Highlights the given text. Args: text: The text to highlight. cache: If set (default), results will be stored, keyed by their respective inputs, and retrieved the next time the same key is given. \"\"\" __call__ ( text , cache = True ) Highlights the given text. Parameters: Name Type Description Default text str The text to highlight. required cache bool If set (default), results will be stored, keyed by their respective inputs, and retrieved the next time the same key is given. True Source code in pytermgui/highlighters.py 29 30 31 32 33 34 35 36 def __call__ ( self , text : str , cache : bool = True ) -> str : \"\"\"Highlights the given text. Args: text: The text to highlight. cache: If set (default), results will be stored, keyed by their respective inputs, and retrieved the next time the same key is given. \"\"\" RegexHighlighter dataclass A class to highlight strings using regular expressions. This class must be provided with a list of styles. These styles are really just a tuple of the markup alias name, and their associated RE patterns. If all aliases in the instance use the same prefix, it can be given under the prefix key and ommitted from the style names. On construction, the instance will combine all of its patterns into a monster regex including named capturing groups. The general format is something like: (?P<{name1}>{pattern1})|(?P<{name2}>{pattern2})|... Calling this instance will then replace all matches, going in the order of definition, with style-injected versions. These follow the format: [{prefix?}{name}]{content}[/{prefix}{name}] Oddities to keep in mind: - Regex replace goes in the order of the defined groups, and is non-overlapping. Two groups cannot match the same text. - Because of how capturing groups work, everything within the patterns will be matched. To look for context around a match, look-around assertions can be used. Source code in pytermgui/highlighters.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 @dataclass class RegexHighlighter : \"\"\"A class to highlight strings using regular expressions. This class must be provided with a list of styles. These styles are really just a tuple of the markup alias name, and their associated RE patterns. If *all* aliases in the instance use the same prefix, it can be given under the `prefix` key and ommitted from the style names. On construction, the instance will combine all of its patterns into a monster regex including named capturing groups. The general format is something like: (?P<{name1}>{pattern1})|(?P<{name2}>{pattern2})|... Calling this instance will then replace all matches, going in the order of definition, with style-injected versions. These follow the format: [{prefix?}{name}]{content}[/{prefix}{name}] Oddities to keep in mind: - Regex replace goes in the order of the defined groups, and is non-overlapping. Two groups cannot match the same text. - Because of how capturing groups work, everything within the patterns will be matched. To look for context around a match, look-around assertions can be used. \"\"\" styles : list [ tuple [ str , str ]] \"\"\"A list of tuples of (style_alias, pattern_str).\"\"\" prefix : str = \"\" \"\"\"Some string to insert before each style alias.\"\"\" pre_formatter : Callable [[ str ], str ] | None = None \"\"\"A callable that formats the input string, before any highlighting is done to it.\"\"\" match_formatter : Callable [[ Match , str ], str ] | None = None \"\"\"A callable of (match, content) that gets called on every match. Its return value will be used as the content that the already set highlighting will apply to. Useful to trim text, or apply other transformations before inserting it back. \"\"\" re_flags : int = 0 \"\"\"All regex flags to apply when compiling the generated pattern, OR-d (|) together.\"\"\" _pattern : Pattern = field ( init = False ) _highlight_cache : dict [ str , str ] = field ( init = False , default_factory = dict ) def __post_init__ ( self ) -> None : \"\"\"Combines all styles into one pattern.\"\"\" pattern = \"\" names : list [ str ] = [] for name , ptrn in self . styles : pattern += f \"(?P< { name } > { ptrn } )|\" names . append ( name ) pattern = pattern [: - 1 ] self . _pattern = re . compile ( pattern , flags = self . re_flags ) def __call__ ( self , text : str , cache : bool = True ) -> str : \"\"\"Highlights the given text, using the combined regex pattern.\"\"\" if self . pre_formatter is not None : text = self . pre_formatter ( text ) if cache and text in self . _highlight_cache : return self . _highlight_cache [ text ] cache_key = text def _insert_style ( matchobj : Match ) -> str : \"\"\"Returns the match inserted into a markup style.\"\"\" groups = matchobj . groupdict () name = matchobj . lastgroup content = groups . get ( str ( name ), None ) if self . match_formatter is not None : content = self . match_formatter ( matchobj , content ) if content == \"\" : return \"\" tag = f \" { self . prefix }{ name } \" style = f \"[ { tag } ] {{}} [/ { tag } ]\" return style . format ( content ) text = self . _pattern . sub ( _insert_style , text ) self . _highlight_cache [ cache_key ] = text return text def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Yields some fancy looking repr text.\"\"\" preview = self ( \"highlight_python()\" ) + \" \\x1b [0m\" pattern = self . _pattern . pattern if len ( pattern ) > 40 : pattern = pattern [: 38 ] + \"...\" yield f \"< { type ( self ) . __name__ } pattern: { pattern !r} , preview: \" yield { \"text\" : str ( preview ), \"highlight\" : False } yield \">\" match_formatter : Callable [[ Match , str ], str ] | None = None class-attribute A callable of (match, content) that gets called on every match. Its return value will be used as the content that the already set highlighting will apply to. Useful to trim text, or apply other transformations before inserting it back. pre_formatter : Callable [[ str ], str ] | None = None class-attribute A callable that formats the input string, before any highlighting is done to it. prefix : str = '' class-attribute Some string to insert before each style alias. re_flags : int = 0 class-attribute All regex flags to apply when compiling the generated pattern, OR-d (|) together. styles : list [ tuple [ str , str ]] class-attribute A list of tuples of (style_alias, pattern_str). __call__ ( text , cache = True ) Highlights the given text, using the combined regex pattern. Source code in pytermgui/highlighters.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def __call__ ( self , text : str , cache : bool = True ) -> str : \"\"\"Highlights the given text, using the combined regex pattern.\"\"\" if self . pre_formatter is not None : text = self . pre_formatter ( text ) if cache and text in self . _highlight_cache : return self . _highlight_cache [ text ] cache_key = text def _insert_style ( matchobj : Match ) -> str : \"\"\"Returns the match inserted into a markup style.\"\"\" groups = matchobj . groupdict () name = matchobj . lastgroup content = groups . get ( str ( name ), None ) if self . match_formatter is not None : content = self . match_formatter ( matchobj , content ) if content == \"\" : return \"\" tag = f \" { self . prefix }{ name } \" style = f \"[ { tag } ] {{}} [/ { tag } ]\" return style . format ( content ) text = self . _pattern . sub ( _insert_style , text ) self . _highlight_cache [ cache_key ] = text return text __fancy_repr__ () Yields some fancy looking repr text. Source code in pytermgui/highlighters.py 135 136 137 138 139 140 141 142 143 144 145 146 147 def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Yields some fancy looking repr text.\"\"\" preview = self ( \"highlight_python()\" ) + \" \\x1b [0m\" pattern = self . _pattern . pattern if len ( pattern ) > 40 : pattern = pattern [: 38 ] + \"...\" yield f \"< { type ( self ) . __name__ } pattern: { pattern !r} , preview: \" yield { \"text\" : str ( preview ), \"highlight\" : False } yield \">\" __post_init__ () Combines all styles into one pattern. Source code in pytermgui/highlighters.py 87 88 89 90 91 92 93 94 95 96 97 98 def __post_init__ ( self ) -> None : \"\"\"Combines all styles into one pattern.\"\"\" pattern = \"\" names : list [ str ] = [] for name , ptrn in self . styles : pattern += f \"(?P< { name } > { ptrn } )|\" names . append ( name ) pattern = pattern [: - 1 ] self . _pattern = re . compile ( pattern , flags = self . re_flags ) highlight_tim ( text , cache = True ) Highlights some TIM code. Source code in pytermgui/highlighters.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 def highlight_tim ( text : str , cache : bool = True ) -> str : \"\"\"Highlights some TIM code.\"\"\" @lru_cache ( 1048 ) def _highlight ( txt : str ) -> str : output = \"\" cursor = 0 active_tokens : list [ Token ] = [] def _get_active_markup () -> str : active_markup = \" \" . join ( tkn . markup for tkn in active_tokens ) if active_markup == \"\" : return \"\" return f \"[ { active_markup } ]\" for matchobj in RE_MARKUP . finditer ( txt ): start , end = matchobj . span () if cursor < start : if cursor > 0 : output += \"]\" output += _get_active_markup () output += f \" { txt [ cursor : start ] } [/]\" * _ , tags = matchobj . groups () output += \"[\" for tag in tags . split (): token = consume_tag ( tag ) output += f \" { token . prettified_markup } \" if Token . is_clear ( token ): active_tokens = [ tkn for tkn in active_tokens if not token . targets ( tkn ) ] else : active_tokens . append ( token ) output = output . rstrip () cursor = end if cursor < len ( txt ) - 1 : if cursor > 0 : output += \"]\" output += _get_active_markup () output += f \" { txt [ cursor :] } \" if len ( active_tokens ) > 0 : output += \"[/]\" if output . count ( \"[\" ) != output . count ( \"]\" ): output += \"]\" return output if cache : return _highlight ( text ) return _highlight . __wrapped__ ( text )","title":"highlighters"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.Highlighter","text":"Bases: Protocol The protocol for highlighters. Source code in pytermgui/highlighters.py 26 27 28 29 30 31 32 33 34 35 36 class Highlighter ( Protocol ): # pylint: disable=too-few-public-methods \"\"\"The protocol for highlighters.\"\"\" def __call__ ( self , text : str , cache : bool = True ) -> str : \"\"\"Highlights the given text. Args: text: The text to highlight. cache: If set (default), results will be stored, keyed by their respective inputs, and retrieved the next time the same key is given. \"\"\"","title":"Highlighter"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.Highlighter.__call__","text":"Highlights the given text. Parameters: Name Type Description Default text str The text to highlight. required cache bool If set (default), results will be stored, keyed by their respective inputs, and retrieved the next time the same key is given. True Source code in pytermgui/highlighters.py 29 30 31 32 33 34 35 36 def __call__ ( self , text : str , cache : bool = True ) -> str : \"\"\"Highlights the given text. Args: text: The text to highlight. cache: If set (default), results will be stored, keyed by their respective inputs, and retrieved the next time the same key is given. \"\"\"","title":"__call__()"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.RegexHighlighter","text":"A class to highlight strings using regular expressions. This class must be provided with a list of styles. These styles are really just a tuple of the markup alias name, and their associated RE patterns. If all aliases in the instance use the same prefix, it can be given under the prefix key and ommitted from the style names. On construction, the instance will combine all of its patterns into a monster regex including named capturing groups. The general format is something like: (?P<{name1}>{pattern1})|(?P<{name2}>{pattern2})|... Calling this instance will then replace all matches, going in the order of definition, with style-injected versions. These follow the format: [{prefix?}{name}]{content}[/{prefix}{name}] Oddities to keep in mind: - Regex replace goes in the order of the defined groups, and is non-overlapping. Two groups cannot match the same text. - Because of how capturing groups work, everything within the patterns will be matched. To look for context around a match, look-around assertions can be used. Source code in pytermgui/highlighters.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 @dataclass class RegexHighlighter : \"\"\"A class to highlight strings using regular expressions. This class must be provided with a list of styles. These styles are really just a tuple of the markup alias name, and their associated RE patterns. If *all* aliases in the instance use the same prefix, it can be given under the `prefix` key and ommitted from the style names. On construction, the instance will combine all of its patterns into a monster regex including named capturing groups. The general format is something like: (?P<{name1}>{pattern1})|(?P<{name2}>{pattern2})|... Calling this instance will then replace all matches, going in the order of definition, with style-injected versions. These follow the format: [{prefix?}{name}]{content}[/{prefix}{name}] Oddities to keep in mind: - Regex replace goes in the order of the defined groups, and is non-overlapping. Two groups cannot match the same text. - Because of how capturing groups work, everything within the patterns will be matched. To look for context around a match, look-around assertions can be used. \"\"\" styles : list [ tuple [ str , str ]] \"\"\"A list of tuples of (style_alias, pattern_str).\"\"\" prefix : str = \"\" \"\"\"Some string to insert before each style alias.\"\"\" pre_formatter : Callable [[ str ], str ] | None = None \"\"\"A callable that formats the input string, before any highlighting is done to it.\"\"\" match_formatter : Callable [[ Match , str ], str ] | None = None \"\"\"A callable of (match, content) that gets called on every match. Its return value will be used as the content that the already set highlighting will apply to. Useful to trim text, or apply other transformations before inserting it back. \"\"\" re_flags : int = 0 \"\"\"All regex flags to apply when compiling the generated pattern, OR-d (|) together.\"\"\" _pattern : Pattern = field ( init = False ) _highlight_cache : dict [ str , str ] = field ( init = False , default_factory = dict ) def __post_init__ ( self ) -> None : \"\"\"Combines all styles into one pattern.\"\"\" pattern = \"\" names : list [ str ] = [] for name , ptrn in self . styles : pattern += f \"(?P< { name } > { ptrn } )|\" names . append ( name ) pattern = pattern [: - 1 ] self . _pattern = re . compile ( pattern , flags = self . re_flags ) def __call__ ( self , text : str , cache : bool = True ) -> str : \"\"\"Highlights the given text, using the combined regex pattern.\"\"\" if self . pre_formatter is not None : text = self . pre_formatter ( text ) if cache and text in self . _highlight_cache : return self . _highlight_cache [ text ] cache_key = text def _insert_style ( matchobj : Match ) -> str : \"\"\"Returns the match inserted into a markup style.\"\"\" groups = matchobj . groupdict () name = matchobj . lastgroup content = groups . get ( str ( name ), None ) if self . match_formatter is not None : content = self . match_formatter ( matchobj , content ) if content == \"\" : return \"\" tag = f \" { self . prefix }{ name } \" style = f \"[ { tag } ] {{}} [/ { tag } ]\" return style . format ( content ) text = self . _pattern . sub ( _insert_style , text ) self . _highlight_cache [ cache_key ] = text return text def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Yields some fancy looking repr text.\"\"\" preview = self ( \"highlight_python()\" ) + \" \\x1b [0m\" pattern = self . _pattern . pattern if len ( pattern ) > 40 : pattern = pattern [: 38 ] + \"...\" yield f \"< { type ( self ) . __name__ } pattern: { pattern !r} , preview: \" yield { \"text\" : str ( preview ), \"highlight\" : False } yield \">\"","title":"RegexHighlighter"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.RegexHighlighter.match_formatter","text":"A callable of (match, content) that gets called on every match. Its return value will be used as the content that the already set highlighting will apply to. Useful to trim text, or apply other transformations before inserting it back.","title":"match_formatter"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.RegexHighlighter.pre_formatter","text":"A callable that formats the input string, before any highlighting is done to it.","title":"pre_formatter"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.RegexHighlighter.prefix","text":"Some string to insert before each style alias.","title":"prefix"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.RegexHighlighter.re_flags","text":"All regex flags to apply when compiling the generated pattern, OR-d (|) together.","title":"re_flags"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.RegexHighlighter.styles","text":"A list of tuples of (style_alias, pattern_str).","title":"styles"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.RegexHighlighter.__call__","text":"Highlights the given text, using the combined regex pattern. Source code in pytermgui/highlighters.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def __call__ ( self , text : str , cache : bool = True ) -> str : \"\"\"Highlights the given text, using the combined regex pattern.\"\"\" if self . pre_formatter is not None : text = self . pre_formatter ( text ) if cache and text in self . _highlight_cache : return self . _highlight_cache [ text ] cache_key = text def _insert_style ( matchobj : Match ) -> str : \"\"\"Returns the match inserted into a markup style.\"\"\" groups = matchobj . groupdict () name = matchobj . lastgroup content = groups . get ( str ( name ), None ) if self . match_formatter is not None : content = self . match_formatter ( matchobj , content ) if content == \"\" : return \"\" tag = f \" { self . prefix }{ name } \" style = f \"[ { tag } ] {{}} [/ { tag } ]\" return style . format ( content ) text = self . _pattern . sub ( _insert_style , text ) self . _highlight_cache [ cache_key ] = text return text","title":"__call__()"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.RegexHighlighter.__fancy_repr__","text":"Yields some fancy looking repr text. Source code in pytermgui/highlighters.py 135 136 137 138 139 140 141 142 143 144 145 146 147 def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Yields some fancy looking repr text.\"\"\" preview = self ( \"highlight_python()\" ) + \" \\x1b [0m\" pattern = self . _pattern . pattern if len ( pattern ) > 40 : pattern = pattern [: 38 ] + \"...\" yield f \"< { type ( self ) . __name__ } pattern: { pattern !r} , preview: \" yield { \"text\" : str ( preview ), \"highlight\" : False } yield \">\"","title":"__fancy_repr__()"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.RegexHighlighter.__post_init__","text":"Combines all styles into one pattern. Source code in pytermgui/highlighters.py 87 88 89 90 91 92 93 94 95 96 97 98 def __post_init__ ( self ) -> None : \"\"\"Combines all styles into one pattern.\"\"\" pattern = \"\" names : list [ str ] = [] for name , ptrn in self . styles : pattern += f \"(?P< { name } > { ptrn } )|\" names . append ( name ) pattern = pattern [: - 1 ] self . _pattern = re . compile ( pattern , flags = self . re_flags )","title":"__post_init__()"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.highlight_tim","text":"Highlights some TIM code. Source code in pytermgui/highlighters.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 def highlight_tim ( text : str , cache : bool = True ) -> str : \"\"\"Highlights some TIM code.\"\"\" @lru_cache ( 1048 ) def _highlight ( txt : str ) -> str : output = \"\" cursor = 0 active_tokens : list [ Token ] = [] def _get_active_markup () -> str : active_markup = \" \" . join ( tkn . markup for tkn in active_tokens ) if active_markup == \"\" : return \"\" return f \"[ { active_markup } ]\" for matchobj in RE_MARKUP . finditer ( txt ): start , end = matchobj . span () if cursor < start : if cursor > 0 : output += \"]\" output += _get_active_markup () output += f \" { txt [ cursor : start ] } [/]\" * _ , tags = matchobj . groups () output += \"[\" for tag in tags . split (): token = consume_tag ( tag ) output += f \" { token . prettified_markup } \" if Token . is_clear ( token ): active_tokens = [ tkn for tkn in active_tokens if not token . targets ( tkn ) ] else : active_tokens . append ( token ) output = output . rstrip () cursor = end if cursor < len ( txt ) - 1 : if cursor > 0 : output += \"]\" output += _get_active_markup () output += f \" { txt [ cursor :] } \" if len ( active_tokens ) > 0 : output += \"[/]\" if output . count ( \"[\" ) != output . count ( \"]\" ): output += \"]\" return output if cache : return _highlight ( text ) return _highlight . __wrapped__ ( text )","title":"highlight_tim()"},{"location":"reference/pytermgui/input/","text":"File providing the getch() function to easily read character inputs. Credits: Original getch implementation: Danny Yoo Modern additions & idea: kcsaff Note that the original link seems to no longer be active, but an archive can be found on GitHub . Keys Class for easy access to key-codes. The keys for CTRL_{ascii_letter}-s can be generated with the following code: for i , letter in enumerate ( ascii_lowercase ): key = f \"CTRL_ { letter . upper () } \" code = chr ( i + 1 ) . encode ( 'unicode_escape' ) . decode ( 'utf-8' ) print ( key , code ) Source code in pytermgui/input.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 class Keys : \"\"\"Class for easy access to key-codes. The keys for CTRL_{ascii_letter}-s can be generated with the following code: ```python3 for i, letter in enumerate(ascii_lowercase): key = f\"CTRL_{letter.upper()}\" code = chr(i+1).encode('unicode_escape').decode('utf-8') print(key, code) ``` \"\"\" def __init__ ( self , platform_keys : dict [ str , str ], platform : str ) -> None : \"\"\"Initialize Keys object. Args: platform_keys: A dictionary of platform-specific keys. platform: The platform the program is running on. \"\"\" self . _keys = { \"SPACE\" : \" \" , \"ESC\" : \" \\x1b \" , # The ALT character in key combinations is the same as ESC \"ALT\" : \" \\x1b \" , \"TAB\" : \" \\t \" , \"ENTER\" : \" \\n \" , \"RETURN\" : \" \\n \" , \"CTRL_SPACE\" : \" \\x00 \" , \"CTRL_A\" : \" \\x01 \" , \"CTRL_B\" : \" \\x02 \" , \"CTRL_C\" : \" \\x03 \" , \"CTRL_D\" : \" \\x04 \" , \"CTRL_E\" : \" \\x05 \" , \"CTRL_F\" : \" \\x06 \" , \"CTRL_G\" : \" \\x07 \" , \"CTRL_H\" : \" \\x08 \" , \"CTRL_I\" : \" \\t \" , \"CTRL_J\" : \" \\n \" , \"CTRL_K\" : \" \\x0b \" , \"CTRL_L\" : \" \\x0c \" , \"CTRL_M\" : \" \\r \" , \"CTRL_N\" : \" \\x0e \" , \"CTRL_O\" : \" \\x0f \" , \"CTRL_P\" : \" \\x10 \" , \"CTRL_Q\" : \" \\x11 \" , \"CTRL_R\" : \" \\x12 \" , \"CTRL_S\" : \" \\x13 \" , \"CTRL_T\" : \" \\x14 \" , \"CTRL_U\" : \" \\x15 \" , \"CTRL_V\" : \" \\x16 \" , \"CTRL_W\" : \" \\x17 \" , \"CTRL_X\" : \" \\x18 \" , \"CTRL_Y\" : \" \\x19 \" , \"CTRL_Z\" : \" \\x1a \" , } self . platform = platform if platform_keys is not None : for key , code in platform_keys . items (): if key == \"name\" : self . name = code continue self . _keys [ key ] = code def __getattr__ ( self , attr : str ) -> str : \"\"\"Gets attr from self._keys.\"\"\" if attr == \"ANY_KEY\" : return attr return self . _keys . get ( attr , \"\" ) def get_name ( self , key : str , default : Optional [ str ] = None ) -> Optional [ str ]: \"\"\"Gets canonical name of a key code. Args: key: The key to get the name of. default: The return value to substitute if no canonical name could be found. Defaults to None. Returns: The canonical name if one can be found, default otherwise. \"\"\" for name , value in self . _keys . items (): if key == value : return name return default def values ( self ) -> ValuesView [ str ]: \"\"\"Returns values() of self._keys.\"\"\" return self . _keys . values () def keys ( self ) -> KeysView [ str ]: \"\"\"Returns keys() of self._keys.\"\"\" return self . _keys . keys () def items ( self ) -> ItemsView [ str , str ]: \"\"\"Returns items() of self._keys.\"\"\" return self . _keys . items () __getattr__ ( attr ) Gets attr from self._keys. Source code in pytermgui/input.py 268 269 270 271 272 273 274 def __getattr__ ( self , attr : str ) -> str : \"\"\"Gets attr from self._keys.\"\"\" if attr == \"ANY_KEY\" : return attr return self . _keys . get ( attr , \"\" ) __init__ ( platform_keys , platform ) Initialize Keys object. Parameters: Name Type Description Default platform_keys dict [ str , str ] A dictionary of platform-specific keys. required platform str The platform the program is running on. required Source code in pytermgui/input.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def __init__ ( self , platform_keys : dict [ str , str ], platform : str ) -> None : \"\"\"Initialize Keys object. Args: platform_keys: A dictionary of platform-specific keys. platform: The platform the program is running on. \"\"\" self . _keys = { \"SPACE\" : \" \" , \"ESC\" : \" \\x1b \" , # The ALT character in key combinations is the same as ESC \"ALT\" : \" \\x1b \" , \"TAB\" : \" \\t \" , \"ENTER\" : \" \\n \" , \"RETURN\" : \" \\n \" , \"CTRL_SPACE\" : \" \\x00 \" , \"CTRL_A\" : \" \\x01 \" , \"CTRL_B\" : \" \\x02 \" , \"CTRL_C\" : \" \\x03 \" , \"CTRL_D\" : \" \\x04 \" , \"CTRL_E\" : \" \\x05 \" , \"CTRL_F\" : \" \\x06 \" , \"CTRL_G\" : \" \\x07 \" , \"CTRL_H\" : \" \\x08 \" , \"CTRL_I\" : \" \\t \" , \"CTRL_J\" : \" \\n \" , \"CTRL_K\" : \" \\x0b \" , \"CTRL_L\" : \" \\x0c \" , \"CTRL_M\" : \" \\r \" , \"CTRL_N\" : \" \\x0e \" , \"CTRL_O\" : \" \\x0f \" , \"CTRL_P\" : \" \\x10 \" , \"CTRL_Q\" : \" \\x11 \" , \"CTRL_R\" : \" \\x12 \" , \"CTRL_S\" : \" \\x13 \" , \"CTRL_T\" : \" \\x14 \" , \"CTRL_U\" : \" \\x15 \" , \"CTRL_V\" : \" \\x16 \" , \"CTRL_W\" : \" \\x17 \" , \"CTRL_X\" : \" \\x18 \" , \"CTRL_Y\" : \" \\x19 \" , \"CTRL_Z\" : \" \\x1a \" , } self . platform = platform if platform_keys is not None : for key , code in platform_keys . items (): if key == \"name\" : self . name = code continue self . _keys [ key ] = code get_name ( key , default = None ) Gets canonical name of a key code. Parameters: Name Type Description Default key str The key to get the name of. required default Optional [ str ] The return value to substitute if no canonical name could be found. Defaults to None. None Returns: Type Description Optional [ str ] The canonical name if one can be found, default otherwise. Source code in pytermgui/input.py 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 def get_name ( self , key : str , default : Optional [ str ] = None ) -> Optional [ str ]: \"\"\"Gets canonical name of a key code. Args: key: The key to get the name of. default: The return value to substitute if no canonical name could be found. Defaults to None. Returns: The canonical name if one can be found, default otherwise. \"\"\" for name , value in self . _keys . items (): if key == value : return name return default items () Returns items() of self._keys. Source code in pytermgui/input.py 304 305 306 307 def items ( self ) -> ItemsView [ str , str ]: \"\"\"Returns items() of self._keys.\"\"\" return self . _keys . items () keys () Returns keys() of self._keys. Source code in pytermgui/input.py 299 300 301 302 def keys ( self ) -> KeysView [ str ]: \"\"\"Returns keys() of self._keys.\"\"\" return self . _keys . keys () values () Returns values() of self._keys. Source code in pytermgui/input.py 294 295 296 297 def values ( self ) -> ValuesView [ str ]: \"\"\"Returns values() of self._keys.\"\"\" return self . _keys . values () getch ( printable = False , interrupts = True ) Wrapper to call the platform-appropriate character getter. Parameters: Name Type Description Default printable bool When set, printable versions of the input are returned. False interrupts bool If not set, KeyboardInterrupt is silenced and chr(3) ( CTRL_C ) is returned. True Source code in pytermgui/input.py 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 def getch ( printable : bool = False , interrupts : bool = True ) -> Any : \"\"\"Wrapper to call the platform-appropriate character getter. Args: printable: When set, printable versions of the input are returned. interrupts: If not set, `KeyboardInterrupt` is silenced and `chr(3)` (`CTRL_C`) is returned. \"\"\" try : key = _getch () # msvcrt.getch returns CTRL_C as a character, unlike UNIX systems # where an interrupt is raised. Thus, we need to manually raise # the interrupt. if key == chr ( 3 ): raise KeyboardInterrupt except KeyboardInterrupt as error : if interrupts : raise KeyboardInterrupt ( \"Unhandled interrupt\" ) from error key = chr ( 3 ) if printable : key = key . encode ( \"unicode_escape\" ) . decode ( \"utf-8\" ) return key getch_timeout ( duration , default = '' , printable = False , interrupts = True ) Calls getch , returns default if timeout passes before getting input. No timeout is applied on Windows systems, as there is no support for SIGALRM . Parameters: Name Type Description Default duration float How long the call should wait for input. required default str The value to return if timeout occured. '' Source code in pytermgui/input.py 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 def getch_timeout ( duration : float , default : str = \"\" , printable : bool = False , interrupts : bool = True ) -> Any : \"\"\"Calls `getch`, returns `default` if timeout passes before getting input. No timeout is applied on Windows systems, as there is no support for `SIGALRM`. Args: duration: How long the call should wait for input. default: The value to return if timeout occured. \"\"\" if isinstance ( _getch , _GetchWindows ): return getch () with timeout ( duration ): return getch ( printable = printable , interrupts = interrupts ) return default timeout ( duration ) Allows context to run for a certain amount of time, quits it once it's up. Note that this should never be run on Windows, as the required signals are not present. Whenever this function is run, there should be a preliminary OS check, to avoid running into issues on unsupported machines. Source code in pytermgui/input.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @contextmanager def timeout ( duration : float ) -> Generator [ None , None , None ]: \"\"\"Allows context to run for a certain amount of time, quits it once it's up. Note that this should never be run on Windows, as the required signals are not present. Whenever this function is run, there should be a preliminary OS check, to avoid running into issues on unsupported machines. \"\"\" def _raise_timeout ( * _ , ** __ ): raise TimeoutException ( \"The action has timed out.\" ) try : # set the timeout handler signal . signal ( signal . SIGALRM , _raise_timeout ) signal . setitimer ( signal . ITIMER_REAL , duration ) yield except TimeoutException : pass finally : signal . alarm ( 0 )","title":"input"},{"location":"reference/pytermgui/input/#pytermgui.input.Keys","text":"Class for easy access to key-codes. The keys for CTRL_{ascii_letter}-s can be generated with the following code: for i , letter in enumerate ( ascii_lowercase ): key = f \"CTRL_ { letter . upper () } \" code = chr ( i + 1 ) . encode ( 'unicode_escape' ) . decode ( 'utf-8' ) print ( key , code ) Source code in pytermgui/input.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 class Keys : \"\"\"Class for easy access to key-codes. The keys for CTRL_{ascii_letter}-s can be generated with the following code: ```python3 for i, letter in enumerate(ascii_lowercase): key = f\"CTRL_{letter.upper()}\" code = chr(i+1).encode('unicode_escape').decode('utf-8') print(key, code) ``` \"\"\" def __init__ ( self , platform_keys : dict [ str , str ], platform : str ) -> None : \"\"\"Initialize Keys object. Args: platform_keys: A dictionary of platform-specific keys. platform: The platform the program is running on. \"\"\" self . _keys = { \"SPACE\" : \" \" , \"ESC\" : \" \\x1b \" , # The ALT character in key combinations is the same as ESC \"ALT\" : \" \\x1b \" , \"TAB\" : \" \\t \" , \"ENTER\" : \" \\n \" , \"RETURN\" : \" \\n \" , \"CTRL_SPACE\" : \" \\x00 \" , \"CTRL_A\" : \" \\x01 \" , \"CTRL_B\" : \" \\x02 \" , \"CTRL_C\" : \" \\x03 \" , \"CTRL_D\" : \" \\x04 \" , \"CTRL_E\" : \" \\x05 \" , \"CTRL_F\" : \" \\x06 \" , \"CTRL_G\" : \" \\x07 \" , \"CTRL_H\" : \" \\x08 \" , \"CTRL_I\" : \" \\t \" , \"CTRL_J\" : \" \\n \" , \"CTRL_K\" : \" \\x0b \" , \"CTRL_L\" : \" \\x0c \" , \"CTRL_M\" : \" \\r \" , \"CTRL_N\" : \" \\x0e \" , \"CTRL_O\" : \" \\x0f \" , \"CTRL_P\" : \" \\x10 \" , \"CTRL_Q\" : \" \\x11 \" , \"CTRL_R\" : \" \\x12 \" , \"CTRL_S\" : \" \\x13 \" , \"CTRL_T\" : \" \\x14 \" , \"CTRL_U\" : \" \\x15 \" , \"CTRL_V\" : \" \\x16 \" , \"CTRL_W\" : \" \\x17 \" , \"CTRL_X\" : \" \\x18 \" , \"CTRL_Y\" : \" \\x19 \" , \"CTRL_Z\" : \" \\x1a \" , } self . platform = platform if platform_keys is not None : for key , code in platform_keys . items (): if key == \"name\" : self . name = code continue self . _keys [ key ] = code def __getattr__ ( self , attr : str ) -> str : \"\"\"Gets attr from self._keys.\"\"\" if attr == \"ANY_KEY\" : return attr return self . _keys . get ( attr , \"\" ) def get_name ( self , key : str , default : Optional [ str ] = None ) -> Optional [ str ]: \"\"\"Gets canonical name of a key code. Args: key: The key to get the name of. default: The return value to substitute if no canonical name could be found. Defaults to None. Returns: The canonical name if one can be found, default otherwise. \"\"\" for name , value in self . _keys . items (): if key == value : return name return default def values ( self ) -> ValuesView [ str ]: \"\"\"Returns values() of self._keys.\"\"\" return self . _keys . values () def keys ( self ) -> KeysView [ str ]: \"\"\"Returns keys() of self._keys.\"\"\" return self . _keys . keys () def items ( self ) -> ItemsView [ str , str ]: \"\"\"Returns items() of self._keys.\"\"\" return self . _keys . items ()","title":"Keys"},{"location":"reference/pytermgui/input/#pytermgui.input.Keys.__getattr__","text":"Gets attr from self._keys. Source code in pytermgui/input.py 268 269 270 271 272 273 274 def __getattr__ ( self , attr : str ) -> str : \"\"\"Gets attr from self._keys.\"\"\" if attr == \"ANY_KEY\" : return attr return self . _keys . get ( attr , \"\" )","title":"__getattr__()"},{"location":"reference/pytermgui/input/#pytermgui.input.Keys.__init__","text":"Initialize Keys object. Parameters: Name Type Description Default platform_keys dict [ str , str ] A dictionary of platform-specific keys. required platform str The platform the program is running on. required Source code in pytermgui/input.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def __init__ ( self , platform_keys : dict [ str , str ], platform : str ) -> None : \"\"\"Initialize Keys object. Args: platform_keys: A dictionary of platform-specific keys. platform: The platform the program is running on. \"\"\" self . _keys = { \"SPACE\" : \" \" , \"ESC\" : \" \\x1b \" , # The ALT character in key combinations is the same as ESC \"ALT\" : \" \\x1b \" , \"TAB\" : \" \\t \" , \"ENTER\" : \" \\n \" , \"RETURN\" : \" \\n \" , \"CTRL_SPACE\" : \" \\x00 \" , \"CTRL_A\" : \" \\x01 \" , \"CTRL_B\" : \" \\x02 \" , \"CTRL_C\" : \" \\x03 \" , \"CTRL_D\" : \" \\x04 \" , \"CTRL_E\" : \" \\x05 \" , \"CTRL_F\" : \" \\x06 \" , \"CTRL_G\" : \" \\x07 \" , \"CTRL_H\" : \" \\x08 \" , \"CTRL_I\" : \" \\t \" , \"CTRL_J\" : \" \\n \" , \"CTRL_K\" : \" \\x0b \" , \"CTRL_L\" : \" \\x0c \" , \"CTRL_M\" : \" \\r \" , \"CTRL_N\" : \" \\x0e \" , \"CTRL_O\" : \" \\x0f \" , \"CTRL_P\" : \" \\x10 \" , \"CTRL_Q\" : \" \\x11 \" , \"CTRL_R\" : \" \\x12 \" , \"CTRL_S\" : \" \\x13 \" , \"CTRL_T\" : \" \\x14 \" , \"CTRL_U\" : \" \\x15 \" , \"CTRL_V\" : \" \\x16 \" , \"CTRL_W\" : \" \\x17 \" , \"CTRL_X\" : \" \\x18 \" , \"CTRL_Y\" : \" \\x19 \" , \"CTRL_Z\" : \" \\x1a \" , } self . platform = platform if platform_keys is not None : for key , code in platform_keys . items (): if key == \"name\" : self . name = code continue self . _keys [ key ] = code","title":"__init__()"},{"location":"reference/pytermgui/input/#pytermgui.input.Keys.get_name","text":"Gets canonical name of a key code. Parameters: Name Type Description Default key str The key to get the name of. required default Optional [ str ] The return value to substitute if no canonical name could be found. Defaults to None. None Returns: Type Description Optional [ str ] The canonical name if one can be found, default otherwise. Source code in pytermgui/input.py 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 def get_name ( self , key : str , default : Optional [ str ] = None ) -> Optional [ str ]: \"\"\"Gets canonical name of a key code. Args: key: The key to get the name of. default: The return value to substitute if no canonical name could be found. Defaults to None. Returns: The canonical name if one can be found, default otherwise. \"\"\" for name , value in self . _keys . items (): if key == value : return name return default","title":"get_name()"},{"location":"reference/pytermgui/input/#pytermgui.input.Keys.items","text":"Returns items() of self._keys. Source code in pytermgui/input.py 304 305 306 307 def items ( self ) -> ItemsView [ str , str ]: \"\"\"Returns items() of self._keys.\"\"\" return self . _keys . items ()","title":"items()"},{"location":"reference/pytermgui/input/#pytermgui.input.Keys.keys","text":"Returns keys() of self._keys. Source code in pytermgui/input.py 299 300 301 302 def keys ( self ) -> KeysView [ str ]: \"\"\"Returns keys() of self._keys.\"\"\" return self . _keys . keys ()","title":"keys()"},{"location":"reference/pytermgui/input/#pytermgui.input.Keys.values","text":"Returns values() of self._keys. Source code in pytermgui/input.py 294 295 296 297 def values ( self ) -> ValuesView [ str ]: \"\"\"Returns values() of self._keys.\"\"\" return self . _keys . values ()","title":"values()"},{"location":"reference/pytermgui/input/#pytermgui.input.getch","text":"Wrapper to call the platform-appropriate character getter. Parameters: Name Type Description Default printable bool When set, printable versions of the input are returned. False interrupts bool If not set, KeyboardInterrupt is silenced and chr(3) ( CTRL_C ) is returned. True Source code in pytermgui/input.py 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 def getch ( printable : bool = False , interrupts : bool = True ) -> Any : \"\"\"Wrapper to call the platform-appropriate character getter. Args: printable: When set, printable versions of the input are returned. interrupts: If not set, `KeyboardInterrupt` is silenced and `chr(3)` (`CTRL_C`) is returned. \"\"\" try : key = _getch () # msvcrt.getch returns CTRL_C as a character, unlike UNIX systems # where an interrupt is raised. Thus, we need to manually raise # the interrupt. if key == chr ( 3 ): raise KeyboardInterrupt except KeyboardInterrupt as error : if interrupts : raise KeyboardInterrupt ( \"Unhandled interrupt\" ) from error key = chr ( 3 ) if printable : key = key . encode ( \"unicode_escape\" ) . decode ( \"utf-8\" ) return key","title":"getch()"},{"location":"reference/pytermgui/input/#pytermgui.input.getch_timeout","text":"Calls getch , returns default if timeout passes before getting input. No timeout is applied on Windows systems, as there is no support for SIGALRM . Parameters: Name Type Description Default duration float How long the call should wait for input. required default str The value to return if timeout occured. '' Source code in pytermgui/input.py 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 def getch_timeout ( duration : float , default : str = \"\" , printable : bool = False , interrupts : bool = True ) -> Any : \"\"\"Calls `getch`, returns `default` if timeout passes before getting input. No timeout is applied on Windows systems, as there is no support for `SIGALRM`. Args: duration: How long the call should wait for input. default: The value to return if timeout occured. \"\"\" if isinstance ( _getch , _GetchWindows ): return getch () with timeout ( duration ): return getch ( printable = printable , interrupts = interrupts ) return default","title":"getch_timeout()"},{"location":"reference/pytermgui/input/#pytermgui.input.timeout","text":"Allows context to run for a certain amount of time, quits it once it's up. Note that this should never be run on Windows, as the required signals are not present. Whenever this function is run, there should be a preliminary OS check, to avoid running into issues on unsupported machines. Source code in pytermgui/input.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @contextmanager def timeout ( duration : float ) -> Generator [ None , None , None ]: \"\"\"Allows context to run for a certain amount of time, quits it once it's up. Note that this should never be run on Windows, as the required signals are not present. Whenever this function is run, there should be a preliminary OS check, to avoid running into issues on unsupported machines. \"\"\" def _raise_timeout ( * _ , ** __ ): raise TimeoutException ( \"The action has timed out.\" ) try : # set the timeout handler signal . signal ( signal . SIGALRM , _raise_timeout ) signal . setitimer ( signal . ITIMER_REAL , duration ) yield except TimeoutException : pass finally : signal . alarm ( 0 )","title":"timeout()"},{"location":"reference/pytermgui/inspector/","text":"This module provides introspection utilities. The inspect method can be used to create an Inspector widget, which can then be used to see what is happening inside any python object. This method is usually preferred for instantiating an Inspector , as it sets up overwriteable default arguments passed to the new widget. These defaults are meant to hide the non-important information when they are not needed, in order to allow the least amount of code for the most usability. For example, by default, when passed a class, inspect will clip the docstrings to their first lines, but show all methods. When an class' method is given it will hide show the full docstring, and also use the method's fully qualified name. Inspector Bases: Container A widget to inspect any Python object. Source code in pytermgui/inspector.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 class Inspector ( Container ): \"\"\"A widget to inspect any Python object.\"\"\" def __init__ ( # pylint: disable=too-many-arguments self , target : object = None , show_private : bool = False , show_dunder : bool = False , show_methods : bool = False , show_full_doc : bool = False , show_qualname : bool = True , show_header : bool = True , ** attrs : Any , ): \"\"\"Initializes an inspector. Note that most of the time, using `inspect` to do this is going to be more useful. Some styles of the inspector can be changed using the `code.name`, `code.file` and `code.keyword` markup aliases. The rest of the highlighting is done using `pprint`, with all of its respective colors. Args: show_private: Whether `_private` attributes should be shown. show_dunder: Whether `__dunder__` attributes should be shown. show_methods: Whether methods should be shown when encountering a class. show_full_doc: If not set, docstrings are cut to only include their first line. show_qualname: Show fully-qualified name, e.g. `module.submodule.name` instead of `name`. show_header: If not set, the header containing the path to the object and its qualname will not be added. \"\"\" if \"box\" not in attrs : attrs [ \"box\" ] = \"EMPTY\" super () . __init__ ( ** attrs ) self . width = self . terminal . width self . show_private = show_private self . show_dunder = show_dunder self . show_methods = show_methods self . show_full_doc = show_full_doc self . show_qualname = show_qualname self . show_header = show_header # TODO: Fix attr-showing self . show_attrs = False self . target : object if target is not None : self . inspect ( target ) self . target = target def _get_header ( self ) -> Container : \"\"\"Creates a header containing the name and location of the object.\"\"\" header = Container ( box = \"SINGLE\" ) line = \"[code.name]\" if self . target_type is ObjectType . MODULE : line += self . target . __name__ # type: ignore else : cls = ( self . target if isclass ( self . target ) or isfunction ( self . target ) else self . target . __class__ ) line += cls . __module__ + \".\" + cls . __qualname__ # type: ignore header += line try : file = getfile ( self . target ) # type: ignore except TypeError : return header header += f \"Located in [code.file ~file:// { file } ] { file } [/]\" return header def _get_definition ( self ) -> Label : \"\"\"Returns the definition str of self.target.\"\"\" target = self . target if self . show_qualname : name = getattr ( target , \"__qualname__\" , type ( target ) . __name__ ) else : name = getattr ( target , \"__name__\" , type ( target ) . __name__ ) if self . target_type == ObjectType . LIVE : target = type ( target ) otype = _determine_type ( target ) keyword = \"\" if otype == ObjectType . CLASS : keyword = \"class \" elif otype == ObjectType . FUNCTION : keyword = \"def \" try : assert callable ( target ) definition = self . highlight ( keyword + name + str ( signature ( target )) + \":\" ) except ( TypeError , ValueError , AssertionError ): definition = self . highlight ( keyword + name + \"(...)\" ) return Label ( definition , parent_align = 0 , non_first_padding = 4 ) def _get_docs ( self , padding : int ) -> Label : \"\"\"Returns a list of Labels of the object's documentation.\"\"\" default = Label ( \"...\" , style = \"102\" ) if self . target . __doc__ is None : return default doc = getdoc ( self . target ) if doc is None : return default lines = doc . splitlines () if not self . show_full_doc and len ( lines ) > 0 : lines = [ lines [ 0 ]] trimmed = \" \\n \" . join ( lines ) return Label ( trimmed . replace ( \"[\" , r \"\\[\" ), style = \"102\" , parent_align = 0 , padding = padding , ) def _get_keys ( self ) -> list [ str ]: \"\"\"Gets all inspectable keys of an object. It first checks for an `__all__` attribute, and substitutes `dir` if not found. Then, if there are too many keys and the given target is a module it tries to list all of the present submodules. \"\"\" keys = getattr ( self . target , \"__all__\" , dir ( self . target )) if not self . show_dunder : keys = [ key for key in keys if not key . startswith ( \"__\" )] if not self . show_private : keys = [ key for key in keys if not ( key . startswith ( \"_\" ) and key [ 1 ] != \"_\" )] if not self . show_methods : keys = [ key for key in keys if not callable ( getattr ( self . target , key , None )) ] keys . sort ( key = lambda item : callable ( getattr ( self . target , item , None ))) return keys def _get_preview ( self ) -> Container : \"\"\"Gets a Container with self.target inside.\"\"\" preview = Container ( static_width = self . width // 2 , parent_align = 0 , box = \"SINGLE\" ) if isinstance ( self . target , str ) and RE_MARKUP . match ( self . target ) is not None : preview += Label ( prettify ( self . target , parse = False ), parent_align = 0 ) return preview for line in prettify ( self . target ) . splitlines (): if real_length ( line ) > preview . width - preview . sidelength : preview . width = real_length ( line ) + preview . sidelength preview += Label ( tim . get_markup ( line ), parent_align = 0 ) preview . width = min ( preview . width , self . terminal . width - preview . sidelength ) return preview @staticmethod def highlight ( text : str ) -> str : \"\"\"Applies highlighting to a given string. This highlight includes keywords, builtin types and more. Args: text: The string to highlight. Returns: Unparsed markup. \"\"\" def _split ( text : str , chars : str = \" ,:|()[] {} \" ) -> list [ tuple [ str , str ]]: \"\"\"Splits given text by the given chars. Args: text: The text to split. chars: A string of characters we will split by. Returns: A tuple of (delimiter, word) tuples. Delimiter is one of the characters of `chars`. \"\"\" last_delim = \"\" output = [] word = \"\" for char in text : if char in chars : output . append (( last_delim , word )) last_delim = char word = \"\" continue word += char output . append (( last_delim , word )) return output buff = \"\" for ( delim , word ) in _split ( text ): stripped = word . strip ( \"'\" ) highlighted = highlight_python ( stripped ) if highlighted != stripped : buff += delim + stripped continue buff += delim + stripped return highlight_python ( buff ) def inspect ( self , target : object ) -> Inspector : \"\"\"Inspects a given object, and sets self.target to it. Returns: Self, with the new content based on the inspection. \"\"\" self . target = target self . target_type = _determine_type ( target ) # Header if self . show_header and self . box is not INDENTED_EMPTY_BOX : self . lazy_add ( self . _get_header ()) # Body if self . target_type is not ObjectType . MODULE : self . lazy_add ( self . _get_definition ()) padding = 0 if self . target_type is ObjectType . MODULE else 4 self . lazy_add ( self . _get_docs ( padding )) keys = self . _get_keys () for key in keys : attr = getattr ( target , key , None ) # Don't show type aliases if _is_type_alias ( attr ): continue # Only show functions if they are not lambdas if ( isfunction ( attr ) or callable ( attr )) and ( hasattr ( attr , \"__name__\" ) and not attr . __name__ == \"<lambda>\" ): self . lazy_add ( Inspector ( box = INDENTED_EMPTY_BOX , show_dunder = self . show_dunder , show_private = self . show_private , show_full_doc = False , show_qualname = self . show_qualname , ) . inspect ( attr ) ) continue if not self . show_attrs : continue for i , line in enumerate ( prettify ( attr , parse = False ) . splitlines ()): if i == 0 : line = f \"- { key } : { line } \" self . lazy_add ( Label ( line , parent_align = 0 )) # Footer if self . target_type in [ ObjectType . LIVE , ObjectType . BUILTIN ]: self . lazy_add ( self . _get_preview ()) return self def debug ( self ) -> str : \"\"\"Returns identifiable information used in repr.\"\"\" if self . terminal . is_interactive and not self . terminal . displayhook_installed : return \" \\n \" . join ( self . get_lines ()) return Widget . debug ( self ) __init__ ( target = None , show_private = False , show_dunder = False , show_methods = False , show_full_doc = False , show_qualname = True , show_header = True , attrs ) Initializes an inspector. Note that most of the time, using inspect to do this is going to be more useful. Some styles of the inspector can be changed using the code.name , code.file and code.keyword markup aliases. The rest of the highlighting is done using pprint , with all of its respective colors. Parameters: Name Type Description Default show_private bool Whether _private attributes should be shown. False show_dunder bool Whether __dunder__ attributes should be shown. False show_methods bool Whether methods should be shown when encountering a class. False show_full_doc bool If not set, docstrings are cut to only include their first line. False show_qualname bool Show fully-qualified name, e.g. module.submodule.name instead of name . True show_header bool If not set, the header containing the path to the object and its qualname will not be added. True Source code in pytermgui/inspector.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 def __init__ ( # pylint: disable=too-many-arguments self , target : object = None , show_private : bool = False , show_dunder : bool = False , show_methods : bool = False , show_full_doc : bool = False , show_qualname : bool = True , show_header : bool = True , ** attrs : Any , ): \"\"\"Initializes an inspector. Note that most of the time, using `inspect` to do this is going to be more useful. Some styles of the inspector can be changed using the `code.name`, `code.file` and `code.keyword` markup aliases. The rest of the highlighting is done using `pprint`, with all of its respective colors. Args: show_private: Whether `_private` attributes should be shown. show_dunder: Whether `__dunder__` attributes should be shown. show_methods: Whether methods should be shown when encountering a class. show_full_doc: If not set, docstrings are cut to only include their first line. show_qualname: Show fully-qualified name, e.g. `module.submodule.name` instead of `name`. show_header: If not set, the header containing the path to the object and its qualname will not be added. \"\"\" if \"box\" not in attrs : attrs [ \"box\" ] = \"EMPTY\" super () . __init__ ( ** attrs ) self . width = self . terminal . width self . show_private = show_private self . show_dunder = show_dunder self . show_methods = show_methods self . show_full_doc = show_full_doc self . show_qualname = show_qualname self . show_header = show_header # TODO: Fix attr-showing self . show_attrs = False self . target : object if target is not None : self . inspect ( target ) self . target = target debug () Returns identifiable information used in repr. Source code in pytermgui/inspector.py 474 475 476 477 478 479 480 def debug ( self ) -> str : \"\"\"Returns identifiable information used in repr.\"\"\" if self . terminal . is_interactive and not self . terminal . displayhook_installed : return \" \\n \" . join ( self . get_lines ()) return Widget . debug ( self ) highlight ( text ) staticmethod Applies highlighting to a given string. This highlight includes keywords, builtin types and more. Parameters: Name Type Description Default text str The string to highlight. required Returns: Type Description str Unparsed markup. Source code in pytermgui/inspector.py 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 @staticmethod def highlight ( text : str ) -> str : \"\"\"Applies highlighting to a given string. This highlight includes keywords, builtin types and more. Args: text: The string to highlight. Returns: Unparsed markup. \"\"\" def _split ( text : str , chars : str = \" ,:|()[] {} \" ) -> list [ tuple [ str , str ]]: \"\"\"Splits given text by the given chars. Args: text: The text to split. chars: A string of characters we will split by. Returns: A tuple of (delimiter, word) tuples. Delimiter is one of the characters of `chars`. \"\"\" last_delim = \"\" output = [] word = \"\" for char in text : if char in chars : output . append (( last_delim , word )) last_delim = char word = \"\" continue word += char output . append (( last_delim , word )) return output buff = \"\" for ( delim , word ) in _split ( text ): stripped = word . strip ( \"'\" ) highlighted = highlight_python ( stripped ) if highlighted != stripped : buff += delim + stripped continue buff += delim + stripped return highlight_python ( buff ) inspect ( target ) Inspects a given object, and sets self.target to it. Returns: Type Description Inspector Self, with the new content based on the inspection. Source code in pytermgui/inspector.py 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 def inspect ( self , target : object ) -> Inspector : \"\"\"Inspects a given object, and sets self.target to it. Returns: Self, with the new content based on the inspection. \"\"\" self . target = target self . target_type = _determine_type ( target ) # Header if self . show_header and self . box is not INDENTED_EMPTY_BOX : self . lazy_add ( self . _get_header ()) # Body if self . target_type is not ObjectType . MODULE : self . lazy_add ( self . _get_definition ()) padding = 0 if self . target_type is ObjectType . MODULE else 4 self . lazy_add ( self . _get_docs ( padding )) keys = self . _get_keys () for key in keys : attr = getattr ( target , key , None ) # Don't show type aliases if _is_type_alias ( attr ): continue # Only show functions if they are not lambdas if ( isfunction ( attr ) or callable ( attr )) and ( hasattr ( attr , \"__name__\" ) and not attr . __name__ == \"<lambda>\" ): self . lazy_add ( Inspector ( box = INDENTED_EMPTY_BOX , show_dunder = self . show_dunder , show_private = self . show_private , show_full_doc = False , show_qualname = self . show_qualname , ) . inspect ( attr ) ) continue if not self . show_attrs : continue for i , line in enumerate ( prettify ( attr , parse = False ) . splitlines ()): if i == 0 : line = f \"- { key } : { line } \" self . lazy_add ( Label ( line , parent_align = 0 )) # Footer if self . target_type in [ ObjectType . LIVE , ObjectType . BUILTIN ]: self . lazy_add ( self . _get_preview ()) return self ObjectType Bases: Enum All types an object can be. Source code in pytermgui/inspector.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class ObjectType ( Enum ): \"\"\"All types an object can be.\"\"\" LIVE = _auto () \"\"\"An instance that does not fit the other types.\"\"\" CLASS = _auto () \"\"\"A class object.\"\"\" MODULE = _auto () \"\"\"A module object.\"\"\" BUILTIN = _auto () \"\"\"Some sort of a builtin object. As builtins are often implemented in C, a lot of the standard python APIs won't work on them, so we need to treat them separately.\"\"\" FUNCTION = _auto () \"\"\"A callable object, that is not a class.\"\"\" BUILTIN = _auto () class-attribute Some sort of a builtin object. As builtins are often implemented in C, a lot of the standard python APIs won't work on them, so we need to treat them separately. CLASS = _auto () class-attribute A class object. FUNCTION = _auto () class-attribute A callable object, that is not a class. LIVE = _auto () class-attribute An instance that does not fit the other types. MODULE = _auto () class-attribute A module object. get_origin ( _ ) Spoofs typing.get_origin, which is used to determine type-hints. Since this function is only available >=3.8, we need to have some implementation on it for 3.7. The code checks for the origin to be non-null, as that is the value returned by this method on non-typing objects. This will cause annotations to show up on 3.7, but not on 3.8+. Source code in pytermgui/inspector.py 38 39 40 41 42 43 44 45 46 47 48 49 def get_origin ( _ : object ) -> Any : # type: ignore \"\"\"Spoofs typing.get_origin, which is used to determine type-hints. Since this function is only available >=3.8, we need to have some implementation on it for 3.7. The code checks for the origin to be non-null, as that is the value returned by this method on non-typing objects. This will cause annotations to show up on 3.7, but not on 3.8+. \"\"\" return None inspect ( target , inspector_args ) Inspects an object. Parameters: Name Type Description Default target object The object to inspect. required **inspector_args Any See Inspector.__init__ . {} Source code in pytermgui/inspector.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def inspect ( target : object , ** inspector_args : Any ) -> Inspector : \"\"\"Inspects an object. Args: target: The object to inspect. **inspector_args: See `Inspector.__init__`. \"\"\" def _conditionally_overwrite_kwarg ( ** kwargs ) -> None : for key , value in kwargs . items (): if inspector_args . get ( key ) is None : inspector_args [ key ] = value if ismodule ( target ): _conditionally_overwrite_kwarg ( show_dunder = False , show_private = False , show_full_doc = False , show_methods = True , show_qualname = False , ) elif isclass ( target ): _conditionally_overwrite_kwarg ( show_dunder = False , show_private = False , show_full_doc = True , show_methods = True , show_qualname = False , ) elif callable ( target ) or isbuiltin ( target ): _conditionally_overwrite_kwarg ( show_dunder = False , show_private = False , show_full_doc = True , show_methods = False , show_qualname = True , ) else : _conditionally_overwrite_kwarg ( show_dunder = False , show_private = False , show_full_doc = True , show_methods = True , show_qualname = False , ) inspector = Inspector ( ** inspector_args ) . inspect ( target ) return inspector","title":"inspector"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.Inspector","text":"Bases: Container A widget to inspect any Python object. Source code in pytermgui/inspector.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 class Inspector ( Container ): \"\"\"A widget to inspect any Python object.\"\"\" def __init__ ( # pylint: disable=too-many-arguments self , target : object = None , show_private : bool = False , show_dunder : bool = False , show_methods : bool = False , show_full_doc : bool = False , show_qualname : bool = True , show_header : bool = True , ** attrs : Any , ): \"\"\"Initializes an inspector. Note that most of the time, using `inspect` to do this is going to be more useful. Some styles of the inspector can be changed using the `code.name`, `code.file` and `code.keyword` markup aliases. The rest of the highlighting is done using `pprint`, with all of its respective colors. Args: show_private: Whether `_private` attributes should be shown. show_dunder: Whether `__dunder__` attributes should be shown. show_methods: Whether methods should be shown when encountering a class. show_full_doc: If not set, docstrings are cut to only include their first line. show_qualname: Show fully-qualified name, e.g. `module.submodule.name` instead of `name`. show_header: If not set, the header containing the path to the object and its qualname will not be added. \"\"\" if \"box\" not in attrs : attrs [ \"box\" ] = \"EMPTY\" super () . __init__ ( ** attrs ) self . width = self . terminal . width self . show_private = show_private self . show_dunder = show_dunder self . show_methods = show_methods self . show_full_doc = show_full_doc self . show_qualname = show_qualname self . show_header = show_header # TODO: Fix attr-showing self . show_attrs = False self . target : object if target is not None : self . inspect ( target ) self . target = target def _get_header ( self ) -> Container : \"\"\"Creates a header containing the name and location of the object.\"\"\" header = Container ( box = \"SINGLE\" ) line = \"[code.name]\" if self . target_type is ObjectType . MODULE : line += self . target . __name__ # type: ignore else : cls = ( self . target if isclass ( self . target ) or isfunction ( self . target ) else self . target . __class__ ) line += cls . __module__ + \".\" + cls . __qualname__ # type: ignore header += line try : file = getfile ( self . target ) # type: ignore except TypeError : return header header += f \"Located in [code.file ~file:// { file } ] { file } [/]\" return header def _get_definition ( self ) -> Label : \"\"\"Returns the definition str of self.target.\"\"\" target = self . target if self . show_qualname : name = getattr ( target , \"__qualname__\" , type ( target ) . __name__ ) else : name = getattr ( target , \"__name__\" , type ( target ) . __name__ ) if self . target_type == ObjectType . LIVE : target = type ( target ) otype = _determine_type ( target ) keyword = \"\" if otype == ObjectType . CLASS : keyword = \"class \" elif otype == ObjectType . FUNCTION : keyword = \"def \" try : assert callable ( target ) definition = self . highlight ( keyword + name + str ( signature ( target )) + \":\" ) except ( TypeError , ValueError , AssertionError ): definition = self . highlight ( keyword + name + \"(...)\" ) return Label ( definition , parent_align = 0 , non_first_padding = 4 ) def _get_docs ( self , padding : int ) -> Label : \"\"\"Returns a list of Labels of the object's documentation.\"\"\" default = Label ( \"...\" , style = \"102\" ) if self . target . __doc__ is None : return default doc = getdoc ( self . target ) if doc is None : return default lines = doc . splitlines () if not self . show_full_doc and len ( lines ) > 0 : lines = [ lines [ 0 ]] trimmed = \" \\n \" . join ( lines ) return Label ( trimmed . replace ( \"[\" , r \"\\[\" ), style = \"102\" , parent_align = 0 , padding = padding , ) def _get_keys ( self ) -> list [ str ]: \"\"\"Gets all inspectable keys of an object. It first checks for an `__all__` attribute, and substitutes `dir` if not found. Then, if there are too many keys and the given target is a module it tries to list all of the present submodules. \"\"\" keys = getattr ( self . target , \"__all__\" , dir ( self . target )) if not self . show_dunder : keys = [ key for key in keys if not key . startswith ( \"__\" )] if not self . show_private : keys = [ key for key in keys if not ( key . startswith ( \"_\" ) and key [ 1 ] != \"_\" )] if not self . show_methods : keys = [ key for key in keys if not callable ( getattr ( self . target , key , None )) ] keys . sort ( key = lambda item : callable ( getattr ( self . target , item , None ))) return keys def _get_preview ( self ) -> Container : \"\"\"Gets a Container with self.target inside.\"\"\" preview = Container ( static_width = self . width // 2 , parent_align = 0 , box = \"SINGLE\" ) if isinstance ( self . target , str ) and RE_MARKUP . match ( self . target ) is not None : preview += Label ( prettify ( self . target , parse = False ), parent_align = 0 ) return preview for line in prettify ( self . target ) . splitlines (): if real_length ( line ) > preview . width - preview . sidelength : preview . width = real_length ( line ) + preview . sidelength preview += Label ( tim . get_markup ( line ), parent_align = 0 ) preview . width = min ( preview . width , self . terminal . width - preview . sidelength ) return preview @staticmethod def highlight ( text : str ) -> str : \"\"\"Applies highlighting to a given string. This highlight includes keywords, builtin types and more. Args: text: The string to highlight. Returns: Unparsed markup. \"\"\" def _split ( text : str , chars : str = \" ,:|()[] {} \" ) -> list [ tuple [ str , str ]]: \"\"\"Splits given text by the given chars. Args: text: The text to split. chars: A string of characters we will split by. Returns: A tuple of (delimiter, word) tuples. Delimiter is one of the characters of `chars`. \"\"\" last_delim = \"\" output = [] word = \"\" for char in text : if char in chars : output . append (( last_delim , word )) last_delim = char word = \"\" continue word += char output . append (( last_delim , word )) return output buff = \"\" for ( delim , word ) in _split ( text ): stripped = word . strip ( \"'\" ) highlighted = highlight_python ( stripped ) if highlighted != stripped : buff += delim + stripped continue buff += delim + stripped return highlight_python ( buff ) def inspect ( self , target : object ) -> Inspector : \"\"\"Inspects a given object, and sets self.target to it. Returns: Self, with the new content based on the inspection. \"\"\" self . target = target self . target_type = _determine_type ( target ) # Header if self . show_header and self . box is not INDENTED_EMPTY_BOX : self . lazy_add ( self . _get_header ()) # Body if self . target_type is not ObjectType . MODULE : self . lazy_add ( self . _get_definition ()) padding = 0 if self . target_type is ObjectType . MODULE else 4 self . lazy_add ( self . _get_docs ( padding )) keys = self . _get_keys () for key in keys : attr = getattr ( target , key , None ) # Don't show type aliases if _is_type_alias ( attr ): continue # Only show functions if they are not lambdas if ( isfunction ( attr ) or callable ( attr )) and ( hasattr ( attr , \"__name__\" ) and not attr . __name__ == \"<lambda>\" ): self . lazy_add ( Inspector ( box = INDENTED_EMPTY_BOX , show_dunder = self . show_dunder , show_private = self . show_private , show_full_doc = False , show_qualname = self . show_qualname , ) . inspect ( attr ) ) continue if not self . show_attrs : continue for i , line in enumerate ( prettify ( attr , parse = False ) . splitlines ()): if i == 0 : line = f \"- { key } : { line } \" self . lazy_add ( Label ( line , parent_align = 0 )) # Footer if self . target_type in [ ObjectType . LIVE , ObjectType . BUILTIN ]: self . lazy_add ( self . _get_preview ()) return self def debug ( self ) -> str : \"\"\"Returns identifiable information used in repr.\"\"\" if self . terminal . is_interactive and not self . terminal . displayhook_installed : return \" \\n \" . join ( self . get_lines ()) return Widget . debug ( self )","title":"Inspector"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.Inspector.__init__","text":"Initializes an inspector. Note that most of the time, using inspect to do this is going to be more useful. Some styles of the inspector can be changed using the code.name , code.file and code.keyword markup aliases. The rest of the highlighting is done using pprint , with all of its respective colors. Parameters: Name Type Description Default show_private bool Whether _private attributes should be shown. False show_dunder bool Whether __dunder__ attributes should be shown. False show_methods bool Whether methods should be shown when encountering a class. False show_full_doc bool If not set, docstrings are cut to only include their first line. False show_qualname bool Show fully-qualified name, e.g. module.submodule.name instead of name . True show_header bool If not set, the header containing the path to the object and its qualname will not be added. True Source code in pytermgui/inspector.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 def __init__ ( # pylint: disable=too-many-arguments self , target : object = None , show_private : bool = False , show_dunder : bool = False , show_methods : bool = False , show_full_doc : bool = False , show_qualname : bool = True , show_header : bool = True , ** attrs : Any , ): \"\"\"Initializes an inspector. Note that most of the time, using `inspect` to do this is going to be more useful. Some styles of the inspector can be changed using the `code.name`, `code.file` and `code.keyword` markup aliases. The rest of the highlighting is done using `pprint`, with all of its respective colors. Args: show_private: Whether `_private` attributes should be shown. show_dunder: Whether `__dunder__` attributes should be shown. show_methods: Whether methods should be shown when encountering a class. show_full_doc: If not set, docstrings are cut to only include their first line. show_qualname: Show fully-qualified name, e.g. `module.submodule.name` instead of `name`. show_header: If not set, the header containing the path to the object and its qualname will not be added. \"\"\" if \"box\" not in attrs : attrs [ \"box\" ] = \"EMPTY\" super () . __init__ ( ** attrs ) self . width = self . terminal . width self . show_private = show_private self . show_dunder = show_dunder self . show_methods = show_methods self . show_full_doc = show_full_doc self . show_qualname = show_qualname self . show_header = show_header # TODO: Fix attr-showing self . show_attrs = False self . target : object if target is not None : self . inspect ( target ) self . target = target","title":"__init__()"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.Inspector.debug","text":"Returns identifiable information used in repr. Source code in pytermgui/inspector.py 474 475 476 477 478 479 480 def debug ( self ) -> str : \"\"\"Returns identifiable information used in repr.\"\"\" if self . terminal . is_interactive and not self . terminal . displayhook_installed : return \" \\n \" . join ( self . get_lines ()) return Widget . debug ( self )","title":"debug()"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.Inspector.highlight","text":"Applies highlighting to a given string. This highlight includes keywords, builtin types and more. Parameters: Name Type Description Default text str The string to highlight. required Returns: Type Description str Unparsed markup. Source code in pytermgui/inspector.py 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 @staticmethod def highlight ( text : str ) -> str : \"\"\"Applies highlighting to a given string. This highlight includes keywords, builtin types and more. Args: text: The string to highlight. Returns: Unparsed markup. \"\"\" def _split ( text : str , chars : str = \" ,:|()[] {} \" ) -> list [ tuple [ str , str ]]: \"\"\"Splits given text by the given chars. Args: text: The text to split. chars: A string of characters we will split by. Returns: A tuple of (delimiter, word) tuples. Delimiter is one of the characters of `chars`. \"\"\" last_delim = \"\" output = [] word = \"\" for char in text : if char in chars : output . append (( last_delim , word )) last_delim = char word = \"\" continue word += char output . append (( last_delim , word )) return output buff = \"\" for ( delim , word ) in _split ( text ): stripped = word . strip ( \"'\" ) highlighted = highlight_python ( stripped ) if highlighted != stripped : buff += delim + stripped continue buff += delim + stripped return highlight_python ( buff )","title":"highlight()"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.Inspector.inspect","text":"Inspects a given object, and sets self.target to it. Returns: Type Description Inspector Self, with the new content based on the inspection. Source code in pytermgui/inspector.py 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 def inspect ( self , target : object ) -> Inspector : \"\"\"Inspects a given object, and sets self.target to it. Returns: Self, with the new content based on the inspection. \"\"\" self . target = target self . target_type = _determine_type ( target ) # Header if self . show_header and self . box is not INDENTED_EMPTY_BOX : self . lazy_add ( self . _get_header ()) # Body if self . target_type is not ObjectType . MODULE : self . lazy_add ( self . _get_definition ()) padding = 0 if self . target_type is ObjectType . MODULE else 4 self . lazy_add ( self . _get_docs ( padding )) keys = self . _get_keys () for key in keys : attr = getattr ( target , key , None ) # Don't show type aliases if _is_type_alias ( attr ): continue # Only show functions if they are not lambdas if ( isfunction ( attr ) or callable ( attr )) and ( hasattr ( attr , \"__name__\" ) and not attr . __name__ == \"<lambda>\" ): self . lazy_add ( Inspector ( box = INDENTED_EMPTY_BOX , show_dunder = self . show_dunder , show_private = self . show_private , show_full_doc = False , show_qualname = self . show_qualname , ) . inspect ( attr ) ) continue if not self . show_attrs : continue for i , line in enumerate ( prettify ( attr , parse = False ) . splitlines ()): if i == 0 : line = f \"- { key } : { line } \" self . lazy_add ( Label ( line , parent_align = 0 )) # Footer if self . target_type in [ ObjectType . LIVE , ObjectType . BUILTIN ]: self . lazy_add ( self . _get_preview ()) return self","title":"inspect()"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.ObjectType","text":"Bases: Enum All types an object can be. Source code in pytermgui/inspector.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class ObjectType ( Enum ): \"\"\"All types an object can be.\"\"\" LIVE = _auto () \"\"\"An instance that does not fit the other types.\"\"\" CLASS = _auto () \"\"\"A class object.\"\"\" MODULE = _auto () \"\"\"A module object.\"\"\" BUILTIN = _auto () \"\"\"Some sort of a builtin object. As builtins are often implemented in C, a lot of the standard python APIs won't work on them, so we need to treat them separately.\"\"\" FUNCTION = _auto () \"\"\"A callable object, that is not a class.\"\"\"","title":"ObjectType"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.ObjectType.BUILTIN","text":"Some sort of a builtin object. As builtins are often implemented in C, a lot of the standard python APIs won't work on them, so we need to treat them separately.","title":"BUILTIN"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.ObjectType.CLASS","text":"A class object.","title":"CLASS"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.ObjectType.FUNCTION","text":"A callable object, that is not a class.","title":"FUNCTION"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.ObjectType.LIVE","text":"An instance that does not fit the other types.","title":"LIVE"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.ObjectType.MODULE","text":"A module object.","title":"MODULE"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.get_origin","text":"Spoofs typing.get_origin, which is used to determine type-hints. Since this function is only available >=3.8, we need to have some implementation on it for 3.7. The code checks for the origin to be non-null, as that is the value returned by this method on non-typing objects. This will cause annotations to show up on 3.7, but not on 3.8+. Source code in pytermgui/inspector.py 38 39 40 41 42 43 44 45 46 47 48 49 def get_origin ( _ : object ) -> Any : # type: ignore \"\"\"Spoofs typing.get_origin, which is used to determine type-hints. Since this function is only available >=3.8, we need to have some implementation on it for 3.7. The code checks for the origin to be non-null, as that is the value returned by this method on non-typing objects. This will cause annotations to show up on 3.7, but not on 3.8+. \"\"\" return None","title":"get_origin()"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.inspect","text":"Inspects an object. Parameters: Name Type Description Default target object The object to inspect. required **inspector_args Any See Inspector.__init__ . {} Source code in pytermgui/inspector.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def inspect ( target : object , ** inspector_args : Any ) -> Inspector : \"\"\"Inspects an object. Args: target: The object to inspect. **inspector_args: See `Inspector.__init__`. \"\"\" def _conditionally_overwrite_kwarg ( ** kwargs ) -> None : for key , value in kwargs . items (): if inspector_args . get ( key ) is None : inspector_args [ key ] = value if ismodule ( target ): _conditionally_overwrite_kwarg ( show_dunder = False , show_private = False , show_full_doc = False , show_methods = True , show_qualname = False , ) elif isclass ( target ): _conditionally_overwrite_kwarg ( show_dunder = False , show_private = False , show_full_doc = True , show_methods = True , show_qualname = False , ) elif callable ( target ) or isbuiltin ( target ): _conditionally_overwrite_kwarg ( show_dunder = False , show_private = False , show_full_doc = True , show_methods = False , show_qualname = True , ) else : _conditionally_overwrite_kwarg ( show_dunder = False , show_private = False , show_full_doc = True , show_methods = True , show_qualname = False , ) inspector = Inspector ( ** inspector_args ) . inspect ( target ) return inspector","title":"inspect()"},{"location":"reference/pytermgui/palettes/","text":"The module responsible for creating snazzy color palettes. PaletteGeneratorStrategy = Callable [[ Color ], Tuple [ Color , Color , Color , Color ]] module-attribute Returns 4 colors generated from the base color. The first color will be used as the primary color. This should usually be the base color, but in some strategies (like analogous) it may not make sense. The second and third colors will be the secondary and tertiary colors, respectively. The last color will be interpreted as the accent. Palette dataclass A harmonious color palette. Running Palette.alias on a generated palette will create the following color aliases: Main colors These are the colors used by the majority of the application. Primary should make up around 50% percent of an average screen's colors, while secondary and tertiary should use the remaining 50% together (25% each). Accents should be used sparingly to highlight specific details. Items: primary, secondary, tertiary, accent Semantic colors These colors are all meant to convey some meaning. They shouldn't be used in situation where that meaning, e.g. success, isn't clearly related. When not given as an argument, they are generated by blending some default green, yellow and red with the primary color. Items: success, warning, error Neutral colors These are colors meant to be used as a background to the main group. All of them are a blend of a default background color and one of the main colors: surface is generated from primary , surface2 comes from secondary and so on. Items: surface, surface2, surface3, surface4 Source code in pytermgui/palettes.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 @dataclass ( repr = False ) class Palette : \"\"\"A harmonious color palette. Running `Palette.alias` on a generated palette will create the following color aliases: !!! cite \"Main colors\" These are the colors used by the majority of the application. Primary should make up around 50% percent of an average screen's colors, while secondary and tertiary should use the remaining 50% together (25% each). Accents should be used sparingly to highlight specific details. **Items:** primary, secondary, tertiary, accent !!! cite \"Semantic colors\" These colors are all meant to convey some meaning. They shouldn't be used in situation where that meaning, e.g. success, isn't clearly related. When not given as an argument, they are generated by blending some default green, yellow and red with the primary color. **Items:** success, warning, error !!! cite \"Neutral colors\" These are colors meant to be used as a background to the main group. All of them are a blend of a default background color and one of the main colors: `surface` is generated from `primary`, `surface2` comes from secondary and so on. **Items:** surface, surface2, surface3, surface4 \"\"\" data : dict [ str , str ] def __init__ ( # pylint: disable=too-many-locals self , * , primary : str , secondary : str | None = None , tertiary : str | None = None , accent : str | None = None , success : str | None = None , warning : str | None = None , error : str | None = None , surface : str | None = None , surface2 : str | None = None , surface3 : str | None = None , strategy : PaletteGeneratorStrategy = triadic , ) -> None : \"\"\"Generates a color palette from the given primary color. If any other color arguments are passed, they will be parsed as a color and used as-is. Otherwise, they will be derived from the primary. See the class documentation for info on all arguments. Args: strategy: A strategy that will be used to derive colors. \"\"\" self . data = self . _generate_map ( primary = primary , secondary = secondary , tertiary = tertiary , accent = accent , success = success , warning = warning , error = error , surface = surface , surface2 = surface2 , surface3 = surface3 , strategy = strategy , ) def _generate_map ( # pylint: disable=too-many-locals self , * , primary : str , secondary : str | None = None , tertiary : str | None = None , accent : str | None = None , success : str | None = None , warning : str | None = None , error : str | None = None , surface : str | None = None , surface2 : str | None = None , surface3 : str | None = None , strategy : PaletteGeneratorStrategy = triadic , ) -> dict [ str , str ]: \"\"\"Generates a map of color names to values. See `__init__` for more information. \"\"\" if isinstance ( strategy , str ): old_strat = strategy strategy = STRATEGIES . get ( strategy ) if strategy is None : raise KeyError ( f \"Unknown strategy { old_strat !r} . Please choose from\" + f \" { list ( STRATEGIES . keys ()) } .\" ) c_primary = Color . parse ( primary , localize = False ) # Four main colors c_primary , * generated = strategy ( c_primary ) c_secondary = _parse_optional ( secondary , generated [ 0 ]) c_tertiary = _parse_optional ( tertiary , generated [ 1 ]) c_accent = _parse_optional ( accent , generated [ 2 ]) # Four surface colors, one for each main color c_surface = _parse_optional ( surface , SURFACE . blend ( c_primary , SURFACE_ALPHA )) c_surface2 = _parse_optional ( surface2 , SURFACE . blend ( c_secondary , SURFACE_ALPHA ) ) c_surface3 = _parse_optional ( surface3 , SURFACE . blend ( c_tertiary , SURFACE_ALPHA )) c_surface4 = _parse_optional ( surface3 , SURFACE . blend ( c_accent , SURFACE_ALPHA )) # Three semantic colors, blended from primary c_success = _parse_optional ( success , SUCCESS . blend ( c_primary , SEMANTIC_ALPHA )) c_warning = _parse_optional ( warning , WARNING . blend ( c_primary , SEMANTIC_ALPHA )) c_error = _parse_optional ( error , ERROR . blend ( c_primary , SEMANTIC_ALPHA )) base_palette : dict [ str , Color ] = { \"primary\" : c_primary , \"secondary\" : c_secondary , \"tertiary\" : c_tertiary , \"accent\" : c_accent , \"surface\" : c_surface , \"surface2\" : c_surface2 , \"surface3\" : c_surface3 , \"surface4\" : c_surface4 , \"success\" : c_success , \"warning\" : c_warning , \"error\" : c_error , } black = Color . parse ( \"#000000\" ) white = Color . parse ( \"#FFFFFF\" ) data = {} for name , color in base_palette . items (): for shadenumber in range ( - SHADE_COUNT , SHADE_COUNT + 1 ): if shadenumber > 0 : shadeindex = f \"+ { shadenumber } \" blend_color = white blend_multiplier = 1 elif shadenumber == 0 : shadeindex = \"\" else : shadeindex = str ( shadenumber ) blend_color = black blend_multiplier = - 1 if shadenumber == 0 : blended = color else : blended = color . blend ( blend_color , blend_multiplier * SHADE_INCREMENT * shadenumber ) data [ f \" { name }{ shadeindex } \" ] = blended bg_variant = deepcopy ( blended ) bg_variant . background = True data [ f \"@ { name }{ shadeindex } \" ] = bg_variant return { key : ( \"@\" if color . background else \"\" ) + color . hex for key , color in data . items () } def regenerate ( self , ** kwargs : Any ) -> Palette : \"\"\"Generates a new palette and replaces self.data with its data. Args: **kwargs: All key word args passed to the new Palette. See `__init__`. Returns: This palette, after regeneration. \"\"\" other = Palette ( ** kwargs ) self . data = other . data self . alias () return self def base_keys ( self ) -> list [ str ]: \"\"\"Returns the non-background, non-shade alias keys.\"\"\" return [ key for key in self . data if not \"+\" in key and not \"-\" in key and not key . startswith ( \"@\" ) ] def alias ( self , lang : MarkupLanguage = tim ) -> None : \"\"\"Sets up aliases for the given language. Note that no unsetters will be generated. Args: lang: The language to run `alias_multiple` on. \"\"\" lang . clear_cache () lang . alias_multiple ( ** self . data , generate_unsetter = False ) def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Shows off the palette in a compact form.\"\"\" yield f \"< { type ( self ) . __name__ } \" for name , value in [ ( \"primary\" , self . data [ \"primary\" ]), ( \"secondary\" , self . data [ \"secondary\" ]), ( \"tertiary\" , self . data [ \"tertiary\" ]), ( \"accent\" , self . data [ \"accent\" ]), ]: yield { \"text\" : f \" { name } : [@ { value } #auto] { value } [/]\" , \"highlight\" : False , } yield \"> \\n\\n \" length = max ( len ( key ) for key in self . base_keys ()) + 2 for name in self . base_keys (): line = \"\" for shadenumber in range ( - SHADE_COUNT , SHADE_COUNT + 1 ): if shadenumber > 0 : shadeindex = f \"+ { shadenumber } \" elif shadenumber == 0 : line += f \"[@ { self . data [ name ] } #auto] { name : ^ { length }} \" continue else : shadeindex = str ( shadenumber ) line += f \"[@ { self . data [ name + shadeindex ] } #auto] \" yield { \"text\" : tim . parse ( line + \"[/] \\n \" ), \"highlight\" : False , } def print ( self ) -> None : \"\"\"Shows off the palette in an extended form.\"\"\" length = max ( len ( key ) for key in self . base_keys ()) + 4 keys = self . base_keys () for name in keys : names = [] for shadenumber in range ( - SHADE_COUNT , SHADE_COUNT + 1 ): if shadenumber > 0 : shadeindex = f \"+ { shadenumber } \" elif shadenumber == 0 : shadeindex = \"\" else : shadeindex = str ( shadenumber ) shaded_name = name + shadeindex names . append ( shaded_name ) tim . print ( \"\" . join ( f \"[@ { self . data [ name ] } ] { ' ' * length } \" for name in names )) tim . print ( \"\" . join ( f \"[@ { self . data [ name ] } #auto]\" + ( f \"[bold] { name : ^ { length }} [/]\" if name in keys else name [ - 2 :] . center ( length ) ) for name in names ) ) tim . print ( \"\" . join ( f \"[@ { self . data [ name ] } #auto] { self . data [ name ] : ^ { length }} \" for name in names ) ) tim . print ( \"\" . join ( f \"[@ { self . data [ name ] } ] { ' ' * length } \" for name in names )) __fancy_repr__ () Shows off the palette in a compact form. Source code in pytermgui/palettes.py 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Shows off the palette in a compact form.\"\"\" yield f \"< { type ( self ) . __name__ } \" for name , value in [ ( \"primary\" , self . data [ \"primary\" ]), ( \"secondary\" , self . data [ \"secondary\" ]), ( \"tertiary\" , self . data [ \"tertiary\" ]), ( \"accent\" , self . data [ \"accent\" ]), ]: yield { \"text\" : f \" { name } : [@ { value } #auto] { value } [/]\" , \"highlight\" : False , } yield \"> \\n\\n \" length = max ( len ( key ) for key in self . base_keys ()) + 2 for name in self . base_keys (): line = \"\" for shadenumber in range ( - SHADE_COUNT , SHADE_COUNT + 1 ): if shadenumber > 0 : shadeindex = f \"+ { shadenumber } \" elif shadenumber == 0 : line += f \"[@ { self . data [ name ] } #auto] { name : ^ { length }} \" continue else : shadeindex = str ( shadenumber ) line += f \"[@ { self . data [ name + shadeindex ] } #auto] \" yield { \"text\" : tim . parse ( line + \"[/] \\n \" ), \"highlight\" : False , } __init__ ( * , primary , secondary = None , tertiary = None , accent = None , success = None , warning = None , error = None , surface = None , surface2 = None , surface3 = None , strategy = triadic ) Generates a color palette from the given primary color. If any other color arguments are passed, they will be parsed as a color and used as-is. Otherwise, they will be derived from the primary. See the class documentation for info on all arguments. Parameters: Name Type Description Default strategy PaletteGeneratorStrategy A strategy that will be used to derive colors. triadic Source code in pytermgui/palettes.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def __init__ ( # pylint: disable=too-many-locals self , * , primary : str , secondary : str | None = None , tertiary : str | None = None , accent : str | None = None , success : str | None = None , warning : str | None = None , error : str | None = None , surface : str | None = None , surface2 : str | None = None , surface3 : str | None = None , strategy : PaletteGeneratorStrategy = triadic , ) -> None : \"\"\"Generates a color palette from the given primary color. If any other color arguments are passed, they will be parsed as a color and used as-is. Otherwise, they will be derived from the primary. See the class documentation for info on all arguments. Args: strategy: A strategy that will be used to derive colors. \"\"\" self . data = self . _generate_map ( primary = primary , secondary = secondary , tertiary = tertiary , accent = accent , success = success , warning = warning , error = error , surface = surface , surface2 = surface2 , surface3 = surface3 , strategy = strategy , ) alias ( lang = tim ) Sets up aliases for the given language. Note that no unsetters will be generated. Parameters: Name Type Description Default lang MarkupLanguage The language to run alias_multiple on. tim Source code in pytermgui/palettes.py 300 301 302 303 304 305 306 307 308 309 310 def alias ( self , lang : MarkupLanguage = tim ) -> None : \"\"\"Sets up aliases for the given language. Note that no unsetters will be generated. Args: lang: The language to run `alias_multiple` on. \"\"\" lang . clear_cache () lang . alias_multiple ( ** self . data , generate_unsetter = False ) base_keys () Returns the non-background, non-shade alias keys. Source code in pytermgui/palettes.py 291 292 293 294 295 296 297 298 def base_keys ( self ) -> list [ str ]: \"\"\"Returns the non-background, non-shade alias keys.\"\"\" return [ key for key in self . data if not \"+\" in key and not \"-\" in key and not key . startswith ( \"@\" ) ] print () Shows off the palette in an extended form. Source code in pytermgui/palettes.py 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 def print ( self ) -> None : \"\"\"Shows off the palette in an extended form.\"\"\" length = max ( len ( key ) for key in self . base_keys ()) + 4 keys = self . base_keys () for name in keys : names = [] for shadenumber in range ( - SHADE_COUNT , SHADE_COUNT + 1 ): if shadenumber > 0 : shadeindex = f \"+ { shadenumber } \" elif shadenumber == 0 : shadeindex = \"\" else : shadeindex = str ( shadenumber ) shaded_name = name + shadeindex names . append ( shaded_name ) tim . print ( \"\" . join ( f \"[@ { self . data [ name ] } ] { ' ' * length } \" for name in names )) tim . print ( \"\" . join ( f \"[@ { self . data [ name ] } #auto]\" + ( f \"[bold] { name : ^ { length }} [/]\" if name in keys else name [ - 2 :] . center ( length ) ) for name in names ) ) tim . print ( \"\" . join ( f \"[@ { self . data [ name ] } #auto] { self . data [ name ] : ^ { length }} \" for name in names ) ) tim . print ( \"\" . join ( f \"[@ { self . data [ name ] } ] { ' ' * length } \" for name in names )) regenerate ( kwargs ) Generates a new palette and replaces self.data with its data. Parameters: Name Type Description Default **kwargs Any All key word args passed to the new Palette. See __init__ . {} Returns: Type Description Palette This palette, after regeneration. Source code in pytermgui/palettes.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 def regenerate ( self , ** kwargs : Any ) -> Palette : \"\"\"Generates a new palette and replaces self.data with its data. Args: **kwargs: All key word args passed to the new Palette. See `__init__`. Returns: This palette, after regeneration. \"\"\" other = Palette ( ** kwargs ) self . data = other . data self . alias () return self analogous ( base ) Colors that sit next to eachother on the colorwheel. Note that the order of primary and secondary colors are swapped by this function. This is done so the colors, when laid out next to eachother, complete a gradient. Parameters: Name Type Description Default base Color The color used for derivations. required Source code in pytermgui/palettes.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def analogous ( base : Color ) -> tuple [ Color , Color , Color , Color ]: \"\"\"Colors that sit next to eachother on the colorwheel. Note that the order of primary and secondary colors are swapped by this function. This is done so the colors, when laid out next to eachother, complete a gradient. Args: base: The color used for derivations. ![Analogous strategy](../../assets/analogous.svg) \"\"\" before , _ , after = base . analogous return before , base , after , base . complement triadic ( base ) Three complementary colors. Each color is offset 120 degrees from the previous one on the colorwheel. If plotted on the colorwheel, they make up a regular triangle. Parameters: Name Type Description Default base Color The color used for derivations. required Source code in pytermgui/palettes.py 54 55 56 57 58 59 60 61 62 63 64 65 66 def triadic ( base : Color ) -> tuple [ Color , Color , Color , Color ]: \"\"\"Three complementary colors. Each color is offset 120 degrees from the previous one on the colorwheel. If plotted on the colorwheel, they make up a regular triangle. Args: base: The color used for derivations. ![Triadic strategy](../../assets/triadic.svg) \"\"\" return ( * base . triadic , base . complement )","title":"palettes"},{"location":"reference/pytermgui/palettes/#pytermgui.palettes.PaletteGeneratorStrategy","text":"Returns 4 colors generated from the base color. The first color will be used as the primary color. This should usually be the base color, but in some strategies (like analogous) it may not make sense. The second and third colors will be the secondary and tertiary colors, respectively. The last color will be interpreted as the accent.","title":"PaletteGeneratorStrategy"},{"location":"reference/pytermgui/palettes/#pytermgui.palettes.Palette","text":"A harmonious color palette. Running Palette.alias on a generated palette will create the following color aliases: Main colors These are the colors used by the majority of the application. Primary should make up around 50% percent of an average screen's colors, while secondary and tertiary should use the remaining 50% together (25% each). Accents should be used sparingly to highlight specific details. Items: primary, secondary, tertiary, accent Semantic colors These colors are all meant to convey some meaning. They shouldn't be used in situation where that meaning, e.g. success, isn't clearly related. When not given as an argument, they are generated by blending some default green, yellow and red with the primary color. Items: success, warning, error Neutral colors These are colors meant to be used as a background to the main group. All of them are a blend of a default background color and one of the main colors: surface is generated from primary , surface2 comes from secondary and so on. Items: surface, surface2, surface3, surface4 Source code in pytermgui/palettes.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 @dataclass ( repr = False ) class Palette : \"\"\"A harmonious color palette. Running `Palette.alias` on a generated palette will create the following color aliases: !!! cite \"Main colors\" These are the colors used by the majority of the application. Primary should make up around 50% percent of an average screen's colors, while secondary and tertiary should use the remaining 50% together (25% each). Accents should be used sparingly to highlight specific details. **Items:** primary, secondary, tertiary, accent !!! cite \"Semantic colors\" These colors are all meant to convey some meaning. They shouldn't be used in situation where that meaning, e.g. success, isn't clearly related. When not given as an argument, they are generated by blending some default green, yellow and red with the primary color. **Items:** success, warning, error !!! cite \"Neutral colors\" These are colors meant to be used as a background to the main group. All of them are a blend of a default background color and one of the main colors: `surface` is generated from `primary`, `surface2` comes from secondary and so on. **Items:** surface, surface2, surface3, surface4 \"\"\" data : dict [ str , str ] def __init__ ( # pylint: disable=too-many-locals self , * , primary : str , secondary : str | None = None , tertiary : str | None = None , accent : str | None = None , success : str | None = None , warning : str | None = None , error : str | None = None , surface : str | None = None , surface2 : str | None = None , surface3 : str | None = None , strategy : PaletteGeneratorStrategy = triadic , ) -> None : \"\"\"Generates a color palette from the given primary color. If any other color arguments are passed, they will be parsed as a color and used as-is. Otherwise, they will be derived from the primary. See the class documentation for info on all arguments. Args: strategy: A strategy that will be used to derive colors. \"\"\" self . data = self . _generate_map ( primary = primary , secondary = secondary , tertiary = tertiary , accent = accent , success = success , warning = warning , error = error , surface = surface , surface2 = surface2 , surface3 = surface3 , strategy = strategy , ) def _generate_map ( # pylint: disable=too-many-locals self , * , primary : str , secondary : str | None = None , tertiary : str | None = None , accent : str | None = None , success : str | None = None , warning : str | None = None , error : str | None = None , surface : str | None = None , surface2 : str | None = None , surface3 : str | None = None , strategy : PaletteGeneratorStrategy = triadic , ) -> dict [ str , str ]: \"\"\"Generates a map of color names to values. See `__init__` for more information. \"\"\" if isinstance ( strategy , str ): old_strat = strategy strategy = STRATEGIES . get ( strategy ) if strategy is None : raise KeyError ( f \"Unknown strategy { old_strat !r} . Please choose from\" + f \" { list ( STRATEGIES . keys ()) } .\" ) c_primary = Color . parse ( primary , localize = False ) # Four main colors c_primary , * generated = strategy ( c_primary ) c_secondary = _parse_optional ( secondary , generated [ 0 ]) c_tertiary = _parse_optional ( tertiary , generated [ 1 ]) c_accent = _parse_optional ( accent , generated [ 2 ]) # Four surface colors, one for each main color c_surface = _parse_optional ( surface , SURFACE . blend ( c_primary , SURFACE_ALPHA )) c_surface2 = _parse_optional ( surface2 , SURFACE . blend ( c_secondary , SURFACE_ALPHA ) ) c_surface3 = _parse_optional ( surface3 , SURFACE . blend ( c_tertiary , SURFACE_ALPHA )) c_surface4 = _parse_optional ( surface3 , SURFACE . blend ( c_accent , SURFACE_ALPHA )) # Three semantic colors, blended from primary c_success = _parse_optional ( success , SUCCESS . blend ( c_primary , SEMANTIC_ALPHA )) c_warning = _parse_optional ( warning , WARNING . blend ( c_primary , SEMANTIC_ALPHA )) c_error = _parse_optional ( error , ERROR . blend ( c_primary , SEMANTIC_ALPHA )) base_palette : dict [ str , Color ] = { \"primary\" : c_primary , \"secondary\" : c_secondary , \"tertiary\" : c_tertiary , \"accent\" : c_accent , \"surface\" : c_surface , \"surface2\" : c_surface2 , \"surface3\" : c_surface3 , \"surface4\" : c_surface4 , \"success\" : c_success , \"warning\" : c_warning , \"error\" : c_error , } black = Color . parse ( \"#000000\" ) white = Color . parse ( \"#FFFFFF\" ) data = {} for name , color in base_palette . items (): for shadenumber in range ( - SHADE_COUNT , SHADE_COUNT + 1 ): if shadenumber > 0 : shadeindex = f \"+ { shadenumber } \" blend_color = white blend_multiplier = 1 elif shadenumber == 0 : shadeindex = \"\" else : shadeindex = str ( shadenumber ) blend_color = black blend_multiplier = - 1 if shadenumber == 0 : blended = color else : blended = color . blend ( blend_color , blend_multiplier * SHADE_INCREMENT * shadenumber ) data [ f \" { name }{ shadeindex } \" ] = blended bg_variant = deepcopy ( blended ) bg_variant . background = True data [ f \"@ { name }{ shadeindex } \" ] = bg_variant return { key : ( \"@\" if color . background else \"\" ) + color . hex for key , color in data . items () } def regenerate ( self , ** kwargs : Any ) -> Palette : \"\"\"Generates a new palette and replaces self.data with its data. Args: **kwargs: All key word args passed to the new Palette. See `__init__`. Returns: This palette, after regeneration. \"\"\" other = Palette ( ** kwargs ) self . data = other . data self . alias () return self def base_keys ( self ) -> list [ str ]: \"\"\"Returns the non-background, non-shade alias keys.\"\"\" return [ key for key in self . data if not \"+\" in key and not \"-\" in key and not key . startswith ( \"@\" ) ] def alias ( self , lang : MarkupLanguage = tim ) -> None : \"\"\"Sets up aliases for the given language. Note that no unsetters will be generated. Args: lang: The language to run `alias_multiple` on. \"\"\" lang . clear_cache () lang . alias_multiple ( ** self . data , generate_unsetter = False ) def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Shows off the palette in a compact form.\"\"\" yield f \"< { type ( self ) . __name__ } \" for name , value in [ ( \"primary\" , self . data [ \"primary\" ]), ( \"secondary\" , self . data [ \"secondary\" ]), ( \"tertiary\" , self . data [ \"tertiary\" ]), ( \"accent\" , self . data [ \"accent\" ]), ]: yield { \"text\" : f \" { name } : [@ { value } #auto] { value } [/]\" , \"highlight\" : False , } yield \"> \\n\\n \" length = max ( len ( key ) for key in self . base_keys ()) + 2 for name in self . base_keys (): line = \"\" for shadenumber in range ( - SHADE_COUNT , SHADE_COUNT + 1 ): if shadenumber > 0 : shadeindex = f \"+ { shadenumber } \" elif shadenumber == 0 : line += f \"[@ { self . data [ name ] } #auto] { name : ^ { length }} \" continue else : shadeindex = str ( shadenumber ) line += f \"[@ { self . data [ name + shadeindex ] } #auto] \" yield { \"text\" : tim . parse ( line + \"[/] \\n \" ), \"highlight\" : False , } def print ( self ) -> None : \"\"\"Shows off the palette in an extended form.\"\"\" length = max ( len ( key ) for key in self . base_keys ()) + 4 keys = self . base_keys () for name in keys : names = [] for shadenumber in range ( - SHADE_COUNT , SHADE_COUNT + 1 ): if shadenumber > 0 : shadeindex = f \"+ { shadenumber } \" elif shadenumber == 0 : shadeindex = \"\" else : shadeindex = str ( shadenumber ) shaded_name = name + shadeindex names . append ( shaded_name ) tim . print ( \"\" . join ( f \"[@ { self . data [ name ] } ] { ' ' * length } \" for name in names )) tim . print ( \"\" . join ( f \"[@ { self . data [ name ] } #auto]\" + ( f \"[bold] { name : ^ { length }} [/]\" if name in keys else name [ - 2 :] . center ( length ) ) for name in names ) ) tim . print ( \"\" . join ( f \"[@ { self . data [ name ] } #auto] { self . data [ name ] : ^ { length }} \" for name in names ) ) tim . print ( \"\" . join ( f \"[@ { self . data [ name ] } ] { ' ' * length } \" for name in names ))","title":"Palette"},{"location":"reference/pytermgui/palettes/#pytermgui.palettes.Palette.__fancy_repr__","text":"Shows off the palette in a compact form. Source code in pytermgui/palettes.py 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Shows off the palette in a compact form.\"\"\" yield f \"< { type ( self ) . __name__ } \" for name , value in [ ( \"primary\" , self . data [ \"primary\" ]), ( \"secondary\" , self . data [ \"secondary\" ]), ( \"tertiary\" , self . data [ \"tertiary\" ]), ( \"accent\" , self . data [ \"accent\" ]), ]: yield { \"text\" : f \" { name } : [@ { value } #auto] { value } [/]\" , \"highlight\" : False , } yield \"> \\n\\n \" length = max ( len ( key ) for key in self . base_keys ()) + 2 for name in self . base_keys (): line = \"\" for shadenumber in range ( - SHADE_COUNT , SHADE_COUNT + 1 ): if shadenumber > 0 : shadeindex = f \"+ { shadenumber } \" elif shadenumber == 0 : line += f \"[@ { self . data [ name ] } #auto] { name : ^ { length }} \" continue else : shadeindex = str ( shadenumber ) line += f \"[@ { self . data [ name + shadeindex ] } #auto] \" yield { \"text\" : tim . parse ( line + \"[/] \\n \" ), \"highlight\" : False , }","title":"__fancy_repr__()"},{"location":"reference/pytermgui/palettes/#pytermgui.palettes.Palette.__init__","text":"Generates a color palette from the given primary color. If any other color arguments are passed, they will be parsed as a color and used as-is. Otherwise, they will be derived from the primary. See the class documentation for info on all arguments. Parameters: Name Type Description Default strategy PaletteGeneratorStrategy A strategy that will be used to derive colors. triadic Source code in pytermgui/palettes.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def __init__ ( # pylint: disable=too-many-locals self , * , primary : str , secondary : str | None = None , tertiary : str | None = None , accent : str | None = None , success : str | None = None , warning : str | None = None , error : str | None = None , surface : str | None = None , surface2 : str | None = None , surface3 : str | None = None , strategy : PaletteGeneratorStrategy = triadic , ) -> None : \"\"\"Generates a color palette from the given primary color. If any other color arguments are passed, they will be parsed as a color and used as-is. Otherwise, they will be derived from the primary. See the class documentation for info on all arguments. Args: strategy: A strategy that will be used to derive colors. \"\"\" self . data = self . _generate_map ( primary = primary , secondary = secondary , tertiary = tertiary , accent = accent , success = success , warning = warning , error = error , surface = surface , surface2 = surface2 , surface3 = surface3 , strategy = strategy , )","title":"__init__()"},{"location":"reference/pytermgui/palettes/#pytermgui.palettes.Palette.alias","text":"Sets up aliases for the given language. Note that no unsetters will be generated. Parameters: Name Type Description Default lang MarkupLanguage The language to run alias_multiple on. tim Source code in pytermgui/palettes.py 300 301 302 303 304 305 306 307 308 309 310 def alias ( self , lang : MarkupLanguage = tim ) -> None : \"\"\"Sets up aliases for the given language. Note that no unsetters will be generated. Args: lang: The language to run `alias_multiple` on. \"\"\" lang . clear_cache () lang . alias_multiple ( ** self . data , generate_unsetter = False )","title":"alias()"},{"location":"reference/pytermgui/palettes/#pytermgui.palettes.Palette.base_keys","text":"Returns the non-background, non-shade alias keys. Source code in pytermgui/palettes.py 291 292 293 294 295 296 297 298 def base_keys ( self ) -> list [ str ]: \"\"\"Returns the non-background, non-shade alias keys.\"\"\" return [ key for key in self . data if not \"+\" in key and not \"-\" in key and not key . startswith ( \"@\" ) ]","title":"base_keys()"},{"location":"reference/pytermgui/palettes/#pytermgui.palettes.Palette.print","text":"Shows off the palette in an extended form. Source code in pytermgui/palettes.py 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 def print ( self ) -> None : \"\"\"Shows off the palette in an extended form.\"\"\" length = max ( len ( key ) for key in self . base_keys ()) + 4 keys = self . base_keys () for name in keys : names = [] for shadenumber in range ( - SHADE_COUNT , SHADE_COUNT + 1 ): if shadenumber > 0 : shadeindex = f \"+ { shadenumber } \" elif shadenumber == 0 : shadeindex = \"\" else : shadeindex = str ( shadenumber ) shaded_name = name + shadeindex names . append ( shaded_name ) tim . print ( \"\" . join ( f \"[@ { self . data [ name ] } ] { ' ' * length } \" for name in names )) tim . print ( \"\" . join ( f \"[@ { self . data [ name ] } #auto]\" + ( f \"[bold] { name : ^ { length }} [/]\" if name in keys else name [ - 2 :] . center ( length ) ) for name in names ) ) tim . print ( \"\" . join ( f \"[@ { self . data [ name ] } #auto] { self . data [ name ] : ^ { length }} \" for name in names ) ) tim . print ( \"\" . join ( f \"[@ { self . data [ name ] } ] { ' ' * length } \" for name in names ))","title":"print()"},{"location":"reference/pytermgui/palettes/#pytermgui.palettes.Palette.regenerate","text":"Generates a new palette and replaces self.data with its data. Parameters: Name Type Description Default **kwargs Any All key word args passed to the new Palette. See __init__ . {} Returns: Type Description Palette This palette, after regeneration. Source code in pytermgui/palettes.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 def regenerate ( self , ** kwargs : Any ) -> Palette : \"\"\"Generates a new palette and replaces self.data with its data. Args: **kwargs: All key word args passed to the new Palette. See `__init__`. Returns: This palette, after regeneration. \"\"\" other = Palette ( ** kwargs ) self . data = other . data self . alias () return self","title":"regenerate()"},{"location":"reference/pytermgui/palettes/#pytermgui.palettes.analogous","text":"Colors that sit next to eachother on the colorwheel. Note that the order of primary and secondary colors are swapped by this function. This is done so the colors, when laid out next to eachother, complete a gradient. Parameters: Name Type Description Default base Color The color used for derivations. required Source code in pytermgui/palettes.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def analogous ( base : Color ) -> tuple [ Color , Color , Color , Color ]: \"\"\"Colors that sit next to eachother on the colorwheel. Note that the order of primary and secondary colors are swapped by this function. This is done so the colors, when laid out next to eachother, complete a gradient. Args: base: The color used for derivations. ![Analogous strategy](../../assets/analogous.svg) \"\"\" before , _ , after = base . analogous return before , base , after , base . complement","title":"analogous()"},{"location":"reference/pytermgui/palettes/#pytermgui.palettes.triadic","text":"Three complementary colors. Each color is offset 120 degrees from the previous one on the colorwheel. If plotted on the colorwheel, they make up a regular triangle. Parameters: Name Type Description Default base Color The color used for derivations. required Source code in pytermgui/palettes.py 54 55 56 57 58 59 60 61 62 63 64 65 66 def triadic ( base : Color ) -> tuple [ Color , Color , Color , Color ]: \"\"\"Three complementary colors. Each color is offset 120 degrees from the previous one on the colorwheel. If plotted on the colorwheel, they make up a regular triangle. Args: base: The color used for derivations. ![Triadic strategy](../../assets/triadic.svg) \"\"\" return ( * base . triadic , base . complement )","title":"triadic()"},{"location":"reference/pytermgui/prettifiers/","text":"This module provides some methods to prettify things. The main export here is prettify . It uses pytermgui.parser.tim , and all of its markup magic to create prettier representations of whatever is given. prettify ( target , indent = 2 , force_markup = False , expand_all = False , parse = True ) Prettifies any Python object. This uses a set of pre-defined aliases for the styling, and as such is fully customizable. The aliases are: str : Applied to all strings, so long as they do not contain TIM code. int : Applied to all integers and booleans. The latter are included as they subclass int. type : Applied to all types. none : Applied to NoneType. Note that when using pytermgui.pretty or any of its printers, a single None return value will not be printed, only when part of a more complex structure. Parameters: Name Type Description Default target Any The object to prettify. Can be any type. required indent int The indentation used for multi-line objects, like containers. When set to 0, these will be collapsed. By default, container types with len() == 1 are always collapsed, regardless of this value. See expand_all to overwrite that behaviour. 2 force_markup bool When this is set every ANSI-sequence string will be turned into markup and syntax highlighted. False expand_all bool When set, objects that would normally be force-collapsed are also going to be expanded. False parse bool If not set, the return value will be a plain markup string, not yet parsed. True Returns: Type Description str A pretty string of the given target. Source code in pytermgui/prettifiers.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def prettify ( # pylint: disable=too-many-branches target : Any , indent : int = 2 , force_markup : bool = False , expand_all : bool = False , parse : bool = True , ) -> str : \"\"\"Prettifies any Python object. This uses a set of pre-defined aliases for the styling, and as such is fully customizable. The aliases are: - `str`: Applied to all strings, so long as they do not contain TIM code. - `int`: Applied to all integers and booleans. The latter are included as they subclass int. - `type`: Applied to all types. - `none`: Applied to NoneType. Note that when using `pytermgui.pretty` or any of its printers, a single `None` return value will not be printed, only when part of a more complex structure. Args: target: The object to prettify. Can be any type. indent: The indentation used for multi-line objects, like containers. When set to 0, these will be collapsed. By default, container types with `len() == 1` are always collapsed, regardless of this value. See `expand_all` to overwrite that behaviour. force_markup: When this is set every ANSI-sequence string will be turned into markup and syntax highlighted. expand_all: When set, objects that would normally be force-collapsed are also going to be expanded. parse: If not set, the return value will be a plain markup string, not yet parsed. Returns: A pretty string of the given target. \"\"\" if isinstance ( target , str ): if RE_MARKUP . match ( target ) is not None : try : highlighted_target = highlight_tim ( target ) if parse : return f '\" { tim . parse ( highlighted_target ) } \"' return highlighted_target + \"[/]\" except MarkupSyntaxError : pass if RE_ANSI . match ( target ) is not None : return target + \" \\x1b [0m\" target = repr ( target ) if isinstance ( target , CONTAINER_TYPES ): if len ( target ) < 2 and not expand_all : indent = 0 indent_str = ( \" \\n \" if indent > 0 else \"\" ) + indent * \" \" chars = str ( target )[ 0 ], str ( target )[ - 1 ] buff = chars [ 0 ] if isinstance ( target , ( dict , UserDict )): for i , ( key , value ) in enumerate ( target . items ()): if i > 0 : buff += \", \" buff += indent_str + highlight_python ( f \" { key !r} : \" ) pretty = prettify ( value , indent = indent , expand_all = expand_all , force_markup = force_markup , parse = False , ) lines = pretty . splitlines () buff += lines [ 0 ] for line in lines [ 1 :]: buff += indent_str + line else : for i , value in enumerate ( target ): if i > 0 : buff += \", \" pretty = prettify ( value , indent = indent , expand_all = expand_all , force_markup = force_markup , parse = False , ) lines = pretty . splitlines () for line in lines : buff += indent_str + line if indent > 0 : buff += \" \\n \" buff += chars [ 1 ] if force_markup : return buff return tim . parse ( buff ) if supports_fancy_repr ( target ): buff = build_fancy_repr ( target ) else : buff = highlight_python ( str ( target )) return tim . parse ( buff ) if parse else buff","title":"prettifiers"},{"location":"reference/pytermgui/prettifiers/#pytermgui.prettifiers.prettify","text":"Prettifies any Python object. This uses a set of pre-defined aliases for the styling, and as such is fully customizable. The aliases are: str : Applied to all strings, so long as they do not contain TIM code. int : Applied to all integers and booleans. The latter are included as they subclass int. type : Applied to all types. none : Applied to NoneType. Note that when using pytermgui.pretty or any of its printers, a single None return value will not be printed, only when part of a more complex structure. Parameters: Name Type Description Default target Any The object to prettify. Can be any type. required indent int The indentation used for multi-line objects, like containers. When set to 0, these will be collapsed. By default, container types with len() == 1 are always collapsed, regardless of this value. See expand_all to overwrite that behaviour. 2 force_markup bool When this is set every ANSI-sequence string will be turned into markup and syntax highlighted. False expand_all bool When set, objects that would normally be force-collapsed are also going to be expanded. False parse bool If not set, the return value will be a plain markup string, not yet parsed. True Returns: Type Description str A pretty string of the given target. Source code in pytermgui/prettifiers.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def prettify ( # pylint: disable=too-many-branches target : Any , indent : int = 2 , force_markup : bool = False , expand_all : bool = False , parse : bool = True , ) -> str : \"\"\"Prettifies any Python object. This uses a set of pre-defined aliases for the styling, and as such is fully customizable. The aliases are: - `str`: Applied to all strings, so long as they do not contain TIM code. - `int`: Applied to all integers and booleans. The latter are included as they subclass int. - `type`: Applied to all types. - `none`: Applied to NoneType. Note that when using `pytermgui.pretty` or any of its printers, a single `None` return value will not be printed, only when part of a more complex structure. Args: target: The object to prettify. Can be any type. indent: The indentation used for multi-line objects, like containers. When set to 0, these will be collapsed. By default, container types with `len() == 1` are always collapsed, regardless of this value. See `expand_all` to overwrite that behaviour. force_markup: When this is set every ANSI-sequence string will be turned into markup and syntax highlighted. expand_all: When set, objects that would normally be force-collapsed are also going to be expanded. parse: If not set, the return value will be a plain markup string, not yet parsed. Returns: A pretty string of the given target. \"\"\" if isinstance ( target , str ): if RE_MARKUP . match ( target ) is not None : try : highlighted_target = highlight_tim ( target ) if parse : return f '\" { tim . parse ( highlighted_target ) } \"' return highlighted_target + \"[/]\" except MarkupSyntaxError : pass if RE_ANSI . match ( target ) is not None : return target + \" \\x1b [0m\" target = repr ( target ) if isinstance ( target , CONTAINER_TYPES ): if len ( target ) < 2 and not expand_all : indent = 0 indent_str = ( \" \\n \" if indent > 0 else \"\" ) + indent * \" \" chars = str ( target )[ 0 ], str ( target )[ - 1 ] buff = chars [ 0 ] if isinstance ( target , ( dict , UserDict )): for i , ( key , value ) in enumerate ( target . items ()): if i > 0 : buff += \", \" buff += indent_str + highlight_python ( f \" { key !r} : \" ) pretty = prettify ( value , indent = indent , expand_all = expand_all , force_markup = force_markup , parse = False , ) lines = pretty . splitlines () buff += lines [ 0 ] for line in lines [ 1 :]: buff += indent_str + line else : for i , value in enumerate ( target ): if i > 0 : buff += \", \" pretty = prettify ( value , indent = indent , expand_all = expand_all , force_markup = force_markup , parse = False , ) lines = pretty . splitlines () for line in lines : buff += indent_str + line if indent > 0 : buff += \" \\n \" buff += chars [ 1 ] if force_markup : return buff return tim . parse ( buff ) if supports_fancy_repr ( target ): buff = build_fancy_repr ( target ) else : buff = highlight_python ( str ( target )) return tim . parse ( buff ) if parse else buff","title":"prettify()"},{"location":"reference/pytermgui/pretty/","text":"This module calls install() on import, and defines print as pprint . It allows setting up pretty print functionality in only one line. Usage >>> from pytermgui.pretty import print PTGFormatter Bases: BaseFormatter An IPython formatter for PTG pretty printing. Source code in pytermgui/pretty.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 class PTGFormatter ( BaseFormatter ): # pylint: disable=too-few-public-methods \"\"\"An IPython formatter for PTG pretty printing.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\"Initializes PTGFormatter, storing **kwargs.\"\"\" super () . __init__ () self . kwargs = kwargs def __call__ ( self , value : Any ) -> None : \"\"\"Pretty prints the given value, as well as a leading newline. The newline is needed since IPython output is prepended with \"Out[i]:\", and it might mess alignments up. \"\"\" builtins . print ( \" \\n \" ) pprint ( value , ** self . kwargs ) # Sets up \"_\" as a way to access return value, # inkeeping with sys.displayhook builtins . _ = value # type: ignore __call__ ( value ) Pretty prints the given value, as well as a leading newline. The newline is needed since IPython output is prepended with \"Out[i]:\", and it might mess alignments up. Source code in pytermgui/pretty.py 164 165 166 167 168 169 170 171 172 173 174 175 176 def __call__ ( self , value : Any ) -> None : \"\"\"Pretty prints the given value, as well as a leading newline. The newline is needed since IPython output is prepended with \"Out[i]:\", and it might mess alignments up. \"\"\" builtins . print ( \" \\n \" ) pprint ( value , ** self . kwargs ) # Sets up \"_\" as a way to access return value, # inkeeping with sys.displayhook builtins . _ = value # type: ignore __init__ ( kwargs ) Initializes PTGFormatter, storing **kwargs. Source code in pytermgui/pretty.py 157 158 159 160 161 162 def __init__ ( self , ** kwargs : Any ) -> None : \"\"\"Initializes PTGFormatter, storing **kwargs.\"\"\" super () . __init__ () self . kwargs = kwargs install ( indent = 2 , force_markup = False , expand_all = False ) Sets up pprint to print all REPL output. IPython is also supported. This function sets up a hook that will call pprint after every interactive return. The given arguments are passed directly to pprint , so for more information you can check out that function. Usage is pretty simple: >>> from pytermgui import pretty >>> tim . setup_displayhook () >>> # Any function output will now be prettified ...or alternatively, you can import print from pytermgui.pretty , and have it automatically set up, and replace your namespace's print function with tim.pprint : >>> from pytermgui.pretty import print ... # Under the hood, the above is called and `tim.pprint` is set ... # for the `print` name >>> # Any function output will now be prettified Parameters: Name Type Description Default indent int The indentation value used for multi-line objects. This is ignored when the given object has a len() < 2 , and expand_all is not set. 2 force_markup bool Turn all ANSI-sequences into tim before pretty printing. False expand_all bool Force-expand containers, even when they would normally be collapsed. False Source code in pytermgui/pretty.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def install ( indent : int = 2 , force_markup : bool = False , expand_all : bool = False ) -> None : \"\"\"Sets up `pprint` to print all REPL output. IPython is also supported. This function sets up a hook that will call `pprint` after every interactive return. The given arguments are passed directly to `pprint`, so for more information you can check out that function. Usage is pretty simple: ```python3 >>> from pytermgui import pretty >>> tim.setup_displayhook() >>> # Any function output will now be prettified ``` ...or alternatively, you can import `print` from `pytermgui.pretty`, and have it automatically set up, and replace your namespace's `print` function with `tim.pprint`: ```python3 >>> from pytermgui.pretty import print ... # Under the hood, the above is called and `tim.pprint` is set ... # for the `print` name >>> # Any function output will now be prettified ``` Args: indent: The indentation value used for multi-line objects. This is ignored when the given object has a `len() < 2`, and `expand_all is not set.` force_markup: Turn all ANSI-sequences into tim before pretty printing. expand_all: Force-expand containers, even when they would normally be collapsed. \"\"\" def _hook ( value : Any ) -> None : if value is None : return pprint ( value , force_markup = force_markup , indent = indent , expand_all = expand_all ) # Sets up \"_\" as a way to access return value, # inkeeping with sys.displayhook builtins . _ = value # type: ignore if IPYTHON is not None : IPYTHON . display_formatter . formatters [ \"text/plain\" ] = PTGFormatter ( force_markup = force_markup , indent = indent , expand_all = expand_all ) else : sys . displayhook = _hook if not NO_WELCOME : with get_terminal () . no_record (): builtins . print () tim . print ( \"[113 bold]Successfully set up prettification!\" ) tim . print ( \"[245 italic]> All function returns will now be pretty-printed,\" ) builtins . print () pprint ( \"[245 italic]Including [/italic 210]Markup!\" ) builtins . print () get_terminal () . displayhook_installed = True pprint ( items , indent = 2 , expand_all = False , force_markup = False , parse = True , print_args ) A wrapper to pretty-print any object. This essentially just calls prettify on each given object, and passes the **print_args right through to print. Note that when the sep print argument is ommitted it is manually set to \", \\n\" . To customize any of the styles, see MarkupLanguage.prettify . Parameters: Name Type Description Default *items Any The items to print. These are passed in the same way they would be into builtin print. () indent int The indentation value used for multi-line objects. This is ignored when the given object has a len() < 2 , and expand_all is not set. 2 force_markup bool Turn all ANSI-sequences into markup before pretty printing. False expand_all bool Force-expand containers, even when they would normally be collapsed. False **print_args Any All arguments passed to builtin print. {} Source code in pytermgui/pretty.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def pprint ( * items : Any , indent : int = 2 , expand_all : bool = False , force_markup : bool = False , parse : bool = True , ** print_args : Any , ) -> None : r \"\"\"A wrapper to pretty-print any object. This essentially just calls `prettify` on each given object, and passes the `**print_args` right through to print. Note that when the `sep` print argument is ommitted it is manually set to `\", \\n\"`. To customize any of the styles, see `MarkupLanguage.prettify`. Args: *items: The items to print. These are passed in the same way they would be into builtin print. indent: The indentation value used for multi-line objects. This is ignored when the given object has a `len() < 2`, and `expand_all is not set.` force_markup: Turn all ANSI-sequences into markup before pretty printing. expand_all: Force-expand containers, even when they would normally be collapsed. **print_args: All arguments passed to builtin print. \"\"\" if \"sep\" not in print_args : print_args [ \"sep\" ] = \", \\n \" pretty = [] for item in items : pretty . append ( prettify ( item , force_markup = force_markup , indent = indent , expand_all = expand_all , parse = parse , ) ) get_terminal () . print ( * pretty , ** print_args )","title":"pretty"},{"location":"reference/pytermgui/pretty/#pytermgui.pretty.PTGFormatter","text":"Bases: BaseFormatter An IPython formatter for PTG pretty printing. Source code in pytermgui/pretty.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 class PTGFormatter ( BaseFormatter ): # pylint: disable=too-few-public-methods \"\"\"An IPython formatter for PTG pretty printing.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\"Initializes PTGFormatter, storing **kwargs.\"\"\" super () . __init__ () self . kwargs = kwargs def __call__ ( self , value : Any ) -> None : \"\"\"Pretty prints the given value, as well as a leading newline. The newline is needed since IPython output is prepended with \"Out[i]:\", and it might mess alignments up. \"\"\" builtins . print ( \" \\n \" ) pprint ( value , ** self . kwargs ) # Sets up \"_\" as a way to access return value, # inkeeping with sys.displayhook builtins . _ = value # type: ignore","title":"PTGFormatter"},{"location":"reference/pytermgui/pretty/#pytermgui.pretty.PTGFormatter.__call__","text":"Pretty prints the given value, as well as a leading newline. The newline is needed since IPython output is prepended with \"Out[i]:\", and it might mess alignments up. Source code in pytermgui/pretty.py 164 165 166 167 168 169 170 171 172 173 174 175 176 def __call__ ( self , value : Any ) -> None : \"\"\"Pretty prints the given value, as well as a leading newline. The newline is needed since IPython output is prepended with \"Out[i]:\", and it might mess alignments up. \"\"\" builtins . print ( \" \\n \" ) pprint ( value , ** self . kwargs ) # Sets up \"_\" as a way to access return value, # inkeeping with sys.displayhook builtins . _ = value # type: ignore","title":"__call__()"},{"location":"reference/pytermgui/pretty/#pytermgui.pretty.PTGFormatter.__init__","text":"Initializes PTGFormatter, storing **kwargs. Source code in pytermgui/pretty.py 157 158 159 160 161 162 def __init__ ( self , ** kwargs : Any ) -> None : \"\"\"Initializes PTGFormatter, storing **kwargs.\"\"\" super () . __init__ () self . kwargs = kwargs","title":"__init__()"},{"location":"reference/pytermgui/pretty/#pytermgui.pretty.install","text":"Sets up pprint to print all REPL output. IPython is also supported. This function sets up a hook that will call pprint after every interactive return. The given arguments are passed directly to pprint , so for more information you can check out that function. Usage is pretty simple: >>> from pytermgui import pretty >>> tim . setup_displayhook () >>> # Any function output will now be prettified ...or alternatively, you can import print from pytermgui.pretty , and have it automatically set up, and replace your namespace's print function with tim.pprint : >>> from pytermgui.pretty import print ... # Under the hood, the above is called and `tim.pprint` is set ... # for the `print` name >>> # Any function output will now be prettified Parameters: Name Type Description Default indent int The indentation value used for multi-line objects. This is ignored when the given object has a len() < 2 , and expand_all is not set. 2 force_markup bool Turn all ANSI-sequences into tim before pretty printing. False expand_all bool Force-expand containers, even when they would normally be collapsed. False Source code in pytermgui/pretty.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def install ( indent : int = 2 , force_markup : bool = False , expand_all : bool = False ) -> None : \"\"\"Sets up `pprint` to print all REPL output. IPython is also supported. This function sets up a hook that will call `pprint` after every interactive return. The given arguments are passed directly to `pprint`, so for more information you can check out that function. Usage is pretty simple: ```python3 >>> from pytermgui import pretty >>> tim.setup_displayhook() >>> # Any function output will now be prettified ``` ...or alternatively, you can import `print` from `pytermgui.pretty`, and have it automatically set up, and replace your namespace's `print` function with `tim.pprint`: ```python3 >>> from pytermgui.pretty import print ... # Under the hood, the above is called and `tim.pprint` is set ... # for the `print` name >>> # Any function output will now be prettified ``` Args: indent: The indentation value used for multi-line objects. This is ignored when the given object has a `len() < 2`, and `expand_all is not set.` force_markup: Turn all ANSI-sequences into tim before pretty printing. expand_all: Force-expand containers, even when they would normally be collapsed. \"\"\" def _hook ( value : Any ) -> None : if value is None : return pprint ( value , force_markup = force_markup , indent = indent , expand_all = expand_all ) # Sets up \"_\" as a way to access return value, # inkeeping with sys.displayhook builtins . _ = value # type: ignore if IPYTHON is not None : IPYTHON . display_formatter . formatters [ \"text/plain\" ] = PTGFormatter ( force_markup = force_markup , indent = indent , expand_all = expand_all ) else : sys . displayhook = _hook if not NO_WELCOME : with get_terminal () . no_record (): builtins . print () tim . print ( \"[113 bold]Successfully set up prettification!\" ) tim . print ( \"[245 italic]> All function returns will now be pretty-printed,\" ) builtins . print () pprint ( \"[245 italic]Including [/italic 210]Markup!\" ) builtins . print () get_terminal () . displayhook_installed = True","title":"install()"},{"location":"reference/pytermgui/pretty/#pytermgui.pretty.pprint","text":"A wrapper to pretty-print any object. This essentially just calls prettify on each given object, and passes the **print_args right through to print. Note that when the sep print argument is ommitted it is manually set to \", \\n\" . To customize any of the styles, see MarkupLanguage.prettify . Parameters: Name Type Description Default *items Any The items to print. These are passed in the same way they would be into builtin print. () indent int The indentation value used for multi-line objects. This is ignored when the given object has a len() < 2 , and expand_all is not set. 2 force_markup bool Turn all ANSI-sequences into markup before pretty printing. False expand_all bool Force-expand containers, even when they would normally be collapsed. False **print_args Any All arguments passed to builtin print. {} Source code in pytermgui/pretty.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def pprint ( * items : Any , indent : int = 2 , expand_all : bool = False , force_markup : bool = False , parse : bool = True , ** print_args : Any , ) -> None : r \"\"\"A wrapper to pretty-print any object. This essentially just calls `prettify` on each given object, and passes the `**print_args` right through to print. Note that when the `sep` print argument is ommitted it is manually set to `\", \\n\"`. To customize any of the styles, see `MarkupLanguage.prettify`. Args: *items: The items to print. These are passed in the same way they would be into builtin print. indent: The indentation value used for multi-line objects. This is ignored when the given object has a `len() < 2`, and `expand_all is not set.` force_markup: Turn all ANSI-sequences into markup before pretty printing. expand_all: Force-expand containers, even when they would normally be collapsed. **print_args: All arguments passed to builtin print. \"\"\" if \"sep\" not in print_args : print_args [ \"sep\" ] = \", \\n \" pretty = [] for item in items : pretty . append ( prettify ( item , force_markup = force_markup , indent = indent , expand_all = expand_all , parse = parse , ) ) get_terminal () . print ( * pretty , ** print_args )","title":"pprint()"},{"location":"reference/pytermgui/regex/","text":"This modules contains all of the regex-related names and utilites. has_open_sequence ( text ) cached Figures out if the given text has any unclosed ANSI sequences. It supports standard SGR ( \\x1b[1mHello ), OSC ( \\x1b[30;2ST\\x1b\\\\ ) and Kitty APC codes ( \u001b_Garguments;hex_data\\x1b\\\\ ). It also recognizes incorrect syntax; it only considers a tag closed when it is using the right closing sequence, e.g. m or H for SGR, \\x1b\\\\ for OSC and APC types. Parameters: Name Type Description Default text str The text to test. required Returns: Type Description bool True if there is at least one tag that hasn't been closed, False otherwise. Source code in pytermgui/regex.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 @lru_cache ( maxsize = 1024 ) def has_open_sequence ( text : str ) -> bool : \"\"\"Figures out if the given text has any unclosed ANSI sequences. It supports standard SGR (`\\\\x1b[1mHello`), OSC (`\\\\x1b[30;2ST\\\\x1b\\\\\\\\`) and Kitty APC codes (`\\x1b_Garguments;hex_data\\\\x1b\\\\\\\\`). It also recognizes incorrect syntax; it only considers a tag closed when it is using the right closing sequence, e.g. `m` or `H` for SGR, `\\\\x1b\\\\\\\\` for OSC and APC types. Args: text: The text to test. Returns: True if there is at least one tag that hasn't been closed, False otherwise. \"\"\" is_osc = False is_sgr = False is_apc = False open_count = 0 sequence = \"\" for char in text : if char == \" \\x1b \" : open_count += 1 sequence += char continue if len ( sequence ) == 0 : continue # Ignore OSC and APC closers as new openers if char == \" \\\\ \" and sequence [ - 1 ] == \" \\x1b \" : open_count -= 1 is_osc = is_osc or sequence [: 2 ] == \" \\x1b ]\" is_sgr = is_sgr or sequence [: 2 ] == \" \\x1b [\" is_apc = is_apc or sequence [: 3 ] == \" \\x1b _G\" sequence += char if ( is_osc or is_apc ) and sequence [ - 2 :] == \" \\x1b\\\\ \" : sequence = \"\" open_count -= 1 elif is_sgr and char in { \"m\" , \"H\" }: sequence = \"\" open_count -= 1 return len ( sequence ) != 0 or open_count != 0 real_length ( text ) cached Gets the display-length of text. This length means no ANSI sequences are counted. This method is a convenience wrapper for len(strip_ansi(text)) . Parameters: Name Type Description Default text str The text to calculate the length of. required Returns: Type Description int The display-length of text. Source code in pytermgui/regex.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @lru_cache ( maxsize = None ) def real_length ( text : str ) -> int : \"\"\"Gets the display-length of text. This length means no ANSI sequences are counted. This method is a convenience wrapper for `len(strip_ansi(text))`. Args: text: The text to calculate the length of. Returns: The display-length of text. \"\"\" return len ( strip_ansi ( text )) strip_ansi ( text ) cached Removes ANSI sequences from text. Parameters: Name Type Description Default text str A string or bytes object containing 0 or more ANSI sequences. required Returns: Type Description str The text without any ANSI sequences. Source code in pytermgui/regex.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @lru_cache () def strip_ansi ( text : str ) -> str : \"\"\"Removes ANSI sequences from text. Args: text: A string or bytes object containing 0 or more ANSI sequences. Returns: The text without any ANSI sequences. \"\"\" if hasattr ( text , \"plain\" ): return text . plain # type: ignore return RE_ANSI . sub ( \"\" , text ) strip_markup ( text ) cached Removes markup tags from text. Parameters: Name Type Description Default text str A string or bytes object containing 0 or more markup tags. required Returns: Type Description str The text without any markup tags. Source code in pytermgui/regex.py 42 43 44 45 46 47 48 49 50 51 52 53 @lru_cache () def strip_markup ( text : str ) -> str : \"\"\"Removes markup tags from text. Args: text: A string or bytes object containing 0 or more markup tags. Returns: The text without any markup tags. \"\"\" return RE_MARKUP . sub ( \"\" , text )","title":"regex"},{"location":"reference/pytermgui/regex/#pytermgui.regex.has_open_sequence","text":"Figures out if the given text has any unclosed ANSI sequences. It supports standard SGR ( \\x1b[1mHello ), OSC ( \\x1b[30;2ST\\x1b\\\\ ) and Kitty APC codes ( \u001b_Garguments;hex_data\\x1b\\\\ ). It also recognizes incorrect syntax; it only considers a tag closed when it is using the right closing sequence, e.g. m or H for SGR, \\x1b\\\\ for OSC and APC types. Parameters: Name Type Description Default text str The text to test. required Returns: Type Description bool True if there is at least one tag that hasn't been closed, False otherwise. Source code in pytermgui/regex.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 @lru_cache ( maxsize = 1024 ) def has_open_sequence ( text : str ) -> bool : \"\"\"Figures out if the given text has any unclosed ANSI sequences. It supports standard SGR (`\\\\x1b[1mHello`), OSC (`\\\\x1b[30;2ST\\\\x1b\\\\\\\\`) and Kitty APC codes (`\\x1b_Garguments;hex_data\\\\x1b\\\\\\\\`). It also recognizes incorrect syntax; it only considers a tag closed when it is using the right closing sequence, e.g. `m` or `H` for SGR, `\\\\x1b\\\\\\\\` for OSC and APC types. Args: text: The text to test. Returns: True if there is at least one tag that hasn't been closed, False otherwise. \"\"\" is_osc = False is_sgr = False is_apc = False open_count = 0 sequence = \"\" for char in text : if char == \" \\x1b \" : open_count += 1 sequence += char continue if len ( sequence ) == 0 : continue # Ignore OSC and APC closers as new openers if char == \" \\\\ \" and sequence [ - 1 ] == \" \\x1b \" : open_count -= 1 is_osc = is_osc or sequence [: 2 ] == \" \\x1b ]\" is_sgr = is_sgr or sequence [: 2 ] == \" \\x1b [\" is_apc = is_apc or sequence [: 3 ] == \" \\x1b _G\" sequence += char if ( is_osc or is_apc ) and sequence [ - 2 :] == \" \\x1b\\\\ \" : sequence = \"\" open_count -= 1 elif is_sgr and char in { \"m\" , \"H\" }: sequence = \"\" open_count -= 1 return len ( sequence ) != 0 or open_count != 0","title":"has_open_sequence()"},{"location":"reference/pytermgui/regex/#pytermgui.regex.real_length","text":"Gets the display-length of text. This length means no ANSI sequences are counted. This method is a convenience wrapper for len(strip_ansi(text)) . Parameters: Name Type Description Default text str The text to calculate the length of. required Returns: Type Description int The display-length of text. Source code in pytermgui/regex.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @lru_cache ( maxsize = None ) def real_length ( text : str ) -> int : \"\"\"Gets the display-length of text. This length means no ANSI sequences are counted. This method is a convenience wrapper for `len(strip_ansi(text))`. Args: text: The text to calculate the length of. Returns: The display-length of text. \"\"\" return len ( strip_ansi ( text ))","title":"real_length()"},{"location":"reference/pytermgui/regex/#pytermgui.regex.strip_ansi","text":"Removes ANSI sequences from text. Parameters: Name Type Description Default text str A string or bytes object containing 0 or more ANSI sequences. required Returns: Type Description str The text without any ANSI sequences. Source code in pytermgui/regex.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @lru_cache () def strip_ansi ( text : str ) -> str : \"\"\"Removes ANSI sequences from text. Args: text: A string or bytes object containing 0 or more ANSI sequences. Returns: The text without any ANSI sequences. \"\"\" if hasattr ( text , \"plain\" ): return text . plain # type: ignore return RE_ANSI . sub ( \"\" , text )","title":"strip_ansi()"},{"location":"reference/pytermgui/regex/#pytermgui.regex.strip_markup","text":"Removes markup tags from text. Parameters: Name Type Description Default text str A string or bytes object containing 0 or more markup tags. required Returns: Type Description str The text without any markup tags. Source code in pytermgui/regex.py 42 43 44 45 46 47 48 49 50 51 52 53 @lru_cache () def strip_markup ( text : str ) -> str : \"\"\"Removes markup tags from text. Args: text: A string or bytes object containing 0 or more markup tags. Returns: The text without any markup tags. \"\"\" return RE_MARKUP . sub ( \"\" , text )","title":"strip_markup()"},{"location":"reference/pytermgui/serialization/","text":"Serializer class to allow dumping and loading Widget -s. This class uses Widget.serialize for each widget. Serializer A class to facilitate loading & dumping widgets. By default it is only aware of pytermgui objects, however if needed it can be made aware of custom widgets using Serializer.register . It can dump any widget type, but can only load ones it knows. All styles (except for char styles) are converted to markup during the dump process. This is done to make the end-result more readable, as well as more universally usable. As a result, all widgets use markup_style for their affected styles. Source code in pytermgui/serialization.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 class Serializer : \"\"\"A class to facilitate loading & dumping widgets. By default it is only aware of pytermgui objects, however if needed it can be made aware of custom widgets using `Serializer.register`. It can dump any widget type, but can only load ones it knows. All styles (except for char styles) are converted to markup during the dump process. This is done to make the end-result more readable, as well as more universally usable. As a result, all widgets use `markup_style` for their affected styles.\"\"\" def __init__ ( self ) -> None : \"\"\"Sets up known widgets.\"\"\" self . known_widgets = self . get_widgets () self . known_boxes = vars ( widgets . boxes ) self . register ( Window ) self . bound_methods : dict [ str , Callable [ ... , Any ]] = {} @staticmethod def get_widgets () -> WidgetDict : \"\"\"Gets all widgets from the module.\"\"\" known = {} for name , item in vars ( widgets ) . items (): if not isinstance ( item , type ): continue if issubclass ( item , Widget ): known [ name ] = item return known @staticmethod def dump_to_dict ( obj : Widget ) -> dict [ str , Any ]: \"\"\"Dump widget to a dict. This is an alias for `obj.serialize`. Args: obj: The widget to dump. Returns: `obj.serialize()`. \"\"\" return obj . serialize () def register_box ( self , name : str , box : widgets . boxes . Box ) -> None : \"\"\"Registers a new Box type. Args: name: The name of the box. box: The box instance. \"\"\" self . known_boxes [ name ] = box def register ( self , cls : Type [ Widget ]) -> None : \"\"\"Makes object aware of a custom widget class, so it can be serialized. Args: cls: The widget type to register. Raises: TypeError: The object is not a type. \"\"\" if not isinstance ( cls , type ): raise TypeError ( \"Registered object must be a type.\" ) self . known_widgets [ cls . __name__ ] = cls def bind ( self , name : str , method : Callable [ ... , Any ]) -> None : \"\"\"Binds a name to a method. These method callables are substituted into all fields that follow the `method:<method_name>` syntax. If `method_name` is not bound, an exception will be raised during loading. Args: name: The name of the method, as referenced in the loaded files. method: The callable to bind. \"\"\" self . bound_methods [ name ] = method def from_dict ( # pylint: disable=too-many-locals, too-many-branches self , data : dict [ str , Any ], widget_type : str | None = None ) -> Widget : \"\"\"Loads a widget from a dictionary. Args: data: The data to load from. widget_type: Substitute for when data has no `type` field. Returns: A widget from the given data. \"\"\" def _apply_markup ( value : CharType ) -> CharType : \"\"\"Apply markup style to obj's key\"\"\" formatted : CharType if isinstance ( value , list ): formatted = [ tim . parse ( val ) for val in value ] else : formatted = tim . parse ( value ) return formatted if widget_type is not None : data [ \"type\" ] = widget_type obj_class_name = data . get ( \"type\" ) if obj_class_name is None : raise ValueError ( \"Object with type None could not be loaded.\" ) if obj_class_name not in self . known_widgets : raise ValueError ( f 'Object of type \" { obj_class_name } \" is not known!' + f \" Register it with `serializer.register( { obj_class_name } )`.\" ) del data [ \"type\" ] obj_class = self . known_widgets . get ( obj_class_name ) assert obj_class is not None obj = obj_class () for key , value in data . items (): if key . startswith ( \"widgets\" ): for inner in value : name , widget = list ( inner . items ())[ 0 ] new = self . from_dict ( widget , widget_type = name ) assert hasattr ( obj , \"__iadd__\" ) # this object can be added to, since # it has an __iadd__ method. obj += new # type: ignore continue if isinstance ( value , str ) and value . startswith ( \"method:\" ): name = value [ 7 :] if name not in self . bound_methods : raise KeyError ( f 'Reference to unbound method: \" { name } \".' ) value = self . bound_methods [ name ] if key == \"chars\" : chars : dict [ str , CharType ] = {} for name , char in value . items (): chars [ name ] = _apply_markup ( char ) setattr ( obj , \"chars\" , chars ) continue if key == \"styles\" : for name , markup_str in value . items (): obj . styles [ name ] = markup_str continue setattr ( obj , key , value ) return obj def from_file ( self , file : IO [ str ]) -> Widget : \"\"\"Loads widget from a file object. Args: file: An IO object. Returns: The loaded widget. \"\"\" return self . from_dict ( json . load ( file )) def to_file ( self , obj : Widget , file : IO [ str ], ** json_args : dict [ str , Any ]) -> None : \"\"\"Dumps widget to a file object. Args: obj: The widget to dump. file: The file object it gets written to. **json_args: Arguments passed to `json.dump`. \"\"\" data = self . dump_to_dict ( obj ) if \"separators\" not in json_args : # this is a sub-element of a dict[str, Any], so this # should work. json_args [ \"separators\" ] = ( \",\" , \":\" ) # type: ignore # ** is supposed to be a dict, not a positional arg json . dump ( data , file , ** json_args ) # type: ignore __init__ () Sets up known widgets. Source code in pytermgui/serialization.py 36 37 38 39 40 41 42 43 def __init__ ( self ) -> None : \"\"\"Sets up known widgets.\"\"\" self . known_widgets = self . get_widgets () self . known_boxes = vars ( widgets . boxes ) self . register ( Window ) self . bound_methods : dict [ str , Callable [ ... , Any ]] = {} bind ( name , method ) Binds a name to a method. These method callables are substituted into all fields that follow the method:<method_name> syntax. If method_name is not bound, an exception will be raised during loading. Parameters: Name Type Description Default name str The name of the method, as referenced in the loaded files. required method Callable [..., Any ] The callable to bind. required Source code in pytermgui/serialization.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def bind ( self , name : str , method : Callable [ ... , Any ]) -> None : \"\"\"Binds a name to a method. These method callables are substituted into all fields that follow the `method:<method_name>` syntax. If `method_name` is not bound, an exception will be raised during loading. Args: name: The name of the method, as referenced in the loaded files. method: The callable to bind. \"\"\" self . bound_methods [ name ] = method dump_to_dict ( obj ) staticmethod Dump widget to a dict. This is an alias for obj.serialize . Parameters: Name Type Description Default obj Widget The widget to dump. required Returns: Type Description dict [ str , Any ] obj.serialize() . Source code in pytermgui/serialization.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 @staticmethod def dump_to_dict ( obj : Widget ) -> dict [ str , Any ]: \"\"\"Dump widget to a dict. This is an alias for `obj.serialize`. Args: obj: The widget to dump. Returns: `obj.serialize()`. \"\"\" return obj . serialize () from_dict ( data , widget_type = None ) Loads a widget from a dictionary. Parameters: Name Type Description Default data dict [ str , Any ] The data to load from. required widget_type str | None Substitute for when data has no type field. None Returns: Type Description Widget A widget from the given data. Source code in pytermgui/serialization.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def from_dict ( # pylint: disable=too-many-locals, too-many-branches self , data : dict [ str , Any ], widget_type : str | None = None ) -> Widget : \"\"\"Loads a widget from a dictionary. Args: data: The data to load from. widget_type: Substitute for when data has no `type` field. Returns: A widget from the given data. \"\"\" def _apply_markup ( value : CharType ) -> CharType : \"\"\"Apply markup style to obj's key\"\"\" formatted : CharType if isinstance ( value , list ): formatted = [ tim . parse ( val ) for val in value ] else : formatted = tim . parse ( value ) return formatted if widget_type is not None : data [ \"type\" ] = widget_type obj_class_name = data . get ( \"type\" ) if obj_class_name is None : raise ValueError ( \"Object with type None could not be loaded.\" ) if obj_class_name not in self . known_widgets : raise ValueError ( f 'Object of type \" { obj_class_name } \" is not known!' + f \" Register it with `serializer.register( { obj_class_name } )`.\" ) del data [ \"type\" ] obj_class = self . known_widgets . get ( obj_class_name ) assert obj_class is not None obj = obj_class () for key , value in data . items (): if key . startswith ( \"widgets\" ): for inner in value : name , widget = list ( inner . items ())[ 0 ] new = self . from_dict ( widget , widget_type = name ) assert hasattr ( obj , \"__iadd__\" ) # this object can be added to, since # it has an __iadd__ method. obj += new # type: ignore continue if isinstance ( value , str ) and value . startswith ( \"method:\" ): name = value [ 7 :] if name not in self . bound_methods : raise KeyError ( f 'Reference to unbound method: \" { name } \".' ) value = self . bound_methods [ name ] if key == \"chars\" : chars : dict [ str , CharType ] = {} for name , char in value . items (): chars [ name ] = _apply_markup ( char ) setattr ( obj , \"chars\" , chars ) continue if key == \"styles\" : for name , markup_str in value . items (): obj . styles [ name ] = markup_str continue setattr ( obj , key , value ) return obj from_file ( file ) Loads widget from a file object. Parameters: Name Type Description Default file IO [ str ] An IO object. required Returns: Type Description Widget The loaded widget. Source code in pytermgui/serialization.py 198 199 200 201 202 203 204 205 206 207 208 def from_file ( self , file : IO [ str ]) -> Widget : \"\"\"Loads widget from a file object. Args: file: An IO object. Returns: The loaded widget. \"\"\" return self . from_dict ( json . load ( file )) get_widgets () staticmethod Gets all widgets from the module. Source code in pytermgui/serialization.py 45 46 47 48 49 50 51 52 53 54 55 56 57 @staticmethod def get_widgets () -> WidgetDict : \"\"\"Gets all widgets from the module.\"\"\" known = {} for name , item in vars ( widgets ) . items (): if not isinstance ( item , type ): continue if issubclass ( item , Widget ): known [ name ] = item return known register ( cls ) Makes object aware of a custom widget class, so it can be serialized. Parameters: Name Type Description Default cls Type [ Widget ] The widget type to register. required Raises: Type Description TypeError The object is not a type. Source code in pytermgui/serialization.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def register ( self , cls : Type [ Widget ]) -> None : \"\"\"Makes object aware of a custom widget class, so it can be serialized. Args: cls: The widget type to register. Raises: TypeError: The object is not a type. \"\"\" if not isinstance ( cls , type ): raise TypeError ( \"Registered object must be a type.\" ) self . known_widgets [ cls . __name__ ] = cls register_box ( name , box ) Registers a new Box type. Parameters: Name Type Description Default name str The name of the box. required box widgets . boxes . Box The box instance. required Source code in pytermgui/serialization.py 74 75 76 77 78 79 80 81 82 def register_box ( self , name : str , box : widgets . boxes . Box ) -> None : \"\"\"Registers a new Box type. Args: name: The name of the box. box: The box instance. \"\"\" self . known_boxes [ name ] = box to_file ( obj , file , json_args ) Dumps widget to a file object. Parameters: Name Type Description Default obj Widget The widget to dump. required file IO [ str ] The file object it gets written to. required **json_args dict [ str , Any ] Arguments passed to json.dump . {} Source code in pytermgui/serialization.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def to_file ( self , obj : Widget , file : IO [ str ], ** json_args : dict [ str , Any ]) -> None : \"\"\"Dumps widget to a file object. Args: obj: The widget to dump. file: The file object it gets written to. **json_args: Arguments passed to `json.dump`. \"\"\" data = self . dump_to_dict ( obj ) if \"separators\" not in json_args : # this is a sub-element of a dict[str, Any], so this # should work. json_args [ \"separators\" ] = ( \",\" , \":\" ) # type: ignore # ** is supposed to be a dict, not a positional arg json . dump ( data , file , ** json_args ) # type: ignore","title":"serialization"},{"location":"reference/pytermgui/serialization/#pytermgui.serialization.Serializer","text":"A class to facilitate loading & dumping widgets. By default it is only aware of pytermgui objects, however if needed it can be made aware of custom widgets using Serializer.register . It can dump any widget type, but can only load ones it knows. All styles (except for char styles) are converted to markup during the dump process. This is done to make the end-result more readable, as well as more universally usable. As a result, all widgets use markup_style for their affected styles. Source code in pytermgui/serialization.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 class Serializer : \"\"\"A class to facilitate loading & dumping widgets. By default it is only aware of pytermgui objects, however if needed it can be made aware of custom widgets using `Serializer.register`. It can dump any widget type, but can only load ones it knows. All styles (except for char styles) are converted to markup during the dump process. This is done to make the end-result more readable, as well as more universally usable. As a result, all widgets use `markup_style` for their affected styles.\"\"\" def __init__ ( self ) -> None : \"\"\"Sets up known widgets.\"\"\" self . known_widgets = self . get_widgets () self . known_boxes = vars ( widgets . boxes ) self . register ( Window ) self . bound_methods : dict [ str , Callable [ ... , Any ]] = {} @staticmethod def get_widgets () -> WidgetDict : \"\"\"Gets all widgets from the module.\"\"\" known = {} for name , item in vars ( widgets ) . items (): if not isinstance ( item , type ): continue if issubclass ( item , Widget ): known [ name ] = item return known @staticmethod def dump_to_dict ( obj : Widget ) -> dict [ str , Any ]: \"\"\"Dump widget to a dict. This is an alias for `obj.serialize`. Args: obj: The widget to dump. Returns: `obj.serialize()`. \"\"\" return obj . serialize () def register_box ( self , name : str , box : widgets . boxes . Box ) -> None : \"\"\"Registers a new Box type. Args: name: The name of the box. box: The box instance. \"\"\" self . known_boxes [ name ] = box def register ( self , cls : Type [ Widget ]) -> None : \"\"\"Makes object aware of a custom widget class, so it can be serialized. Args: cls: The widget type to register. Raises: TypeError: The object is not a type. \"\"\" if not isinstance ( cls , type ): raise TypeError ( \"Registered object must be a type.\" ) self . known_widgets [ cls . __name__ ] = cls def bind ( self , name : str , method : Callable [ ... , Any ]) -> None : \"\"\"Binds a name to a method. These method callables are substituted into all fields that follow the `method:<method_name>` syntax. If `method_name` is not bound, an exception will be raised during loading. Args: name: The name of the method, as referenced in the loaded files. method: The callable to bind. \"\"\" self . bound_methods [ name ] = method def from_dict ( # pylint: disable=too-many-locals, too-many-branches self , data : dict [ str , Any ], widget_type : str | None = None ) -> Widget : \"\"\"Loads a widget from a dictionary. Args: data: The data to load from. widget_type: Substitute for when data has no `type` field. Returns: A widget from the given data. \"\"\" def _apply_markup ( value : CharType ) -> CharType : \"\"\"Apply markup style to obj's key\"\"\" formatted : CharType if isinstance ( value , list ): formatted = [ tim . parse ( val ) for val in value ] else : formatted = tim . parse ( value ) return formatted if widget_type is not None : data [ \"type\" ] = widget_type obj_class_name = data . get ( \"type\" ) if obj_class_name is None : raise ValueError ( \"Object with type None could not be loaded.\" ) if obj_class_name not in self . known_widgets : raise ValueError ( f 'Object of type \" { obj_class_name } \" is not known!' + f \" Register it with `serializer.register( { obj_class_name } )`.\" ) del data [ \"type\" ] obj_class = self . known_widgets . get ( obj_class_name ) assert obj_class is not None obj = obj_class () for key , value in data . items (): if key . startswith ( \"widgets\" ): for inner in value : name , widget = list ( inner . items ())[ 0 ] new = self . from_dict ( widget , widget_type = name ) assert hasattr ( obj , \"__iadd__\" ) # this object can be added to, since # it has an __iadd__ method. obj += new # type: ignore continue if isinstance ( value , str ) and value . startswith ( \"method:\" ): name = value [ 7 :] if name not in self . bound_methods : raise KeyError ( f 'Reference to unbound method: \" { name } \".' ) value = self . bound_methods [ name ] if key == \"chars\" : chars : dict [ str , CharType ] = {} for name , char in value . items (): chars [ name ] = _apply_markup ( char ) setattr ( obj , \"chars\" , chars ) continue if key == \"styles\" : for name , markup_str in value . items (): obj . styles [ name ] = markup_str continue setattr ( obj , key , value ) return obj def from_file ( self , file : IO [ str ]) -> Widget : \"\"\"Loads widget from a file object. Args: file: An IO object. Returns: The loaded widget. \"\"\" return self . from_dict ( json . load ( file )) def to_file ( self , obj : Widget , file : IO [ str ], ** json_args : dict [ str , Any ]) -> None : \"\"\"Dumps widget to a file object. Args: obj: The widget to dump. file: The file object it gets written to. **json_args: Arguments passed to `json.dump`. \"\"\" data = self . dump_to_dict ( obj ) if \"separators\" not in json_args : # this is a sub-element of a dict[str, Any], so this # should work. json_args [ \"separators\" ] = ( \",\" , \":\" ) # type: ignore # ** is supposed to be a dict, not a positional arg json . dump ( data , file , ** json_args ) # type: ignore","title":"Serializer"},{"location":"reference/pytermgui/serialization/#pytermgui.serialization.Serializer.__init__","text":"Sets up known widgets. Source code in pytermgui/serialization.py 36 37 38 39 40 41 42 43 def __init__ ( self ) -> None : \"\"\"Sets up known widgets.\"\"\" self . known_widgets = self . get_widgets () self . known_boxes = vars ( widgets . boxes ) self . register ( Window ) self . bound_methods : dict [ str , Callable [ ... , Any ]] = {}","title":"__init__()"},{"location":"reference/pytermgui/serialization/#pytermgui.serialization.Serializer.bind","text":"Binds a name to a method. These method callables are substituted into all fields that follow the method:<method_name> syntax. If method_name is not bound, an exception will be raised during loading. Parameters: Name Type Description Default name str The name of the method, as referenced in the loaded files. required method Callable [..., Any ] The callable to bind. required Source code in pytermgui/serialization.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def bind ( self , name : str , method : Callable [ ... , Any ]) -> None : \"\"\"Binds a name to a method. These method callables are substituted into all fields that follow the `method:<method_name>` syntax. If `method_name` is not bound, an exception will be raised during loading. Args: name: The name of the method, as referenced in the loaded files. method: The callable to bind. \"\"\" self . bound_methods [ name ] = method","title":"bind()"},{"location":"reference/pytermgui/serialization/#pytermgui.serialization.Serializer.dump_to_dict","text":"Dump widget to a dict. This is an alias for obj.serialize . Parameters: Name Type Description Default obj Widget The widget to dump. required Returns: Type Description dict [ str , Any ] obj.serialize() . Source code in pytermgui/serialization.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 @staticmethod def dump_to_dict ( obj : Widget ) -> dict [ str , Any ]: \"\"\"Dump widget to a dict. This is an alias for `obj.serialize`. Args: obj: The widget to dump. Returns: `obj.serialize()`. \"\"\" return obj . serialize ()","title":"dump_to_dict()"},{"location":"reference/pytermgui/serialization/#pytermgui.serialization.Serializer.from_dict","text":"Loads a widget from a dictionary. Parameters: Name Type Description Default data dict [ str , Any ] The data to load from. required widget_type str | None Substitute for when data has no type field. None Returns: Type Description Widget A widget from the given data. Source code in pytermgui/serialization.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def from_dict ( # pylint: disable=too-many-locals, too-many-branches self , data : dict [ str , Any ], widget_type : str | None = None ) -> Widget : \"\"\"Loads a widget from a dictionary. Args: data: The data to load from. widget_type: Substitute for when data has no `type` field. Returns: A widget from the given data. \"\"\" def _apply_markup ( value : CharType ) -> CharType : \"\"\"Apply markup style to obj's key\"\"\" formatted : CharType if isinstance ( value , list ): formatted = [ tim . parse ( val ) for val in value ] else : formatted = tim . parse ( value ) return formatted if widget_type is not None : data [ \"type\" ] = widget_type obj_class_name = data . get ( \"type\" ) if obj_class_name is None : raise ValueError ( \"Object with type None could not be loaded.\" ) if obj_class_name not in self . known_widgets : raise ValueError ( f 'Object of type \" { obj_class_name } \" is not known!' + f \" Register it with `serializer.register( { obj_class_name } )`.\" ) del data [ \"type\" ] obj_class = self . known_widgets . get ( obj_class_name ) assert obj_class is not None obj = obj_class () for key , value in data . items (): if key . startswith ( \"widgets\" ): for inner in value : name , widget = list ( inner . items ())[ 0 ] new = self . from_dict ( widget , widget_type = name ) assert hasattr ( obj , \"__iadd__\" ) # this object can be added to, since # it has an __iadd__ method. obj += new # type: ignore continue if isinstance ( value , str ) and value . startswith ( \"method:\" ): name = value [ 7 :] if name not in self . bound_methods : raise KeyError ( f 'Reference to unbound method: \" { name } \".' ) value = self . bound_methods [ name ] if key == \"chars\" : chars : dict [ str , CharType ] = {} for name , char in value . items (): chars [ name ] = _apply_markup ( char ) setattr ( obj , \"chars\" , chars ) continue if key == \"styles\" : for name , markup_str in value . items (): obj . styles [ name ] = markup_str continue setattr ( obj , key , value ) return obj","title":"from_dict()"},{"location":"reference/pytermgui/serialization/#pytermgui.serialization.Serializer.from_file","text":"Loads widget from a file object. Parameters: Name Type Description Default file IO [ str ] An IO object. required Returns: Type Description Widget The loaded widget. Source code in pytermgui/serialization.py 198 199 200 201 202 203 204 205 206 207 208 def from_file ( self , file : IO [ str ]) -> Widget : \"\"\"Loads widget from a file object. Args: file: An IO object. Returns: The loaded widget. \"\"\" return self . from_dict ( json . load ( file ))","title":"from_file()"},{"location":"reference/pytermgui/serialization/#pytermgui.serialization.Serializer.get_widgets","text":"Gets all widgets from the module. Source code in pytermgui/serialization.py 45 46 47 48 49 50 51 52 53 54 55 56 57 @staticmethod def get_widgets () -> WidgetDict : \"\"\"Gets all widgets from the module.\"\"\" known = {} for name , item in vars ( widgets ) . items (): if not isinstance ( item , type ): continue if issubclass ( item , Widget ): known [ name ] = item return known","title":"get_widgets()"},{"location":"reference/pytermgui/serialization/#pytermgui.serialization.Serializer.register","text":"Makes object aware of a custom widget class, so it can be serialized. Parameters: Name Type Description Default cls Type [ Widget ] The widget type to register. required Raises: Type Description TypeError The object is not a type. Source code in pytermgui/serialization.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def register ( self , cls : Type [ Widget ]) -> None : \"\"\"Makes object aware of a custom widget class, so it can be serialized. Args: cls: The widget type to register. Raises: TypeError: The object is not a type. \"\"\" if not isinstance ( cls , type ): raise TypeError ( \"Registered object must be a type.\" ) self . known_widgets [ cls . __name__ ] = cls","title":"register()"},{"location":"reference/pytermgui/serialization/#pytermgui.serialization.Serializer.register_box","text":"Registers a new Box type. Parameters: Name Type Description Default name str The name of the box. required box widgets . boxes . Box The box instance. required Source code in pytermgui/serialization.py 74 75 76 77 78 79 80 81 82 def register_box ( self , name : str , box : widgets . boxes . Box ) -> None : \"\"\"Registers a new Box type. Args: name: The name of the box. box: The box instance. \"\"\" self . known_boxes [ name ] = box","title":"register_box()"},{"location":"reference/pytermgui/serialization/#pytermgui.serialization.Serializer.to_file","text":"Dumps widget to a file object. Parameters: Name Type Description Default obj Widget The widget to dump. required file IO [ str ] The file object it gets written to. required **json_args dict [ str , Any ] Arguments passed to json.dump . {} Source code in pytermgui/serialization.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def to_file ( self , obj : Widget , file : IO [ str ], ** json_args : dict [ str , Any ]) -> None : \"\"\"Dumps widget to a file object. Args: obj: The widget to dump. file: The file object it gets written to. **json_args: Arguments passed to `json.dump`. \"\"\" data = self . dump_to_dict ( obj ) if \"separators\" not in json_args : # this is a sub-element of a dict[str, Any], so this # should work. json_args [ \"separators\" ] = ( \",\" , \":\" ) # type: ignore # ** is supposed to be a dict, not a positional arg json . dump ( data , file , ** json_args ) # type: ignore","title":"to_file()"},{"location":"reference/pytermgui/term/","text":"This module houses the Terminal class, and its provided instance. terminal = Terminal () module-attribute Terminal instance that should be used pretty much always. ColorSystem Bases: Enum An enumeration of various terminal-supported colorsystems. Source code in pytermgui/term.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 class ColorSystem ( Enum ): \"\"\"An enumeration of various terminal-supported colorsystems.\"\"\" NO_COLOR = - 1 \"\"\"No-color terminal. See https://no-color.org/.\"\"\" STANDARD = 0 \"\"\"Standard 3-bit colorsystem of the basic 16 colors.\"\"\" EIGHT_BIT = 1 \"\"\"xterm 8-bit colors, 0-256.\"\"\" TRUE = 2 \"\"\"'True' color, a.k.a. 24-bit RGB colors.\"\"\" def __ge__ ( self , other ): \"\"\"Comparison: self >= other.\"\"\" if self . __class__ is other . __class__ : return self . value >= other . value return NotImplemented def __gt__ ( self , other ): \"\"\"Comparison: self > other.\"\"\" if self . __class__ is other . __class__ : return self . value > other . value return NotImplemented def __le__ ( self , other ): \"\"\"Comparison: self <= other.\"\"\" if self . __class__ is other . __class__ : return self . value <= other . value return NotImplemented def __lt__ ( self , other ): \"\"\"Comparison: self < other.\"\"\" if self . __class__ is other . __class__ : return self . value < other . value return NotImplemented EIGHT_BIT = 1 class-attribute xterm 8-bit colors, 0-256. NO_COLOR = - 1 class-attribute No-color terminal. See https://no-color.org/. STANDARD = 0 class-attribute Standard 3-bit colorsystem of the basic 16 colors. TRUE = 2 class-attribute 'True' color, a.k.a. 24-bit RGB colors. __ge__ ( other ) Comparison: self >= other. Source code in pytermgui/term.py 179 180 181 182 183 184 185 def __ge__ ( self , other ): \"\"\"Comparison: self >= other.\"\"\" if self . __class__ is other . __class__ : return self . value >= other . value return NotImplemented __gt__ ( other ) Comparison: self > other. Source code in pytermgui/term.py 187 188 189 190 191 192 193 def __gt__ ( self , other ): \"\"\"Comparison: self > other.\"\"\" if self . __class__ is other . __class__ : return self . value > other . value return NotImplemented __le__ ( other ) Comparison: self <= other. Source code in pytermgui/term.py 195 196 197 198 199 200 201 def __le__ ( self , other ): \"\"\"Comparison: self <= other.\"\"\" if self . __class__ is other . __class__ : return self . value <= other . value return NotImplemented __lt__ ( other ) Comparison: self < other. Source code in pytermgui/term.py 203 204 205 206 207 208 209 def __lt__ ( self , other ): \"\"\"Comparison: self < other.\"\"\" if self . __class__ is other . __class__ : return self . value < other . value return NotImplemented Recorder A class that records & exports terminal content. Source code in pytermgui/term.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 class Recorder : \"\"\"A class that records & exports terminal content.\"\"\" def __init__ ( self ) -> None : \"\"\"Initializes the Recorder.\"\"\" self . recording : list [ tuple [ str , float ]] = [] self . _start_stamp = time . time () @property def _content ( self ) -> str : \"\"\"Returns the str part of self._recording\"\"\" return \"\" . join ( data for data , _ in self . recording ) def write ( self , data : str ) -> None : \"\"\"Writes to the recorder.\"\"\" self . recording . append (( data , time . time () - self . _start_stamp )) def export_text ( self ) -> str : \"\"\"Exports current content as plain text.\"\"\" return strip_ansi ( self . _content ) def export_html ( self , prefix : str | None = None , inline_styles : bool = False ) -> str : \"\"\"Exports current content as HTML. For help on the arguments, see `pytermgui.html.to_html`. \"\"\" from .exporters import to_html # pylint: disable=import-outside-toplevel return to_html ( self . _content , prefix = prefix , inline_styles = inline_styles ) def export_svg ( self , prefix : str | None = None , inline_styles : bool = False , title : str = \"PyTermGUI\" , chrome : bool = True , ) -> str : \"\"\"Exports current content as SVG. For help on the arguments, see `pytermgui.html.to_svg`. \"\"\" from .exporters import to_svg # pylint: disable=import-outside-toplevel return to_svg ( self . _content , prefix = prefix , inline_styles = inline_styles , title = title , chrome = chrome , ) def save_plain ( self , filename : str ) -> None : \"\"\"Exports plain text content to the given file. Args: filename: The file to save to. \"\"\" with open ( filename , \"w\" , encoding = \"utf-8\" ) as file : file . write ( self . export_text ()) def save_html ( self , filename : str | None = None , prefix : str | None = None , inline_styles : bool = False , ) -> None : \"\"\"Exports HTML content to the given file. For help on the arguments, see `pytermgui.exporters.to_html`. Args: filename: The file to save to. If the filename does not contain the '.html' extension it will be appended to the end. \"\"\" if filename is None : filename = f \"PTG_ { time . time () : %Y-%m-%d %H:%M:%S } .html\" if not filename . endswith ( \".html\" ): filename += \".html\" with open ( filename , \"w\" , encoding = \"utf-8\" ) as file : file . write ( self . export_html ( prefix = prefix , inline_styles = inline_styles )) def save_svg ( # pylint: disable=too-many-arguments self , filename : str | None = None , prefix : str | None = None , chrome : bool = True , inline_styles : bool = False , title : str = \"PyTermGUI\" , ) -> None : \"\"\"Exports SVG content to the given file. For help on the arguments, see `pytermgui.exporters.to_svg`. Args: filename: The file to save to. If the filename does not contain the '.svg' extension it will be appended to the end. \"\"\" if filename is None : timeval = datetime . now () filename = f \"PTG_ { timeval : %Y-%m-%d_%H:%M:%S } .svg\" if not filename . endswith ( \".svg\" ): filename += \".svg\" with open ( filename , \"w\" , encoding = \"utf-8\" ) as file : file . write ( self . export_svg ( prefix = prefix , inline_styles = inline_styles , title = title , chrome = chrome , ) ) __init__ () Initializes the Recorder. Source code in pytermgui/term.py 39 40 41 42 43 def __init__ ( self ) -> None : \"\"\"Initializes the Recorder.\"\"\" self . recording : list [ tuple [ str , float ]] = [] self . _start_stamp = time . time () export_html ( prefix = None , inline_styles = False ) Exports current content as HTML. For help on the arguments, see pytermgui.html.to_html . Source code in pytermgui/term.py 61 62 63 64 65 66 67 68 69 70 71 def export_html ( self , prefix : str | None = None , inline_styles : bool = False ) -> str : \"\"\"Exports current content as HTML. For help on the arguments, see `pytermgui.html.to_html`. \"\"\" from .exporters import to_html # pylint: disable=import-outside-toplevel return to_html ( self . _content , prefix = prefix , inline_styles = inline_styles ) export_svg ( prefix = None , inline_styles = False , title = 'PyTermGUI' , chrome = True ) Exports current content as SVG. For help on the arguments, see pytermgui.html.to_svg . Source code in pytermgui/term.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def export_svg ( self , prefix : str | None = None , inline_styles : bool = False , title : str = \"PyTermGUI\" , chrome : bool = True , ) -> str : \"\"\"Exports current content as SVG. For help on the arguments, see `pytermgui.html.to_svg`. \"\"\" from .exporters import to_svg # pylint: disable=import-outside-toplevel return to_svg ( self . _content , prefix = prefix , inline_styles = inline_styles , title = title , chrome = chrome , ) export_text () Exports current content as plain text. Source code in pytermgui/term.py 56 57 58 59 def export_text ( self ) -> str : \"\"\"Exports current content as plain text.\"\"\" return strip_ansi ( self . _content ) save_html ( filename = None , prefix = None , inline_styles = False ) Exports HTML content to the given file. For help on the arguments, see pytermgui.exporters.to_html . Parameters: Name Type Description Default filename str | None The file to save to. If the filename does not contain the '.html' extension it will be appended to the end. None Source code in pytermgui/term.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def save_html ( self , filename : str | None = None , prefix : str | None = None , inline_styles : bool = False , ) -> None : \"\"\"Exports HTML content to the given file. For help on the arguments, see `pytermgui.exporters.to_html`. Args: filename: The file to save to. If the filename does not contain the '.html' extension it will be appended to the end. \"\"\" if filename is None : filename = f \"PTG_ { time . time () : %Y-%m-%d %H:%M:%S } .html\" if not filename . endswith ( \".html\" ): filename += \".html\" with open ( filename , \"w\" , encoding = \"utf-8\" ) as file : file . write ( self . export_html ( prefix = prefix , inline_styles = inline_styles )) save_plain ( filename ) Exports plain text content to the given file. Parameters: Name Type Description Default filename str The file to save to. required Source code in pytermgui/term.py 95 96 97 98 99 100 101 102 103 def save_plain ( self , filename : str ) -> None : \"\"\"Exports plain text content to the given file. Args: filename: The file to save to. \"\"\" with open ( filename , \"w\" , encoding = \"utf-8\" ) as file : file . write ( self . export_text ()) save_svg ( filename = None , prefix = None , chrome = True , inline_styles = False , title = 'PyTermGUI' ) Exports SVG content to the given file. For help on the arguments, see pytermgui.exporters.to_svg . Parameters: Name Type Description Default filename str | None The file to save to. If the filename does not contain the '.svg' extension it will be appended to the end. None Source code in pytermgui/term.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def save_svg ( # pylint: disable=too-many-arguments self , filename : str | None = None , prefix : str | None = None , chrome : bool = True , inline_styles : bool = False , title : str = \"PyTermGUI\" , ) -> None : \"\"\"Exports SVG content to the given file. For help on the arguments, see `pytermgui.exporters.to_svg`. Args: filename: The file to save to. If the filename does not contain the '.svg' extension it will be appended to the end. \"\"\" if filename is None : timeval = datetime . now () filename = f \"PTG_ { timeval : %Y-%m-%d_%H:%M:%S } .svg\" if not filename . endswith ( \".svg\" ): filename += \".svg\" with open ( filename , \"w\" , encoding = \"utf-8\" ) as file : file . write ( self . export_svg ( prefix = prefix , inline_styles = inline_styles , title = title , chrome = chrome , ) ) write ( data ) Writes to the recorder. Source code in pytermgui/term.py 51 52 53 54 def write ( self , data : str ) -> None : \"\"\"Writes to the recorder.\"\"\" self . recording . append (( data , time . time () - self . _start_stamp )) Terminal A class to store & access data about a terminal. Source code in pytermgui/term.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 class Terminal : # pylint: disable=too-many-instance-attributes \"\"\"A class to store & access data about a terminal.\"\"\" RESIZE = 0 \"\"\"Event sent out when the terminal has been resized. Arguments passed: - New size: tuple[int, int] \"\"\" margins = [ 0 , 0 , 0 , 0 ] \"\"\"Not quite sure what this does at the moment.\"\"\" displayhook_installed : bool = False \"\"\"This is set to True when `pretty.install` is called.\"\"\" origin : tuple [ int , int ] = ( 1 , 1 ) \"\"\"Origin of the internal coordinate system.\"\"\" def __init__ ( self , stream : TextIO | None = None , * , size : tuple [ int , int ] | None = None , ) -> None : \"\"\"Initialize `Terminal` class.\"\"\" if stream is None : stream = sys . stdout self . _size = size self . _stream = stream or sys . stdout self . _recorder : Recorder | None = None self . size : tuple [ int , int ] = self . _get_size () self . forced_colorsystem : ColorSystem | None = _get_env_colorsys () self . _listeners : dict [ int , list [ Callable [ ... , Any ]]] = {} if hasattr ( signal , \"SIGWINCH\" ): signal . signal ( signal . SIGWINCH , self . _update_size ) else : from threading import Thread # pylint: disable=import-outside-toplevel Thread ( name = \"windows_terminal_resize\" , target = self . _window_terminal_resize , daemon = True , ) . start () self . _diff_buffer = [ [ \"\" for _ in range ( self . width )] for y in range ( self . height ) ] def _window_terminal_resize ( self ): from time import sleep # pylint: disable=import-outside-toplevel _previous = get_terminal_size () while True : _next = get_terminal_size () if _previous != _next : self . _update_size () _previous = _next sleep ( 0.001 ) def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Returns a cool looking repr.\"\"\" name = type ( self ) . __name__ yield f \"< { name } stream= { self . _stream } size= { self . size } >\" @cached_property def resolution ( self ) -> tuple [ int , int ]: \"\"\"Returns the terminal's pixel based resolution. Only evaluated on demand. \"\"\" if self . isatty (): sys . stdout . write ( \" \\x1b [14t\" ) sys . stdout . flush () # Some terminals may not respond to a pixel size query, so we send # a timed-out getch call with a default response of 1280x720. output = getch_timeout ( 0.1 , default = \" \\x1b [4;720;1280t\" ) match = RE_PIXEL_SIZE . match ( output ) if match is not None : return ( int ( match [ 2 ]), int ( match [ 1 ])) return ( 0 , 0 ) @property def pixel_size ( self ) -> tuple [ int , int ]: \"\"\"DEPRECATED: Returns the terminal's pixel resolution. Prefer terminal.resolution. \"\"\" return self . resolution def _call_listener ( self , event : int , data : Any ) -> None : \"\"\"Calls callbacks for event. Args: event: A terminal event. data: Arbitrary data passed to the callback. \"\"\" if event in self . _listeners : for callback in self . _listeners [ event ]: callback ( data ) def _get_size ( self ) -> tuple [ int , int ]: \"\"\"Gets the screen size with origin substracted.\"\"\" if self . _size is not None : return self . _size size = get_terminal_size () return ( size [ 0 ], size [ 1 ]) def _update_size ( self , * _ : Any ) -> None : \"\"\"Resize terminal when SIGWINCH occurs, and call listeners.\"\"\" if hasattr ( self , \"resolution\" ): del self . resolution self . size = self . _get_size () self . _call_listener ( self . RESIZE , self . size ) # Wipe the screen in case anything got messed up self . write ( \" \\x1b [2J\" ) @property def width ( self ) -> int : \"\"\"Gets the current width of the terminal.\"\"\" return self . size [ 0 ] @property def height ( self ) -> int : \"\"\"Gets the current height of the terminal.\"\"\" return self . size [ 1 ] @staticmethod def is_interactive () -> bool : \"\"\"Determines whether shell is interactive. A shell is interactive if it is run from `python3` or `python3 -i`. \"\"\" return hasattr ( sys , \"ps1\" ) @property def forced_colorsystem ( self ) -> ColorSystem | None : \"\"\"Forces a color system type on this terminal.\"\"\" return self . _forced_colorsystem @forced_colorsystem . setter def forced_colorsystem ( self , new : ColorSystem | None ) -> None : \"\"\"Sets a colorsystem, clears colorsystem cache.\"\"\" self . _forced_colorsystem = new @property def colorsystem ( self ) -> ColorSystem : \"\"\"Gets the current terminal's supported color system.\"\"\" if self . forced_colorsystem is not None : return self . forced_colorsystem if os . getenv ( \"NO_COLOR\" ) is not None : return ColorSystem . NO_COLOR term = os . getenv ( \"TERM\" , \"\" ) color_term = os . getenv ( \"COLORTERM\" , \"\" ) . strip () . lower () if color_term == \"\" : color_term = term . split ( \"xterm-\" )[ - 1 ] if color_term in [ \"24bit\" , \"truecolor\" ]: return ColorSystem . TRUE if color_term == \"256color\" : return ColorSystem . EIGHT_BIT return ColorSystem . STANDARD @contextmanager def record ( self ) -> Generator [ Recorder , None , None ]: \"\"\"Records the terminal's stream.\"\"\" if self . _recorder is not None : raise RuntimeError ( f \" { self !r} is already recording.\" ) try : self . _recorder = Recorder () yield self . _recorder finally : self . _recorder = None @contextmanager def no_record ( self ) -> Generator [ None , None , None ]: \"\"\"Pauses recording for the duration of the context.\"\"\" recorder = self . _recorder try : self . _recorder = None yield finally : self . _recorder = recorder @contextmanager def frame ( self ) -> Generator [ StringIO , None , None ]: \"\"\"Notifies the emulator of the inner content being a single frame. See https://gist.github.com/christianparpart/d8a62cc1ab659194337d73e399004036! \"\"\" buffer = StringIO () try : with self . no_record (): self . write ( \" \\x1b [?2026h\" ) yield buffer finally : self . write ( buffer . getvalue ()) with self . no_record (): self . write ( \" \\x1b [?2026l\" ) self . flush () @staticmethod def isatty () -> bool : \"\"\"Returns whether sys.stdin is a tty.\"\"\" return sys . stdin . isatty () def replay ( self , recorder : Recorder ) -> None : \"\"\"Replays a recording.\"\"\" last_time = 0.0 for data , delay in recorder . recording : if last_time > 0.0 : time . sleep ( delay - last_time ) self . write ( data , flush = True ) last_time = delay def subscribe ( self , event : int , callback : Callable [ ... , Any ]) -> None : \"\"\"Subcribes a callback to be called when event occurs. Args: event: The terminal event that calls callback. callback: The callable to be called. The signature of this callable is dependent on the event. See the documentation of the specific event for more information. \"\"\" if not event in self . _listeners : self . _listeners [ event ] = [] self . _listeners [ event ] . append ( callback ) def write ( self , data : str , pos : tuple [ int , int ] | None = None , flush : bool = False , slice_too_long : bool = True , ) -> None : \"\"\"Writes the given data to the terminal's stream. Args: data: The data to write. pos: Terminal-character space position to write the data to, (x, y). flush: If set, `flush` will be called on the stream after reading. slice_too_long: If set, lines that are outside of the terminal will be sliced to fit. Involves a sizable performance hit. \"\"\" def _slice ( line : str , maximum : int ) -> str : length = 0 sliced = \"\" for char in line : sliced += char if char == \" \\x1b \" : continue if ( length > maximum and real_length ( sliced ) > maximum and not has_open_sequence ( sliced ) ): break length += 1 return sliced if \" \\x1b [2J\" in data : self . clear_stream () if pos is not None : xpos , ypos = pos if slice_too_long : if not self . height + self . origin [ 1 ] + 1 > ypos >= 0 : return maximum = self . width - xpos + self . origin [ 0 ] if xpos < self . origin [ 0 ]: xpos = self . origin [ 0 ] sliced = _slice ( data , maximum ) if len ( data ) > maximum else data data = f \" \\x1b [ { ypos } ; { xpos } H { sliced } \\x1b [0m\" else : data = f \" \\x1b [ { ypos } ; { xpos } H { data } \" self . _stream . write ( data ) if self . _recorder is not None : self . _recorder . write ( data ) if flush : self . _stream . flush () def clear_stream ( self ) -> None : \"\"\"Clears (truncates) the terminal's stream.\"\"\" try : self . _stream . truncate ( 0 ) except OSError as error : if error . errno != errno . EINVAL and os . name != \"nt\" : raise self . _stream . write ( \" \\x1b [2J\" ) def print ( self , * items , pos : tuple [ int , int ] | None = None , sep : str = \" \" , end = \" \\n \" , flush : bool = True , ) -> None : \"\"\"Prints items to the stream. All arguments not mentioned here are analogous to `print`. Args: pos: Terminal-character space position to write the data to, (x, y). \"\"\" self . write ( sep . join ( map ( str , items )) + end , pos = pos , flush = flush ) def flush ( self ) -> None : \"\"\"Flushes self._stream.\"\"\" self . _stream . flush () RESIZE = 0 class-attribute Event sent out when the terminal has been resized. Arguments passed: - New size: tuple[int, int] displayhook_installed : bool = False class-attribute This is set to True when pretty.install is called. margins = [ 0 , 0 , 0 , 0 ] class-attribute Not quite sure what this does at the moment. origin : tuple [ int , int ] = ( 1 , 1 ) class-attribute Origin of the internal coordinate system. __fancy_repr__ () Returns a cool looking repr. Source code in pytermgui/term.py 292 293 294 295 296 297 def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Returns a cool looking repr.\"\"\" name = type ( self ) . __name__ yield f \"< { name } stream= { self . _stream } size= { self . size } >\" __init__ ( stream = None , * , size = None ) Initialize Terminal class. Source code in pytermgui/term.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def __init__ ( self , stream : TextIO | None = None , * , size : tuple [ int , int ] | None = None , ) -> None : \"\"\"Initialize `Terminal` class.\"\"\" if stream is None : stream = sys . stdout self . _size = size self . _stream = stream or sys . stdout self . _recorder : Recorder | None = None self . size : tuple [ int , int ] = self . _get_size () self . forced_colorsystem : ColorSystem | None = _get_env_colorsys () self . _listeners : dict [ int , list [ Callable [ ... , Any ]]] = {} if hasattr ( signal , \"SIGWINCH\" ): signal . signal ( signal . SIGWINCH , self . _update_size ) else : from threading import Thread # pylint: disable=import-outside-toplevel Thread ( name = \"windows_terminal_resize\" , target = self . _window_terminal_resize , daemon = True , ) . start () self . _diff_buffer = [ [ \"\" for _ in range ( self . width )] for y in range ( self . height ) ] clear_stream () Clears (truncates) the terminal's stream. Source code in pytermgui/term.py 565 566 567 568 569 570 571 572 573 574 575 def clear_stream ( self ) -> None : \"\"\"Clears (truncates) the terminal's stream.\"\"\" try : self . _stream . truncate ( 0 ) except OSError as error : if error . errno != errno . EINVAL and os . name != \"nt\" : raise self . _stream . write ( \" \\x1b [2J\" ) colorsystem () property Gets the current terminal's supported color system. Source code in pytermgui/term.py 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 @property def colorsystem ( self ) -> ColorSystem : \"\"\"Gets the current terminal's supported color system.\"\"\" if self . forced_colorsystem is not None : return self . forced_colorsystem if os . getenv ( \"NO_COLOR\" ) is not None : return ColorSystem . NO_COLOR term = os . getenv ( \"TERM\" , \"\" ) color_term = os . getenv ( \"COLORTERM\" , \"\" ) . strip () . lower () if color_term == \"\" : color_term = term . split ( \"xterm-\" )[ - 1 ] if color_term in [ \"24bit\" , \"truecolor\" ]: return ColorSystem . TRUE if color_term == \"256color\" : return ColorSystem . EIGHT_BIT return ColorSystem . STANDARD flush () Flushes self._stream. Source code in pytermgui/term.py 596 597 598 599 def flush ( self ) -> None : \"\"\"Flushes self._stream.\"\"\" self . _stream . flush () forced_colorsystem () property writable Forces a color system type on this terminal. Source code in pytermgui/term.py 384 385 386 387 388 @property def forced_colorsystem ( self ) -> ColorSystem | None : \"\"\"Forces a color system type on this terminal.\"\"\" return self . _forced_colorsystem frame () Notifies the emulator of the inner content being a single frame. See https://gist.github.com/christianparpart/d8a62cc1ab659194337d73e399004036! Source code in pytermgui/term.py 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 @contextmanager def frame ( self ) -> Generator [ StringIO , None , None ]: \"\"\"Notifies the emulator of the inner content being a single frame. See https://gist.github.com/christianparpart/d8a62cc1ab659194337d73e399004036! \"\"\" buffer = StringIO () try : with self . no_record (): self . write ( \" \\x1b [?2026h\" ) yield buffer finally : self . write ( buffer . getvalue ()) with self . no_record (): self . write ( \" \\x1b [?2026l\" ) self . flush () height () property Gets the current height of the terminal. Source code in pytermgui/term.py 369 370 371 372 373 @property def height ( self ) -> int : \"\"\"Gets the current height of the terminal.\"\"\" return self . size [ 1 ] is_interactive () staticmethod Determines whether shell is interactive. A shell is interactive if it is run from python3 or python3 -i . Source code in pytermgui/term.py 375 376 377 378 379 380 381 382 @staticmethod def is_interactive () -> bool : \"\"\"Determines whether shell is interactive. A shell is interactive if it is run from `python3` or `python3 -i`. \"\"\" return hasattr ( sys , \"ps1\" ) isatty () staticmethod Returns whether sys.stdin is a tty. Source code in pytermgui/term.py 467 468 469 470 471 @staticmethod def isatty () -> bool : \"\"\"Returns whether sys.stdin is a tty.\"\"\" return sys . stdin . isatty () no_record () Pauses recording for the duration of the context. Source code in pytermgui/term.py 434 435 436 437 438 439 440 441 442 443 444 445 @contextmanager def no_record ( self ) -> Generator [ None , None , None ]: \"\"\"Pauses recording for the duration of the context.\"\"\" recorder = self . _recorder try : self . _recorder = None yield finally : self . _recorder = recorder pixel_size () property DEPRECATED: Returns the terminal's pixel resolution. Prefer terminal.resolution. Source code in pytermgui/term.py 320 321 322 323 324 325 326 327 @property def pixel_size ( self ) -> tuple [ int , int ]: \"\"\"DEPRECATED: Returns the terminal's pixel resolution. Prefer terminal.resolution. \"\"\" return self . resolution print ( items , pos = None , sep = ' ' , end = ' \\n ' , flush = True ) Prints items to the stream. All arguments not mentioned here are analogous to print . Parameters: Name Type Description Default pos tuple [ int , int ] | None Terminal-character space position to write the data to, (x, y). None Source code in pytermgui/term.py 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 def print ( self , * items , pos : tuple [ int , int ] | None = None , sep : str = \" \" , end = \" \\n \" , flush : bool = True , ) -> None : \"\"\"Prints items to the stream. All arguments not mentioned here are analogous to `print`. Args: pos: Terminal-character space position to write the data to, (x, y). \"\"\" self . write ( sep . join ( map ( str , items )) + end , pos = pos , flush = flush ) record () Records the terminal's stream. Source code in pytermgui/term.py 420 421 422 423 424 425 426 427 428 429 430 431 432 @contextmanager def record ( self ) -> Generator [ Recorder , None , None ]: \"\"\"Records the terminal's stream.\"\"\" if self . _recorder is not None : raise RuntimeError ( f \" { self !r} is already recording.\" ) try : self . _recorder = Recorder () yield self . _recorder finally : self . _recorder = None replay ( recorder ) Replays a recording. Source code in pytermgui/term.py 473 474 475 476 477 478 479 480 481 482 def replay ( self , recorder : Recorder ) -> None : \"\"\"Replays a recording.\"\"\" last_time = 0.0 for data , delay in recorder . recording : if last_time > 0.0 : time . sleep ( delay - last_time ) self . write ( data , flush = True ) last_time = delay resolution () property cached Returns the terminal's pixel based resolution. Only evaluated on demand. Source code in pytermgui/term.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 @cached_property def resolution ( self ) -> tuple [ int , int ]: \"\"\"Returns the terminal's pixel based resolution. Only evaluated on demand. \"\"\" if self . isatty (): sys . stdout . write ( \" \\x1b [14t\" ) sys . stdout . flush () # Some terminals may not respond to a pixel size query, so we send # a timed-out getch call with a default response of 1280x720. output = getch_timeout ( 0.1 , default = \" \\x1b [4;720;1280t\" ) match = RE_PIXEL_SIZE . match ( output ) if match is not None : return ( int ( match [ 2 ]), int ( match [ 1 ])) return ( 0 , 0 ) subscribe ( event , callback ) Subcribes a callback to be called when event occurs. Parameters: Name Type Description Default event int The terminal event that calls callback. required callback Callable [..., Any ] The callable to be called. The signature of this callable is dependent on the event. See the documentation of the specific event for more information. required Source code in pytermgui/term.py 484 485 486 487 488 489 490 491 492 493 494 495 496 497 def subscribe ( self , event : int , callback : Callable [ ... , Any ]) -> None : \"\"\"Subcribes a callback to be called when event occurs. Args: event: The terminal event that calls callback. callback: The callable to be called. The signature of this callable is dependent on the event. See the documentation of the specific event for more information. \"\"\" if not event in self . _listeners : self . _listeners [ event ] = [] self . _listeners [ event ] . append ( callback ) width () property Gets the current width of the terminal. Source code in pytermgui/term.py 363 364 365 366 367 @property def width ( self ) -> int : \"\"\"Gets the current width of the terminal.\"\"\" return self . size [ 0 ] write ( data , pos = None , flush = False , slice_too_long = True ) Writes the given data to the terminal's stream. Parameters: Name Type Description Default data str The data to write. required pos tuple [ int , int ] | None Terminal-character space position to write the data to, (x, y). None flush bool If set, flush will be called on the stream after reading. False slice_too_long bool If set, lines that are outside of the terminal will be sliced to fit. Involves a sizable performance hit. True Source code in pytermgui/term.py 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 def write ( self , data : str , pos : tuple [ int , int ] | None = None , flush : bool = False , slice_too_long : bool = True , ) -> None : \"\"\"Writes the given data to the terminal's stream. Args: data: The data to write. pos: Terminal-character space position to write the data to, (x, y). flush: If set, `flush` will be called on the stream after reading. slice_too_long: If set, lines that are outside of the terminal will be sliced to fit. Involves a sizable performance hit. \"\"\" def _slice ( line : str , maximum : int ) -> str : length = 0 sliced = \"\" for char in line : sliced += char if char == \" \\x1b \" : continue if ( length > maximum and real_length ( sliced ) > maximum and not has_open_sequence ( sliced ) ): break length += 1 return sliced if \" \\x1b [2J\" in data : self . clear_stream () if pos is not None : xpos , ypos = pos if slice_too_long : if not self . height + self . origin [ 1 ] + 1 > ypos >= 0 : return maximum = self . width - xpos + self . origin [ 0 ] if xpos < self . origin [ 0 ]: xpos = self . origin [ 0 ] sliced = _slice ( data , maximum ) if len ( data ) > maximum else data data = f \" \\x1b [ { ypos } ; { xpos } H { sliced } \\x1b [0m\" else : data = f \" \\x1b [ { ypos } ; { xpos } H { data } \" self . _stream . write ( data ) if self . _recorder is not None : self . _recorder . write ( data ) if flush : self . _stream . flush () get_terminal () Gets the default terminal instance used by the module. Source code in pytermgui/term.py 612 613 614 615 def get_terminal () -> Terminal : \"\"\"Gets the default terminal instance used by the module.\"\"\" return terminal set_global_terminal ( new ) Sets the terminal instance to be used by the module. Source code in pytermgui/term.py 606 607 608 609 def set_global_terminal ( new : Terminal ) -> None : \"\"\"Sets the terminal instance to be used by the module.\"\"\" globals ()[ \"terminal\" ] = new","title":"term"},{"location":"reference/pytermgui/term/#pytermgui.term.terminal","text":"Terminal instance that should be used pretty much always.","title":"terminal"},{"location":"reference/pytermgui/term/#pytermgui.term.ColorSystem","text":"Bases: Enum An enumeration of various terminal-supported colorsystems. Source code in pytermgui/term.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 class ColorSystem ( Enum ): \"\"\"An enumeration of various terminal-supported colorsystems.\"\"\" NO_COLOR = - 1 \"\"\"No-color terminal. See https://no-color.org/.\"\"\" STANDARD = 0 \"\"\"Standard 3-bit colorsystem of the basic 16 colors.\"\"\" EIGHT_BIT = 1 \"\"\"xterm 8-bit colors, 0-256.\"\"\" TRUE = 2 \"\"\"'True' color, a.k.a. 24-bit RGB colors.\"\"\" def __ge__ ( self , other ): \"\"\"Comparison: self >= other.\"\"\" if self . __class__ is other . __class__ : return self . value >= other . value return NotImplemented def __gt__ ( self , other ): \"\"\"Comparison: self > other.\"\"\" if self . __class__ is other . __class__ : return self . value > other . value return NotImplemented def __le__ ( self , other ): \"\"\"Comparison: self <= other.\"\"\" if self . __class__ is other . __class__ : return self . value <= other . value return NotImplemented def __lt__ ( self , other ): \"\"\"Comparison: self < other.\"\"\" if self . __class__ is other . __class__ : return self . value < other . value return NotImplemented","title":"ColorSystem"},{"location":"reference/pytermgui/term/#pytermgui.term.ColorSystem.EIGHT_BIT","text":"xterm 8-bit colors, 0-256.","title":"EIGHT_BIT"},{"location":"reference/pytermgui/term/#pytermgui.term.ColorSystem.NO_COLOR","text":"No-color terminal. See https://no-color.org/.","title":"NO_COLOR"},{"location":"reference/pytermgui/term/#pytermgui.term.ColorSystem.STANDARD","text":"Standard 3-bit colorsystem of the basic 16 colors.","title":"STANDARD"},{"location":"reference/pytermgui/term/#pytermgui.term.ColorSystem.TRUE","text":"'True' color, a.k.a. 24-bit RGB colors.","title":"TRUE"},{"location":"reference/pytermgui/term/#pytermgui.term.ColorSystem.__ge__","text":"Comparison: self >= other. Source code in pytermgui/term.py 179 180 181 182 183 184 185 def __ge__ ( self , other ): \"\"\"Comparison: self >= other.\"\"\" if self . __class__ is other . __class__ : return self . value >= other . value return NotImplemented","title":"__ge__()"},{"location":"reference/pytermgui/term/#pytermgui.term.ColorSystem.__gt__","text":"Comparison: self > other. Source code in pytermgui/term.py 187 188 189 190 191 192 193 def __gt__ ( self , other ): \"\"\"Comparison: self > other.\"\"\" if self . __class__ is other . __class__ : return self . value > other . value return NotImplemented","title":"__gt__()"},{"location":"reference/pytermgui/term/#pytermgui.term.ColorSystem.__le__","text":"Comparison: self <= other. Source code in pytermgui/term.py 195 196 197 198 199 200 201 def __le__ ( self , other ): \"\"\"Comparison: self <= other.\"\"\" if self . __class__ is other . __class__ : return self . value <= other . value return NotImplemented","title":"__le__()"},{"location":"reference/pytermgui/term/#pytermgui.term.ColorSystem.__lt__","text":"Comparison: self < other. Source code in pytermgui/term.py 203 204 205 206 207 208 209 def __lt__ ( self , other ): \"\"\"Comparison: self < other.\"\"\" if self . __class__ is other . __class__ : return self . value < other . value return NotImplemented","title":"__lt__()"},{"location":"reference/pytermgui/term/#pytermgui.term.Recorder","text":"A class that records & exports terminal content. Source code in pytermgui/term.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 class Recorder : \"\"\"A class that records & exports terminal content.\"\"\" def __init__ ( self ) -> None : \"\"\"Initializes the Recorder.\"\"\" self . recording : list [ tuple [ str , float ]] = [] self . _start_stamp = time . time () @property def _content ( self ) -> str : \"\"\"Returns the str part of self._recording\"\"\" return \"\" . join ( data for data , _ in self . recording ) def write ( self , data : str ) -> None : \"\"\"Writes to the recorder.\"\"\" self . recording . append (( data , time . time () - self . _start_stamp )) def export_text ( self ) -> str : \"\"\"Exports current content as plain text.\"\"\" return strip_ansi ( self . _content ) def export_html ( self , prefix : str | None = None , inline_styles : bool = False ) -> str : \"\"\"Exports current content as HTML. For help on the arguments, see `pytermgui.html.to_html`. \"\"\" from .exporters import to_html # pylint: disable=import-outside-toplevel return to_html ( self . _content , prefix = prefix , inline_styles = inline_styles ) def export_svg ( self , prefix : str | None = None , inline_styles : bool = False , title : str = \"PyTermGUI\" , chrome : bool = True , ) -> str : \"\"\"Exports current content as SVG. For help on the arguments, see `pytermgui.html.to_svg`. \"\"\" from .exporters import to_svg # pylint: disable=import-outside-toplevel return to_svg ( self . _content , prefix = prefix , inline_styles = inline_styles , title = title , chrome = chrome , ) def save_plain ( self , filename : str ) -> None : \"\"\"Exports plain text content to the given file. Args: filename: The file to save to. \"\"\" with open ( filename , \"w\" , encoding = \"utf-8\" ) as file : file . write ( self . export_text ()) def save_html ( self , filename : str | None = None , prefix : str | None = None , inline_styles : bool = False , ) -> None : \"\"\"Exports HTML content to the given file. For help on the arguments, see `pytermgui.exporters.to_html`. Args: filename: The file to save to. If the filename does not contain the '.html' extension it will be appended to the end. \"\"\" if filename is None : filename = f \"PTG_ { time . time () : %Y-%m-%d %H:%M:%S } .html\" if not filename . endswith ( \".html\" ): filename += \".html\" with open ( filename , \"w\" , encoding = \"utf-8\" ) as file : file . write ( self . export_html ( prefix = prefix , inline_styles = inline_styles )) def save_svg ( # pylint: disable=too-many-arguments self , filename : str | None = None , prefix : str | None = None , chrome : bool = True , inline_styles : bool = False , title : str = \"PyTermGUI\" , ) -> None : \"\"\"Exports SVG content to the given file. For help on the arguments, see `pytermgui.exporters.to_svg`. Args: filename: The file to save to. If the filename does not contain the '.svg' extension it will be appended to the end. \"\"\" if filename is None : timeval = datetime . now () filename = f \"PTG_ { timeval : %Y-%m-%d_%H:%M:%S } .svg\" if not filename . endswith ( \".svg\" ): filename += \".svg\" with open ( filename , \"w\" , encoding = \"utf-8\" ) as file : file . write ( self . export_svg ( prefix = prefix , inline_styles = inline_styles , title = title , chrome = chrome , ) )","title":"Recorder"},{"location":"reference/pytermgui/term/#pytermgui.term.Recorder.__init__","text":"Initializes the Recorder. Source code in pytermgui/term.py 39 40 41 42 43 def __init__ ( self ) -> None : \"\"\"Initializes the Recorder.\"\"\" self . recording : list [ tuple [ str , float ]] = [] self . _start_stamp = time . time ()","title":"__init__()"},{"location":"reference/pytermgui/term/#pytermgui.term.Recorder.export_html","text":"Exports current content as HTML. For help on the arguments, see pytermgui.html.to_html . Source code in pytermgui/term.py 61 62 63 64 65 66 67 68 69 70 71 def export_html ( self , prefix : str | None = None , inline_styles : bool = False ) -> str : \"\"\"Exports current content as HTML. For help on the arguments, see `pytermgui.html.to_html`. \"\"\" from .exporters import to_html # pylint: disable=import-outside-toplevel return to_html ( self . _content , prefix = prefix , inline_styles = inline_styles )","title":"export_html()"},{"location":"reference/pytermgui/term/#pytermgui.term.Recorder.export_svg","text":"Exports current content as SVG. For help on the arguments, see pytermgui.html.to_svg . Source code in pytermgui/term.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def export_svg ( self , prefix : str | None = None , inline_styles : bool = False , title : str = \"PyTermGUI\" , chrome : bool = True , ) -> str : \"\"\"Exports current content as SVG. For help on the arguments, see `pytermgui.html.to_svg`. \"\"\" from .exporters import to_svg # pylint: disable=import-outside-toplevel return to_svg ( self . _content , prefix = prefix , inline_styles = inline_styles , title = title , chrome = chrome , )","title":"export_svg()"},{"location":"reference/pytermgui/term/#pytermgui.term.Recorder.export_text","text":"Exports current content as plain text. Source code in pytermgui/term.py 56 57 58 59 def export_text ( self ) -> str : \"\"\"Exports current content as plain text.\"\"\" return strip_ansi ( self . _content )","title":"export_text()"},{"location":"reference/pytermgui/term/#pytermgui.term.Recorder.save_html","text":"Exports HTML content to the given file. For help on the arguments, see pytermgui.exporters.to_html . Parameters: Name Type Description Default filename str | None The file to save to. If the filename does not contain the '.html' extension it will be appended to the end. None Source code in pytermgui/term.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def save_html ( self , filename : str | None = None , prefix : str | None = None , inline_styles : bool = False , ) -> None : \"\"\"Exports HTML content to the given file. For help on the arguments, see `pytermgui.exporters.to_html`. Args: filename: The file to save to. If the filename does not contain the '.html' extension it will be appended to the end. \"\"\" if filename is None : filename = f \"PTG_ { time . time () : %Y-%m-%d %H:%M:%S } .html\" if not filename . endswith ( \".html\" ): filename += \".html\" with open ( filename , \"w\" , encoding = \"utf-8\" ) as file : file . write ( self . export_html ( prefix = prefix , inline_styles = inline_styles ))","title":"save_html()"},{"location":"reference/pytermgui/term/#pytermgui.term.Recorder.save_plain","text":"Exports plain text content to the given file. Parameters: Name Type Description Default filename str The file to save to. required Source code in pytermgui/term.py 95 96 97 98 99 100 101 102 103 def save_plain ( self , filename : str ) -> None : \"\"\"Exports plain text content to the given file. Args: filename: The file to save to. \"\"\" with open ( filename , \"w\" , encoding = \"utf-8\" ) as file : file . write ( self . export_text ())","title":"save_plain()"},{"location":"reference/pytermgui/term/#pytermgui.term.Recorder.save_svg","text":"Exports SVG content to the given file. For help on the arguments, see pytermgui.exporters.to_svg . Parameters: Name Type Description Default filename str | None The file to save to. If the filename does not contain the '.svg' extension it will be appended to the end. None Source code in pytermgui/term.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def save_svg ( # pylint: disable=too-many-arguments self , filename : str | None = None , prefix : str | None = None , chrome : bool = True , inline_styles : bool = False , title : str = \"PyTermGUI\" , ) -> None : \"\"\"Exports SVG content to the given file. For help on the arguments, see `pytermgui.exporters.to_svg`. Args: filename: The file to save to. If the filename does not contain the '.svg' extension it will be appended to the end. \"\"\" if filename is None : timeval = datetime . now () filename = f \"PTG_ { timeval : %Y-%m-%d_%H:%M:%S } .svg\" if not filename . endswith ( \".svg\" ): filename += \".svg\" with open ( filename , \"w\" , encoding = \"utf-8\" ) as file : file . write ( self . export_svg ( prefix = prefix , inline_styles = inline_styles , title = title , chrome = chrome , ) )","title":"save_svg()"},{"location":"reference/pytermgui/term/#pytermgui.term.Recorder.write","text":"Writes to the recorder. Source code in pytermgui/term.py 51 52 53 54 def write ( self , data : str ) -> None : \"\"\"Writes to the recorder.\"\"\" self . recording . append (( data , time . time () - self . _start_stamp ))","title":"write()"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal","text":"A class to store & access data about a terminal. Source code in pytermgui/term.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 class Terminal : # pylint: disable=too-many-instance-attributes \"\"\"A class to store & access data about a terminal.\"\"\" RESIZE = 0 \"\"\"Event sent out when the terminal has been resized. Arguments passed: - New size: tuple[int, int] \"\"\" margins = [ 0 , 0 , 0 , 0 ] \"\"\"Not quite sure what this does at the moment.\"\"\" displayhook_installed : bool = False \"\"\"This is set to True when `pretty.install` is called.\"\"\" origin : tuple [ int , int ] = ( 1 , 1 ) \"\"\"Origin of the internal coordinate system.\"\"\" def __init__ ( self , stream : TextIO | None = None , * , size : tuple [ int , int ] | None = None , ) -> None : \"\"\"Initialize `Terminal` class.\"\"\" if stream is None : stream = sys . stdout self . _size = size self . _stream = stream or sys . stdout self . _recorder : Recorder | None = None self . size : tuple [ int , int ] = self . _get_size () self . forced_colorsystem : ColorSystem | None = _get_env_colorsys () self . _listeners : dict [ int , list [ Callable [ ... , Any ]]] = {} if hasattr ( signal , \"SIGWINCH\" ): signal . signal ( signal . SIGWINCH , self . _update_size ) else : from threading import Thread # pylint: disable=import-outside-toplevel Thread ( name = \"windows_terminal_resize\" , target = self . _window_terminal_resize , daemon = True , ) . start () self . _diff_buffer = [ [ \"\" for _ in range ( self . width )] for y in range ( self . height ) ] def _window_terminal_resize ( self ): from time import sleep # pylint: disable=import-outside-toplevel _previous = get_terminal_size () while True : _next = get_terminal_size () if _previous != _next : self . _update_size () _previous = _next sleep ( 0.001 ) def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Returns a cool looking repr.\"\"\" name = type ( self ) . __name__ yield f \"< { name } stream= { self . _stream } size= { self . size } >\" @cached_property def resolution ( self ) -> tuple [ int , int ]: \"\"\"Returns the terminal's pixel based resolution. Only evaluated on demand. \"\"\" if self . isatty (): sys . stdout . write ( \" \\x1b [14t\" ) sys . stdout . flush () # Some terminals may not respond to a pixel size query, so we send # a timed-out getch call with a default response of 1280x720. output = getch_timeout ( 0.1 , default = \" \\x1b [4;720;1280t\" ) match = RE_PIXEL_SIZE . match ( output ) if match is not None : return ( int ( match [ 2 ]), int ( match [ 1 ])) return ( 0 , 0 ) @property def pixel_size ( self ) -> tuple [ int , int ]: \"\"\"DEPRECATED: Returns the terminal's pixel resolution. Prefer terminal.resolution. \"\"\" return self . resolution def _call_listener ( self , event : int , data : Any ) -> None : \"\"\"Calls callbacks for event. Args: event: A terminal event. data: Arbitrary data passed to the callback. \"\"\" if event in self . _listeners : for callback in self . _listeners [ event ]: callback ( data ) def _get_size ( self ) -> tuple [ int , int ]: \"\"\"Gets the screen size with origin substracted.\"\"\" if self . _size is not None : return self . _size size = get_terminal_size () return ( size [ 0 ], size [ 1 ]) def _update_size ( self , * _ : Any ) -> None : \"\"\"Resize terminal when SIGWINCH occurs, and call listeners.\"\"\" if hasattr ( self , \"resolution\" ): del self . resolution self . size = self . _get_size () self . _call_listener ( self . RESIZE , self . size ) # Wipe the screen in case anything got messed up self . write ( \" \\x1b [2J\" ) @property def width ( self ) -> int : \"\"\"Gets the current width of the terminal.\"\"\" return self . size [ 0 ] @property def height ( self ) -> int : \"\"\"Gets the current height of the terminal.\"\"\" return self . size [ 1 ] @staticmethod def is_interactive () -> bool : \"\"\"Determines whether shell is interactive. A shell is interactive if it is run from `python3` or `python3 -i`. \"\"\" return hasattr ( sys , \"ps1\" ) @property def forced_colorsystem ( self ) -> ColorSystem | None : \"\"\"Forces a color system type on this terminal.\"\"\" return self . _forced_colorsystem @forced_colorsystem . setter def forced_colorsystem ( self , new : ColorSystem | None ) -> None : \"\"\"Sets a colorsystem, clears colorsystem cache.\"\"\" self . _forced_colorsystem = new @property def colorsystem ( self ) -> ColorSystem : \"\"\"Gets the current terminal's supported color system.\"\"\" if self . forced_colorsystem is not None : return self . forced_colorsystem if os . getenv ( \"NO_COLOR\" ) is not None : return ColorSystem . NO_COLOR term = os . getenv ( \"TERM\" , \"\" ) color_term = os . getenv ( \"COLORTERM\" , \"\" ) . strip () . lower () if color_term == \"\" : color_term = term . split ( \"xterm-\" )[ - 1 ] if color_term in [ \"24bit\" , \"truecolor\" ]: return ColorSystem . TRUE if color_term == \"256color\" : return ColorSystem . EIGHT_BIT return ColorSystem . STANDARD @contextmanager def record ( self ) -> Generator [ Recorder , None , None ]: \"\"\"Records the terminal's stream.\"\"\" if self . _recorder is not None : raise RuntimeError ( f \" { self !r} is already recording.\" ) try : self . _recorder = Recorder () yield self . _recorder finally : self . _recorder = None @contextmanager def no_record ( self ) -> Generator [ None , None , None ]: \"\"\"Pauses recording for the duration of the context.\"\"\" recorder = self . _recorder try : self . _recorder = None yield finally : self . _recorder = recorder @contextmanager def frame ( self ) -> Generator [ StringIO , None , None ]: \"\"\"Notifies the emulator of the inner content being a single frame. See https://gist.github.com/christianparpart/d8a62cc1ab659194337d73e399004036! \"\"\" buffer = StringIO () try : with self . no_record (): self . write ( \" \\x1b [?2026h\" ) yield buffer finally : self . write ( buffer . getvalue ()) with self . no_record (): self . write ( \" \\x1b [?2026l\" ) self . flush () @staticmethod def isatty () -> bool : \"\"\"Returns whether sys.stdin is a tty.\"\"\" return sys . stdin . isatty () def replay ( self , recorder : Recorder ) -> None : \"\"\"Replays a recording.\"\"\" last_time = 0.0 for data , delay in recorder . recording : if last_time > 0.0 : time . sleep ( delay - last_time ) self . write ( data , flush = True ) last_time = delay def subscribe ( self , event : int , callback : Callable [ ... , Any ]) -> None : \"\"\"Subcribes a callback to be called when event occurs. Args: event: The terminal event that calls callback. callback: The callable to be called. The signature of this callable is dependent on the event. See the documentation of the specific event for more information. \"\"\" if not event in self . _listeners : self . _listeners [ event ] = [] self . _listeners [ event ] . append ( callback ) def write ( self , data : str , pos : tuple [ int , int ] | None = None , flush : bool = False , slice_too_long : bool = True , ) -> None : \"\"\"Writes the given data to the terminal's stream. Args: data: The data to write. pos: Terminal-character space position to write the data to, (x, y). flush: If set, `flush` will be called on the stream after reading. slice_too_long: If set, lines that are outside of the terminal will be sliced to fit. Involves a sizable performance hit. \"\"\" def _slice ( line : str , maximum : int ) -> str : length = 0 sliced = \"\" for char in line : sliced += char if char == \" \\x1b \" : continue if ( length > maximum and real_length ( sliced ) > maximum and not has_open_sequence ( sliced ) ): break length += 1 return sliced if \" \\x1b [2J\" in data : self . clear_stream () if pos is not None : xpos , ypos = pos if slice_too_long : if not self . height + self . origin [ 1 ] + 1 > ypos >= 0 : return maximum = self . width - xpos + self . origin [ 0 ] if xpos < self . origin [ 0 ]: xpos = self . origin [ 0 ] sliced = _slice ( data , maximum ) if len ( data ) > maximum else data data = f \" \\x1b [ { ypos } ; { xpos } H { sliced } \\x1b [0m\" else : data = f \" \\x1b [ { ypos } ; { xpos } H { data } \" self . _stream . write ( data ) if self . _recorder is not None : self . _recorder . write ( data ) if flush : self . _stream . flush () def clear_stream ( self ) -> None : \"\"\"Clears (truncates) the terminal's stream.\"\"\" try : self . _stream . truncate ( 0 ) except OSError as error : if error . errno != errno . EINVAL and os . name != \"nt\" : raise self . _stream . write ( \" \\x1b [2J\" ) def print ( self , * items , pos : tuple [ int , int ] | None = None , sep : str = \" \" , end = \" \\n \" , flush : bool = True , ) -> None : \"\"\"Prints items to the stream. All arguments not mentioned here are analogous to `print`. Args: pos: Terminal-character space position to write the data to, (x, y). \"\"\" self . write ( sep . join ( map ( str , items )) + end , pos = pos , flush = flush ) def flush ( self ) -> None : \"\"\"Flushes self._stream.\"\"\" self . _stream . flush ()","title":"Terminal"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.RESIZE","text":"Event sent out when the terminal has been resized. Arguments passed: - New size: tuple[int, int]","title":"RESIZE"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.displayhook_installed","text":"This is set to True when pretty.install is called.","title":"displayhook_installed"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.margins","text":"Not quite sure what this does at the moment.","title":"margins"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.origin","text":"Origin of the internal coordinate system.","title":"origin"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.__fancy_repr__","text":"Returns a cool looking repr. Source code in pytermgui/term.py 292 293 294 295 296 297 def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Returns a cool looking repr.\"\"\" name = type ( self ) . __name__ yield f \"< { name } stream= { self . _stream } size= { self . size } >\"","title":"__fancy_repr__()"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.__init__","text":"Initialize Terminal class. Source code in pytermgui/term.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def __init__ ( self , stream : TextIO | None = None , * , size : tuple [ int , int ] | None = None , ) -> None : \"\"\"Initialize `Terminal` class.\"\"\" if stream is None : stream = sys . stdout self . _size = size self . _stream = stream or sys . stdout self . _recorder : Recorder | None = None self . size : tuple [ int , int ] = self . _get_size () self . forced_colorsystem : ColorSystem | None = _get_env_colorsys () self . _listeners : dict [ int , list [ Callable [ ... , Any ]]] = {} if hasattr ( signal , \"SIGWINCH\" ): signal . signal ( signal . SIGWINCH , self . _update_size ) else : from threading import Thread # pylint: disable=import-outside-toplevel Thread ( name = \"windows_terminal_resize\" , target = self . _window_terminal_resize , daemon = True , ) . start () self . _diff_buffer = [ [ \"\" for _ in range ( self . width )] for y in range ( self . height ) ]","title":"__init__()"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.clear_stream","text":"Clears (truncates) the terminal's stream. Source code in pytermgui/term.py 565 566 567 568 569 570 571 572 573 574 575 def clear_stream ( self ) -> None : \"\"\"Clears (truncates) the terminal's stream.\"\"\" try : self . _stream . truncate ( 0 ) except OSError as error : if error . errno != errno . EINVAL and os . name != \"nt\" : raise self . _stream . write ( \" \\x1b [2J\" )","title":"clear_stream()"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.colorsystem","text":"Gets the current terminal's supported color system. Source code in pytermgui/term.py 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 @property def colorsystem ( self ) -> ColorSystem : \"\"\"Gets the current terminal's supported color system.\"\"\" if self . forced_colorsystem is not None : return self . forced_colorsystem if os . getenv ( \"NO_COLOR\" ) is not None : return ColorSystem . NO_COLOR term = os . getenv ( \"TERM\" , \"\" ) color_term = os . getenv ( \"COLORTERM\" , \"\" ) . strip () . lower () if color_term == \"\" : color_term = term . split ( \"xterm-\" )[ - 1 ] if color_term in [ \"24bit\" , \"truecolor\" ]: return ColorSystem . TRUE if color_term == \"256color\" : return ColorSystem . EIGHT_BIT return ColorSystem . STANDARD","title":"colorsystem()"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.flush","text":"Flushes self._stream. Source code in pytermgui/term.py 596 597 598 599 def flush ( self ) -> None : \"\"\"Flushes self._stream.\"\"\" self . _stream . flush ()","title":"flush()"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.forced_colorsystem","text":"Forces a color system type on this terminal. Source code in pytermgui/term.py 384 385 386 387 388 @property def forced_colorsystem ( self ) -> ColorSystem | None : \"\"\"Forces a color system type on this terminal.\"\"\" return self . _forced_colorsystem","title":"forced_colorsystem()"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.frame","text":"Notifies the emulator of the inner content being a single frame. See https://gist.github.com/christianparpart/d8a62cc1ab659194337d73e399004036! Source code in pytermgui/term.py 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 @contextmanager def frame ( self ) -> Generator [ StringIO , None , None ]: \"\"\"Notifies the emulator of the inner content being a single frame. See https://gist.github.com/christianparpart/d8a62cc1ab659194337d73e399004036! \"\"\" buffer = StringIO () try : with self . no_record (): self . write ( \" \\x1b [?2026h\" ) yield buffer finally : self . write ( buffer . getvalue ()) with self . no_record (): self . write ( \" \\x1b [?2026l\" ) self . flush ()","title":"frame()"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.height","text":"Gets the current height of the terminal. Source code in pytermgui/term.py 369 370 371 372 373 @property def height ( self ) -> int : \"\"\"Gets the current height of the terminal.\"\"\" return self . size [ 1 ]","title":"height()"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.is_interactive","text":"Determines whether shell is interactive. A shell is interactive if it is run from python3 or python3 -i . Source code in pytermgui/term.py 375 376 377 378 379 380 381 382 @staticmethod def is_interactive () -> bool : \"\"\"Determines whether shell is interactive. A shell is interactive if it is run from `python3` or `python3 -i`. \"\"\" return hasattr ( sys , \"ps1\" )","title":"is_interactive()"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.isatty","text":"Returns whether sys.stdin is a tty. Source code in pytermgui/term.py 467 468 469 470 471 @staticmethod def isatty () -> bool : \"\"\"Returns whether sys.stdin is a tty.\"\"\" return sys . stdin . isatty ()","title":"isatty()"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.no_record","text":"Pauses recording for the duration of the context. Source code in pytermgui/term.py 434 435 436 437 438 439 440 441 442 443 444 445 @contextmanager def no_record ( self ) -> Generator [ None , None , None ]: \"\"\"Pauses recording for the duration of the context.\"\"\" recorder = self . _recorder try : self . _recorder = None yield finally : self . _recorder = recorder","title":"no_record()"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.pixel_size","text":"DEPRECATED: Returns the terminal's pixel resolution. Prefer terminal.resolution. Source code in pytermgui/term.py 320 321 322 323 324 325 326 327 @property def pixel_size ( self ) -> tuple [ int , int ]: \"\"\"DEPRECATED: Returns the terminal's pixel resolution. Prefer terminal.resolution. \"\"\" return self . resolution","title":"pixel_size()"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.print","text":"Prints items to the stream. All arguments not mentioned here are analogous to print . Parameters: Name Type Description Default pos tuple [ int , int ] | None Terminal-character space position to write the data to, (x, y). None Source code in pytermgui/term.py 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 def print ( self , * items , pos : tuple [ int , int ] | None = None , sep : str = \" \" , end = \" \\n \" , flush : bool = True , ) -> None : \"\"\"Prints items to the stream. All arguments not mentioned here are analogous to `print`. Args: pos: Terminal-character space position to write the data to, (x, y). \"\"\" self . write ( sep . join ( map ( str , items )) + end , pos = pos , flush = flush )","title":"print()"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.record","text":"Records the terminal's stream. Source code in pytermgui/term.py 420 421 422 423 424 425 426 427 428 429 430 431 432 @contextmanager def record ( self ) -> Generator [ Recorder , None , None ]: \"\"\"Records the terminal's stream.\"\"\" if self . _recorder is not None : raise RuntimeError ( f \" { self !r} is already recording.\" ) try : self . _recorder = Recorder () yield self . _recorder finally : self . _recorder = None","title":"record()"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.replay","text":"Replays a recording. Source code in pytermgui/term.py 473 474 475 476 477 478 479 480 481 482 def replay ( self , recorder : Recorder ) -> None : \"\"\"Replays a recording.\"\"\" last_time = 0.0 for data , delay in recorder . recording : if last_time > 0.0 : time . sleep ( delay - last_time ) self . write ( data , flush = True ) last_time = delay","title":"replay()"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.resolution","text":"Returns the terminal's pixel based resolution. Only evaluated on demand. Source code in pytermgui/term.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 @cached_property def resolution ( self ) -> tuple [ int , int ]: \"\"\"Returns the terminal's pixel based resolution. Only evaluated on demand. \"\"\" if self . isatty (): sys . stdout . write ( \" \\x1b [14t\" ) sys . stdout . flush () # Some terminals may not respond to a pixel size query, so we send # a timed-out getch call with a default response of 1280x720. output = getch_timeout ( 0.1 , default = \" \\x1b [4;720;1280t\" ) match = RE_PIXEL_SIZE . match ( output ) if match is not None : return ( int ( match [ 2 ]), int ( match [ 1 ])) return ( 0 , 0 )","title":"resolution()"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.subscribe","text":"Subcribes a callback to be called when event occurs. Parameters: Name Type Description Default event int The terminal event that calls callback. required callback Callable [..., Any ] The callable to be called. The signature of this callable is dependent on the event. See the documentation of the specific event for more information. required Source code in pytermgui/term.py 484 485 486 487 488 489 490 491 492 493 494 495 496 497 def subscribe ( self , event : int , callback : Callable [ ... , Any ]) -> None : \"\"\"Subcribes a callback to be called when event occurs. Args: event: The terminal event that calls callback. callback: The callable to be called. The signature of this callable is dependent on the event. See the documentation of the specific event for more information. \"\"\" if not event in self . _listeners : self . _listeners [ event ] = [] self . _listeners [ event ] . append ( callback )","title":"subscribe()"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.width","text":"Gets the current width of the terminal. Source code in pytermgui/term.py 363 364 365 366 367 @property def width ( self ) -> int : \"\"\"Gets the current width of the terminal.\"\"\" return self . size [ 0 ]","title":"width()"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.write","text":"Writes the given data to the terminal's stream. Parameters: Name Type Description Default data str The data to write. required pos tuple [ int , int ] | None Terminal-character space position to write the data to, (x, y). None flush bool If set, flush will be called on the stream after reading. False slice_too_long bool If set, lines that are outside of the terminal will be sliced to fit. Involves a sizable performance hit. True Source code in pytermgui/term.py 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 def write ( self , data : str , pos : tuple [ int , int ] | None = None , flush : bool = False , slice_too_long : bool = True , ) -> None : \"\"\"Writes the given data to the terminal's stream. Args: data: The data to write. pos: Terminal-character space position to write the data to, (x, y). flush: If set, `flush` will be called on the stream after reading. slice_too_long: If set, lines that are outside of the terminal will be sliced to fit. Involves a sizable performance hit. \"\"\" def _slice ( line : str , maximum : int ) -> str : length = 0 sliced = \"\" for char in line : sliced += char if char == \" \\x1b \" : continue if ( length > maximum and real_length ( sliced ) > maximum and not has_open_sequence ( sliced ) ): break length += 1 return sliced if \" \\x1b [2J\" in data : self . clear_stream () if pos is not None : xpos , ypos = pos if slice_too_long : if not self . height + self . origin [ 1 ] + 1 > ypos >= 0 : return maximum = self . width - xpos + self . origin [ 0 ] if xpos < self . origin [ 0 ]: xpos = self . origin [ 0 ] sliced = _slice ( data , maximum ) if len ( data ) > maximum else data data = f \" \\x1b [ { ypos } ; { xpos } H { sliced } \\x1b [0m\" else : data = f \" \\x1b [ { ypos } ; { xpos } H { data } \" self . _stream . write ( data ) if self . _recorder is not None : self . _recorder . write ( data ) if flush : self . _stream . flush ()","title":"write()"},{"location":"reference/pytermgui/term/#pytermgui.term.get_terminal","text":"Gets the default terminal instance used by the module. Source code in pytermgui/term.py 612 613 614 615 def get_terminal () -> Terminal : \"\"\"Gets the default terminal instance used by the module.\"\"\" return terminal","title":"get_terminal()"},{"location":"reference/pytermgui/term/#pytermgui.term.set_global_terminal","text":"Sets the terminal instance to be used by the module. Source code in pytermgui/term.py 606 607 608 609 def set_global_terminal ( new : Terminal ) -> None : \"\"\"Sets the terminal instance to be used by the module.\"\"\" globals ()[ \"terminal\" ] = new","title":"set_global_terminal()"},{"location":"reference/pytermgui/markup/","text":"Everything related to the TIM language.","title":"Index"},{"location":"reference/pytermgui/markup/aliases/","text":"All PTG-builtin TIM aliases. apply_default_aliases ( lang ) Applies all aliases within DEFAULT_ALIASES . Parameters: Name Type Description Default lang MarkupLanguage The MarkupLanguage instance all aliases will be applied to. required Source code in pytermgui/markup/aliases.py 26 27 28 29 30 31 32 33 34 def apply_default_aliases ( lang : MarkupLanguage ) -> None : \"\"\"Applies all aliases within `DEFAULT_ALIASES`. Args: lang: The `MarkupLanguage` instance all aliases will be applied to. \"\"\" lang . alias_multiple ( ** DEFAULT_ALIASES )","title":"aliases"},{"location":"reference/pytermgui/markup/aliases/#pytermgui.markup.aliases.apply_default_aliases","text":"Applies all aliases within DEFAULT_ALIASES . Parameters: Name Type Description Default lang MarkupLanguage The MarkupLanguage instance all aliases will be applied to. required Source code in pytermgui/markup/aliases.py 26 27 28 29 30 31 32 33 34 def apply_default_aliases ( lang : MarkupLanguage ) -> None : \"\"\"Applies all aliases within `DEFAULT_ALIASES`. Args: lang: The `MarkupLanguage` instance all aliases will be applied to. \"\"\" lang . alias_multiple ( ** DEFAULT_ALIASES )","title":"apply_default_aliases()"},{"location":"reference/pytermgui/markup/language/","text":"Wrappers around the TIM parsing engine, implementing caching and context management. MarkupLanguage A relatively simple object that binds context to TIM parsing functions. Most of the job this class has is to pass along a ContextDict to various \"lower level\" functions, in order to maintain a sort of state. It also exposes ways to modify this state, namely the alias and define methods. Source code in pytermgui/markup/language.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 class MarkupLanguage : \"\"\"A relatively simple object that binds context to TIM parsing functions. Most of the job this class has is to pass along a `ContextDict` to various \"lower level\" functions, in order to maintain a sort of state. It also exposes ways to modify this state, namely the `alias` and `define` methods. \"\"\" def __init__ ( self , * , strict : bool = False , default_aliases : bool = True , default_macros : bool = True , ) -> None : self . _cache : dict [ tuple [ str , bool , bool ], tuple [ list [ Token ], str , bool ]] = {} self . context = create_context_dict () self . _aliases = self . context [ \"aliases\" ] self . _macros = self . context [ \"macros\" ] if default_aliases : apply_default_aliases ( self ) if default_macros : apply_default_macros ( self ) self . strict = strict or STRICT_MARKUP @property def aliases ( self ) -> dict [ str , str ]: \"\"\"Returns a copy of the aliases defined in context.\"\"\" return self . _aliases . copy () @property def macros ( self ) -> dict [ str , MacroType ]: \"\"\"Returns a copy of the macros defined in context.\"\"\" return self . _macros . copy () def clear_cache ( self ) -> None : \"\"\"Clears the internal cache. Use this after re-defining aliases. \"\"\" self . _cache . clear () def define ( self , name : str , method : MacroType ) -> None : \"\"\"Defines a markup macro. Macros are essentially function bindings callable within markup. They can be very useful to represent changing data and simplify TIM code. Args: name: The name that will be used within TIM to call the macro. Must start with a bang (`!`). method: The function bound to the name given above. This function will take any number of strings as arguments, and return a terminal-ready (i.e. parsed) string. \"\"\" if not name . startswith ( \"!\" ): raise ValueError ( \"TIM macro names must be prefixed by `!`.\" ) self . _macros [ name ] = method def alias ( self , name : str , value : str , * , generate_unsetter : bool = True ) -> None : \"\"\"Creates an alias from one custom name to a set of styles. These can be used to store and reference a set of tags using only one name. Aliases may reference other aliases, but only do this consciously, as it can become a hard to follow trail of sorrow very quickly! Args: name: The name this alias will be referenced by. value: The markup value that the alias will represent. generate_unsetter: Disable generating clearer aliases. For example: ``` my-tag = 141 bold italic ``` will generate: ``` /my-tag = /fg /bold /italic ``` \"\"\" def _generate_unsetter () -> str : unsetter = \"\" no_alias = eval_alias ( value , self . context ) for tag in no_alias . split (): if \"(\" in tag and \")\" in tag : tag = tag [: tag . find ( \"(\" )] if tag in self . _aliases or tag in self . _macros : unsetter += f \" / { tag } \" continue try : color = str_to_color ( tag ) unsetter += f \" / { 'bg' if color . background else 'fg' } \" except ColorSyntaxError : unsetter += f \" / { tag } \" return unsetter . lstrip ( \" \" ) self . _aliases [ name ] = value if generate_unsetter : self . _aliases [ f \"/ { name } \" ] = _generate_unsetter () def alias_multiple ( self , * , generate_unsetter : bool = True , ** items : str ) -> None : \"\"\"Runs `MarkupLanguage.alias` repeatedly for all arguments. The same `generate_unsetter` value will be used for all calls. You can use this in two forms: - Traditional keyword arguments: ```python lang.alias_multiple(my-tag1=\"bold\", my-tag2=\"italic\") ``` - Keyword argument unpacking: ```python my_aliases = {\"my-tag1\": \"bold\", \"my-tag2\": \"italic\"} lang.alias_multiple(**my_aliases) ``` \"\"\" for name , value in items . items (): self . alias ( name , value , generate_unsetter = generate_unsetter ) def parse ( self , text : str , optimize : bool = False , append_reset : bool = True , ) -> str : \"\"\"Parses some markup text. This is a thin wrapper around [markup.parsing.parse](/reference/ pytermgui/markup/parsing#pytermgui.markup.parsing.parse). The main additions of this wrapper are a caching system, as well as state management. Ignoring caching, all calls to this function would be equivalent to: ```python3 def parse(self, *args, **kwargs) -> str: kwargs[\"context\"] = self.context return parse(*args, **kwargs) ``` \"\"\" key = ( text , optimize , append_reset ) cache_hit = self . _cache . get ( key ) if cache_hit is not None : cached , tokens , has_macro = cache_hit # Re-parse using known tokens when macro is present # # This saves a tiny fraction of time (around 0.2ms) when parsing # macros, for a loss of an even smaller time for the general, # non-macro usecase. if has_macro : output = parse_tokens ( tokens , optimize = optimize , append_reset = append_reset , context = self . context , ignore_unknown_tags = not self . strict , ) return output return cached tokens = list ( tokenize_markup ( text )) output = parse_tokens ( tokens , optimize = optimize , append_reset = append_reset , context = self . context , ignore_unknown_tags = not self . strict , ) has_macro = any ( token . is_macro () for token in tokens ) self . _cache [ key ] = ( output , tokens , has_macro ) return output # TODO: This should be deprecated. @staticmethod def get_markup ( text : str ) -> str : \"\"\"DEPRECATED: Convert ANSI text into markup. This function does not use context, and thus is out of place here. \"\"\" return tokens_to_markup ( list ( tokenize_ansi ( text ))) def group_styles ( self , text : str , tokenizer : Tokenizer = tokenize_ansi ) -> Generator [ StyledText , None , None ]: \"\"\"Generate StyledText-s from some text, using our context. See `StyledText.group_styles` for arguments. \"\"\" yield from StyledText . group_styles ( text , tokenizer = tokenizer , context = self . context ) def print ( self , * args , ** kwargs ) -> None : \"\"\"Parse all arguments and pass them through to print, along with kwargs.\"\"\" parsed = [] for arg in args : parsed . append ( self . parse ( str ( arg ))) get_terminal () . print ( * parsed , ** kwargs ) alias ( name , value , * , generate_unsetter = True ) Creates an alias from one custom name to a set of styles. These can be used to store and reference a set of tags using only one name. Aliases may reference other aliases, but only do this consciously, as it can become a hard to follow trail of sorrow very quickly! Parameters: Name Type Description Default name str The name this alias will be referenced by. required value str The markup value that the alias will represent. required generate_unsetter bool Disable generating clearer aliases. For example: my-tag = 141 bold italic will generate: /my-tag = /fg /bold /italic True Source code in pytermgui/markup/language.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def alias ( self , name : str , value : str , * , generate_unsetter : bool = True ) -> None : \"\"\"Creates an alias from one custom name to a set of styles. These can be used to store and reference a set of tags using only one name. Aliases may reference other aliases, but only do this consciously, as it can become a hard to follow trail of sorrow very quickly! Args: name: The name this alias will be referenced by. value: The markup value that the alias will represent. generate_unsetter: Disable generating clearer aliases. For example: ``` my-tag = 141 bold italic ``` will generate: ``` /my-tag = /fg /bold /italic ``` \"\"\" def _generate_unsetter () -> str : unsetter = \"\" no_alias = eval_alias ( value , self . context ) for tag in no_alias . split (): if \"(\" in tag and \")\" in tag : tag = tag [: tag . find ( \"(\" )] if tag in self . _aliases or tag in self . _macros : unsetter += f \" / { tag } \" continue try : color = str_to_color ( tag ) unsetter += f \" / { 'bg' if color . background else 'fg' } \" except ColorSyntaxError : unsetter += f \" / { tag } \" return unsetter . lstrip ( \" \" ) self . _aliases [ name ] = value if generate_unsetter : self . _aliases [ f \"/ { name } \" ] = _generate_unsetter () alias_multiple ( * , generate_unsetter = True , items ) Runs MarkupLanguage.alias repeatedly for all arguments. The same generate_unsetter value will be used for all calls. You can use this in two forms: Traditional keyword arguments: lang . alias_multiple ( my - tag1 = \"bold\" , my - tag2 = \"italic\" ) Keyword argument unpacking: my_aliases = { \"my-tag1\" : \"bold\" , \"my-tag2\" : \"italic\" } lang . alias_multiple ( ** my_aliases ) Source code in pytermgui/markup/language.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def alias_multiple ( self , * , generate_unsetter : bool = True , ** items : str ) -> None : \"\"\"Runs `MarkupLanguage.alias` repeatedly for all arguments. The same `generate_unsetter` value will be used for all calls. You can use this in two forms: - Traditional keyword arguments: ```python lang.alias_multiple(my-tag1=\"bold\", my-tag2=\"italic\") ``` - Keyword argument unpacking: ```python my_aliases = {\"my-tag1\": \"bold\", \"my-tag2\": \"italic\"} lang.alias_multiple(**my_aliases) ``` \"\"\" for name , value in items . items (): self . alias ( name , value , generate_unsetter = generate_unsetter ) aliases () property Returns a copy of the aliases defined in context. Source code in pytermgui/markup/language.py 81 82 83 84 85 @property def aliases ( self ) -> dict [ str , str ]: \"\"\"Returns a copy of the aliases defined in context.\"\"\" return self . _aliases . copy () clear_cache () Clears the internal cache. Use this after re-defining aliases. Source code in pytermgui/markup/language.py 93 94 95 96 97 98 99 def clear_cache ( self ) -> None : \"\"\"Clears the internal cache. Use this after re-defining aliases. \"\"\" self . _cache . clear () define ( name , method ) Defines a markup macro. Macros are essentially function bindings callable within markup. They can be very useful to represent changing data and simplify TIM code. Parameters: Name Type Description Default name str The name that will be used within TIM to call the macro. Must start with a bang ( ! ). required method MacroType The function bound to the name given above. This function will take any number of strings as arguments, and return a terminal-ready (i.e. parsed) string. required Source code in pytermgui/markup/language.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def define ( self , name : str , method : MacroType ) -> None : \"\"\"Defines a markup macro. Macros are essentially function bindings callable within markup. They can be very useful to represent changing data and simplify TIM code. Args: name: The name that will be used within TIM to call the macro. Must start with a bang (`!`). method: The function bound to the name given above. This function will take any number of strings as arguments, and return a terminal-ready (i.e. parsed) string. \"\"\" if not name . startswith ( \"!\" ): raise ValueError ( \"TIM macro names must be prefixed by `!`.\" ) self . _macros [ name ] = method get_markup ( text ) staticmethod DEPRECATED: Convert ANSI text into markup. This function does not use context, and thus is out of place here. Source code in pytermgui/markup/language.py 257 258 259 260 261 262 263 264 @staticmethod def get_markup ( text : str ) -> str : \"\"\"DEPRECATED: Convert ANSI text into markup. This function does not use context, and thus is out of place here. \"\"\" return tokens_to_markup ( list ( tokenize_ansi ( text ))) group_styles ( text , tokenizer = tokenize_ansi ) Generate StyledText-s from some text, using our context. See StyledText.group_styles for arguments. Source code in pytermgui/markup/language.py 266 267 268 269 270 271 272 273 274 275 276 def group_styles ( self , text : str , tokenizer : Tokenizer = tokenize_ansi ) -> Generator [ StyledText , None , None ]: \"\"\"Generate StyledText-s from some text, using our context. See `StyledText.group_styles` for arguments. \"\"\" yield from StyledText . group_styles ( text , tokenizer = tokenizer , context = self . context ) macros () property Returns a copy of the macros defined in context. Source code in pytermgui/markup/language.py 87 88 89 90 91 @property def macros ( self ) -> dict [ str , MacroType ]: \"\"\"Returns a copy of the macros defined in context.\"\"\" return self . _macros . copy () parse ( text , optimize = False , append_reset = True ) Parses some markup text. This is a thin wrapper around markup.parsing.parse . The main additions of this wrapper are a caching system, as well as state management. Ignoring caching, all calls to this function would be equivalent to: def parse ( self , * args , ** kwargs ) -> str : kwargs [ \"context\" ] = self . context return parse ( * args , ** kwargs ) Source code in pytermgui/markup/language.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def parse ( self , text : str , optimize : bool = False , append_reset : bool = True , ) -> str : \"\"\"Parses some markup text. This is a thin wrapper around [markup.parsing.parse](/reference/ pytermgui/markup/parsing#pytermgui.markup.parsing.parse). The main additions of this wrapper are a caching system, as well as state management. Ignoring caching, all calls to this function would be equivalent to: ```python3 def parse(self, *args, **kwargs) -> str: kwargs[\"context\"] = self.context return parse(*args, **kwargs) ``` \"\"\" key = ( text , optimize , append_reset ) cache_hit = self . _cache . get ( key ) if cache_hit is not None : cached , tokens , has_macro = cache_hit # Re-parse using known tokens when macro is present # # This saves a tiny fraction of time (around 0.2ms) when parsing # macros, for a loss of an even smaller time for the general, # non-macro usecase. if has_macro : output = parse_tokens ( tokens , optimize = optimize , append_reset = append_reset , context = self . context , ignore_unknown_tags = not self . strict , ) return output return cached tokens = list ( tokenize_markup ( text )) output = parse_tokens ( tokens , optimize = optimize , append_reset = append_reset , context = self . context , ignore_unknown_tags = not self . strict , ) has_macro = any ( token . is_macro () for token in tokens ) self . _cache [ key ] = ( output , tokens , has_macro ) return output print ( args , kwargs ) Parse all arguments and pass them through to print, along with kwargs. Source code in pytermgui/markup/language.py 278 279 280 281 282 283 284 285 def print ( self , * args , ** kwargs ) -> None : \"\"\"Parse all arguments and pass them through to print, along with kwargs.\"\"\" parsed = [] for arg in args : parsed . append ( self . parse ( str ( arg ))) get_terminal () . print ( * parsed , ** kwargs ) StyledText dataclass An ANSI style-infused string. This is a sort of helper to handle ANSI texts in a more semantic manner. It keeps track of a sequence and a plain part. Calling len() will return the length of the printable, non-ANSI part, and indexing will return the characters at the given slice, but also include the sequences that are applied to them. To generate StyledText-s, it is recommended to use the StyledText.group_styles classmethod. Source code in pytermgui/markup/language.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 @dataclass ( frozen = True ) class StyledText : \"\"\"An ANSI style-infused string. This is a sort of helper to handle ANSI texts in a more semantic manner. It keeps track of a sequence and a plain part. Calling `len()` will return the length of the printable, non-ANSI part, and indexing will return the characters at the given slice, but also include the sequences that are applied to them. To generate StyledText-s, it is recommended to use the `StyledText.group_styles` classmethod. \"\"\" __slots__ = ( \"plain\" , \"sequences\" , \"tokens\" , \"link\" , \"__dict__\" ) sequences : str plain : str tokens : list [ Token ] link : str | None @cached_property def foreground ( self ) -> Color | None : \"\"\"Returns the foreground color of this object.\"\"\" colors = [ tkn for tkn in self . tokens if Token . is_color ( tkn ) and not tkn . color . background ] if len ( colors ) == 0 : return None return colors [ - 1 ] . color @cached_property def background ( self ) -> Color | None : \"\"\"Returns the background color of this object.\"\"\" colors = [ tkn for tkn in self . tokens if Token . is_color ( tkn ) and tkn . color . background ] if len ( colors ) == 0 : return None return colors [ - 1 ] . color @cached_property def bold ( self ) -> bool : \"\"\"Returns this text is bold.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"bold\" for tkn in self . tokens ) @cached_property def dim ( self ) -> bool : \"\"\"Returns this text is dimmed.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"dim\" for tkn in self . tokens ) @cached_property def italic ( self ) -> bool : \"\"\"Returns this text is italicized.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"italic\" for tkn in self . tokens ) @cached_property def underline ( self ) -> bool : \"\"\"Returns this text is underlined.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"underline\" for tkn in self . tokens ) @cached_property def blink ( self ) -> bool : \"\"\"Returns this text is blinking.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"blink\" for tkn in self . tokens ) @cached_property def blink2 ( self ) -> bool : \"\"\"Returns this text is alternate-blinking.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"blink2\" for tkn in self . tokens ) @cached_property def strikethrough ( self ) -> bool : \"\"\"Returns this text is striked out.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"strikethrough\" for tkn in self . tokens ) @cached_property def inverse ( self ) -> bool : \"\"\"Returns this text has its colors inversed.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"inverse\" for tkn in self . tokens ) @cached_property def overline ( self ) -> bool : \"\"\"Returns this text is overlined.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"overline\" for tkn in self . tokens ) @staticmethod def group_styles ( text : str , tokenizer : Tokenizer = tokenize_ansi , context : ContextDict | None = None , ) -> Generator [ StyledText , None , None ]: \"\"\"Yields StyledTexts from an ANSI coded string. A new StyledText will be created each time a non-plain token follows a plain token, thus all texts will represent a single (ANSI)PLAIN group of characters. \"\"\" context = context if context is not None else create_context_dict () parsers = PARSERS link = None def _parse ( token : Token ) -> str : nonlocal link if token . is_macro (): return token . markup if token . is_hyperlink (): link = token return \"\" if link is not None and Token . is_clear ( token ) and token . targets ( link ): link = None if token . is_clear () and token . value not in CLEARERS : return token . markup # The full text (last arg) is not relevant here, as ANSI parsing doesn't # use any context-defined tags, so no errors will occur. return parsers [ type ( token )]( token , context , lambda : \"\" ) # type: ignore tokens : list [ Token ] = [] token : Token for token in tokenizer ( text ): if token . is_plain (): yield StyledText ( \"\" . join ( _parse ( tkn ) for tkn in tokens ), token . value , tokens + [ token ], link . value if link is not None else None , ) tokens = [ tkn for tkn in tokens if not tkn . is_cursor ()] continue if Token . is_clear ( token ): tokens = [ tkn for tkn in tokens if not token . targets ( tkn )] if len ( tokens ) > 0 and tokens [ - 1 ] == token : continue if len ( tokens ) > 0 and all ( tkn . is_clear () for tkn in tokens ): tokens = [] tokens . append ( token ) # if len(tokens) > 0: # token = PlainToken(\"\") # yield StyledText( # \"\".join(_parse(tkn) for tkn in tokens), # token.value, # tokens + [token], # link.value if link is not None else None, # ) @classmethod def first_of ( cls , text : str ) -> StyledText | None : \"\"\"Returns the first element of cls.group_styles(text).\"\"\" for item in cls . group_styles ( text ): return item return None def __len__ ( self ) -> int : return len ( self . plain ) def __str__ ( self ) -> str : return self . sequences + self . plain def __getitem__ ( self , sli : int | slice ) -> str : return self . sequences + self . plain [ sli ] background () property cached Returns the background color of this object. Source code in pytermgui/markup/language.py 328 329 330 331 332 333 334 335 336 337 338 339 @cached_property def background ( self ) -> Color | None : \"\"\"Returns the background color of this object.\"\"\" colors = [ tkn for tkn in self . tokens if Token . is_color ( tkn ) and tkn . color . background ] if len ( colors ) == 0 : return None return colors [ - 1 ] . color blink () property cached Returns this text is blinking. Source code in pytermgui/markup/language.py 369 370 371 372 373 @cached_property def blink ( self ) -> bool : \"\"\"Returns this text is blinking.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"blink\" for tkn in self . tokens ) blink2 () property cached Returns this text is alternate-blinking. Source code in pytermgui/markup/language.py 375 376 377 378 379 380 381 @cached_property def blink2 ( self ) -> bool : \"\"\"Returns this text is alternate-blinking.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"blink2\" for tkn in self . tokens ) bold () property cached Returns this text is bold. Source code in pytermgui/markup/language.py 341 342 343 344 345 @cached_property def bold ( self ) -> bool : \"\"\"Returns this text is bold.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"bold\" for tkn in self . tokens ) dim () property cached Returns this text is dimmed. Source code in pytermgui/markup/language.py 347 348 349 350 351 @cached_property def dim ( self ) -> bool : \"\"\"Returns this text is dimmed.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"dim\" for tkn in self . tokens ) first_of ( text ) classmethod Returns the first element of cls.group_styles(text). Source code in pytermgui/markup/language.py 481 482 483 484 485 486 487 488 @classmethod def first_of ( cls , text : str ) -> StyledText | None : \"\"\"Returns the first element of cls.group_styles(text).\"\"\" for item in cls . group_styles ( text ): return item return None foreground () property cached Returns the foreground color of this object. Source code in pytermgui/markup/language.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 @cached_property def foreground ( self ) -> Color | None : \"\"\"Returns the foreground color of this object.\"\"\" colors = [ tkn for tkn in self . tokens if Token . is_color ( tkn ) and not tkn . color . background ] if len ( colors ) == 0 : return None return colors [ - 1 ] . color group_styles ( text , tokenizer = tokenize_ansi , context = None ) staticmethod Yields StyledTexts from an ANSI coded string. A new StyledText will be created each time a non-plain token follows a plain token, thus all texts will represent a single (ANSI)PLAIN group of characters. Source code in pytermgui/markup/language.py 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 @staticmethod def group_styles ( text : str , tokenizer : Tokenizer = tokenize_ansi , context : ContextDict | None = None , ) -> Generator [ StyledText , None , None ]: \"\"\"Yields StyledTexts from an ANSI coded string. A new StyledText will be created each time a non-plain token follows a plain token, thus all texts will represent a single (ANSI)PLAIN group of characters. \"\"\" context = context if context is not None else create_context_dict () parsers = PARSERS link = None def _parse ( token : Token ) -> str : nonlocal link if token . is_macro (): return token . markup if token . is_hyperlink (): link = token return \"\" if link is not None and Token . is_clear ( token ) and token . targets ( link ): link = None if token . is_clear () and token . value not in CLEARERS : return token . markup # The full text (last arg) is not relevant here, as ANSI parsing doesn't # use any context-defined tags, so no errors will occur. return parsers [ type ( token )]( token , context , lambda : \"\" ) # type: ignore tokens : list [ Token ] = [] token : Token for token in tokenizer ( text ): if token . is_plain (): yield StyledText ( \"\" . join ( _parse ( tkn ) for tkn in tokens ), token . value , tokens + [ token ], link . value if link is not None else None , ) tokens = [ tkn for tkn in tokens if not tkn . is_cursor ()] continue if Token . is_clear ( token ): tokens = [ tkn for tkn in tokens if not token . targets ( tkn )] if len ( tokens ) > 0 and tokens [ - 1 ] == token : continue if len ( tokens ) > 0 and all ( tkn . is_clear () for tkn in tokens ): tokens = [] tokens . append ( token ) inverse () property cached Returns this text has its colors inversed. Source code in pytermgui/markup/language.py 391 392 393 394 395 396 397 @cached_property def inverse ( self ) -> bool : \"\"\"Returns this text has its colors inversed.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"inverse\" for tkn in self . tokens ) italic () property cached Returns this text is italicized. Source code in pytermgui/markup/language.py 353 354 355 356 357 358 359 @cached_property def italic ( self ) -> bool : \"\"\"Returns this text is italicized.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"italic\" for tkn in self . tokens ) overline () property cached Returns this text is overlined. Source code in pytermgui/markup/language.py 399 400 401 402 403 404 405 @cached_property def overline ( self ) -> bool : \"\"\"Returns this text is overlined.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"overline\" for tkn in self . tokens ) strikethrough () property cached Returns this text is striked out. Source code in pytermgui/markup/language.py 383 384 385 386 387 388 389 @cached_property def strikethrough ( self ) -> bool : \"\"\"Returns this text is striked out.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"strikethrough\" for tkn in self . tokens ) underline () property cached Returns this text is underlined. Source code in pytermgui/markup/language.py 361 362 363 364 365 366 367 @cached_property def underline ( self ) -> bool : \"\"\"Returns this text is underlined.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"underline\" for tkn in self . tokens ) escape ( text ) Escapes any markup found within the given text. Source code in pytermgui/markup/language.py 41 42 43 44 45 46 47 48 49 def escape ( text : str ) -> str : \"\"\"Escapes any markup found within the given text.\"\"\" def _repl ( matchobj : Match ) -> str : full , * _ = matchobj . groups () return f \" \\\\ { full } \" return RE_MARKUP . sub ( _repl , text )","title":"language"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.MarkupLanguage","text":"A relatively simple object that binds context to TIM parsing functions. Most of the job this class has is to pass along a ContextDict to various \"lower level\" functions, in order to maintain a sort of state. It also exposes ways to modify this state, namely the alias and define methods. Source code in pytermgui/markup/language.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 class MarkupLanguage : \"\"\"A relatively simple object that binds context to TIM parsing functions. Most of the job this class has is to pass along a `ContextDict` to various \"lower level\" functions, in order to maintain a sort of state. It also exposes ways to modify this state, namely the `alias` and `define` methods. \"\"\" def __init__ ( self , * , strict : bool = False , default_aliases : bool = True , default_macros : bool = True , ) -> None : self . _cache : dict [ tuple [ str , bool , bool ], tuple [ list [ Token ], str , bool ]] = {} self . context = create_context_dict () self . _aliases = self . context [ \"aliases\" ] self . _macros = self . context [ \"macros\" ] if default_aliases : apply_default_aliases ( self ) if default_macros : apply_default_macros ( self ) self . strict = strict or STRICT_MARKUP @property def aliases ( self ) -> dict [ str , str ]: \"\"\"Returns a copy of the aliases defined in context.\"\"\" return self . _aliases . copy () @property def macros ( self ) -> dict [ str , MacroType ]: \"\"\"Returns a copy of the macros defined in context.\"\"\" return self . _macros . copy () def clear_cache ( self ) -> None : \"\"\"Clears the internal cache. Use this after re-defining aliases. \"\"\" self . _cache . clear () def define ( self , name : str , method : MacroType ) -> None : \"\"\"Defines a markup macro. Macros are essentially function bindings callable within markup. They can be very useful to represent changing data and simplify TIM code. Args: name: The name that will be used within TIM to call the macro. Must start with a bang (`!`). method: The function bound to the name given above. This function will take any number of strings as arguments, and return a terminal-ready (i.e. parsed) string. \"\"\" if not name . startswith ( \"!\" ): raise ValueError ( \"TIM macro names must be prefixed by `!`.\" ) self . _macros [ name ] = method def alias ( self , name : str , value : str , * , generate_unsetter : bool = True ) -> None : \"\"\"Creates an alias from one custom name to a set of styles. These can be used to store and reference a set of tags using only one name. Aliases may reference other aliases, but only do this consciously, as it can become a hard to follow trail of sorrow very quickly! Args: name: The name this alias will be referenced by. value: The markup value that the alias will represent. generate_unsetter: Disable generating clearer aliases. For example: ``` my-tag = 141 bold italic ``` will generate: ``` /my-tag = /fg /bold /italic ``` \"\"\" def _generate_unsetter () -> str : unsetter = \"\" no_alias = eval_alias ( value , self . context ) for tag in no_alias . split (): if \"(\" in tag and \")\" in tag : tag = tag [: tag . find ( \"(\" )] if tag in self . _aliases or tag in self . _macros : unsetter += f \" / { tag } \" continue try : color = str_to_color ( tag ) unsetter += f \" / { 'bg' if color . background else 'fg' } \" except ColorSyntaxError : unsetter += f \" / { tag } \" return unsetter . lstrip ( \" \" ) self . _aliases [ name ] = value if generate_unsetter : self . _aliases [ f \"/ { name } \" ] = _generate_unsetter () def alias_multiple ( self , * , generate_unsetter : bool = True , ** items : str ) -> None : \"\"\"Runs `MarkupLanguage.alias` repeatedly for all arguments. The same `generate_unsetter` value will be used for all calls. You can use this in two forms: - Traditional keyword arguments: ```python lang.alias_multiple(my-tag1=\"bold\", my-tag2=\"italic\") ``` - Keyword argument unpacking: ```python my_aliases = {\"my-tag1\": \"bold\", \"my-tag2\": \"italic\"} lang.alias_multiple(**my_aliases) ``` \"\"\" for name , value in items . items (): self . alias ( name , value , generate_unsetter = generate_unsetter ) def parse ( self , text : str , optimize : bool = False , append_reset : bool = True , ) -> str : \"\"\"Parses some markup text. This is a thin wrapper around [markup.parsing.parse](/reference/ pytermgui/markup/parsing#pytermgui.markup.parsing.parse). The main additions of this wrapper are a caching system, as well as state management. Ignoring caching, all calls to this function would be equivalent to: ```python3 def parse(self, *args, **kwargs) -> str: kwargs[\"context\"] = self.context return parse(*args, **kwargs) ``` \"\"\" key = ( text , optimize , append_reset ) cache_hit = self . _cache . get ( key ) if cache_hit is not None : cached , tokens , has_macro = cache_hit # Re-parse using known tokens when macro is present # # This saves a tiny fraction of time (around 0.2ms) when parsing # macros, for a loss of an even smaller time for the general, # non-macro usecase. if has_macro : output = parse_tokens ( tokens , optimize = optimize , append_reset = append_reset , context = self . context , ignore_unknown_tags = not self . strict , ) return output return cached tokens = list ( tokenize_markup ( text )) output = parse_tokens ( tokens , optimize = optimize , append_reset = append_reset , context = self . context , ignore_unknown_tags = not self . strict , ) has_macro = any ( token . is_macro () for token in tokens ) self . _cache [ key ] = ( output , tokens , has_macro ) return output # TODO: This should be deprecated. @staticmethod def get_markup ( text : str ) -> str : \"\"\"DEPRECATED: Convert ANSI text into markup. This function does not use context, and thus is out of place here. \"\"\" return tokens_to_markup ( list ( tokenize_ansi ( text ))) def group_styles ( self , text : str , tokenizer : Tokenizer = tokenize_ansi ) -> Generator [ StyledText , None , None ]: \"\"\"Generate StyledText-s from some text, using our context. See `StyledText.group_styles` for arguments. \"\"\" yield from StyledText . group_styles ( text , tokenizer = tokenizer , context = self . context ) def print ( self , * args , ** kwargs ) -> None : \"\"\"Parse all arguments and pass them through to print, along with kwargs.\"\"\" parsed = [] for arg in args : parsed . append ( self . parse ( str ( arg ))) get_terminal () . print ( * parsed , ** kwargs )","title":"MarkupLanguage"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.MarkupLanguage.alias","text":"Creates an alias from one custom name to a set of styles. These can be used to store and reference a set of tags using only one name. Aliases may reference other aliases, but only do this consciously, as it can become a hard to follow trail of sorrow very quickly! Parameters: Name Type Description Default name str The name this alias will be referenced by. required value str The markup value that the alias will represent. required generate_unsetter bool Disable generating clearer aliases. For example: my-tag = 141 bold italic will generate: /my-tag = /fg /bold /italic True Source code in pytermgui/markup/language.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def alias ( self , name : str , value : str , * , generate_unsetter : bool = True ) -> None : \"\"\"Creates an alias from one custom name to a set of styles. These can be used to store and reference a set of tags using only one name. Aliases may reference other aliases, but only do this consciously, as it can become a hard to follow trail of sorrow very quickly! Args: name: The name this alias will be referenced by. value: The markup value that the alias will represent. generate_unsetter: Disable generating clearer aliases. For example: ``` my-tag = 141 bold italic ``` will generate: ``` /my-tag = /fg /bold /italic ``` \"\"\" def _generate_unsetter () -> str : unsetter = \"\" no_alias = eval_alias ( value , self . context ) for tag in no_alias . split (): if \"(\" in tag and \")\" in tag : tag = tag [: tag . find ( \"(\" )] if tag in self . _aliases or tag in self . _macros : unsetter += f \" / { tag } \" continue try : color = str_to_color ( tag ) unsetter += f \" / { 'bg' if color . background else 'fg' } \" except ColorSyntaxError : unsetter += f \" / { tag } \" return unsetter . lstrip ( \" \" ) self . _aliases [ name ] = value if generate_unsetter : self . _aliases [ f \"/ { name } \" ] = _generate_unsetter ()","title":"alias()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.MarkupLanguage.alias_multiple","text":"Runs MarkupLanguage.alias repeatedly for all arguments. The same generate_unsetter value will be used for all calls. You can use this in two forms: Traditional keyword arguments: lang . alias_multiple ( my - tag1 = \"bold\" , my - tag2 = \"italic\" ) Keyword argument unpacking: my_aliases = { \"my-tag1\" : \"bold\" , \"my-tag2\" : \"italic\" } lang . alias_multiple ( ** my_aliases ) Source code in pytermgui/markup/language.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def alias_multiple ( self , * , generate_unsetter : bool = True , ** items : str ) -> None : \"\"\"Runs `MarkupLanguage.alias` repeatedly for all arguments. The same `generate_unsetter` value will be used for all calls. You can use this in two forms: - Traditional keyword arguments: ```python lang.alias_multiple(my-tag1=\"bold\", my-tag2=\"italic\") ``` - Keyword argument unpacking: ```python my_aliases = {\"my-tag1\": \"bold\", \"my-tag2\": \"italic\"} lang.alias_multiple(**my_aliases) ``` \"\"\" for name , value in items . items (): self . alias ( name , value , generate_unsetter = generate_unsetter )","title":"alias_multiple()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.MarkupLanguage.aliases","text":"Returns a copy of the aliases defined in context. Source code in pytermgui/markup/language.py 81 82 83 84 85 @property def aliases ( self ) -> dict [ str , str ]: \"\"\"Returns a copy of the aliases defined in context.\"\"\" return self . _aliases . copy ()","title":"aliases()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.MarkupLanguage.clear_cache","text":"Clears the internal cache. Use this after re-defining aliases. Source code in pytermgui/markup/language.py 93 94 95 96 97 98 99 def clear_cache ( self ) -> None : \"\"\"Clears the internal cache. Use this after re-defining aliases. \"\"\" self . _cache . clear ()","title":"clear_cache()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.MarkupLanguage.define","text":"Defines a markup macro. Macros are essentially function bindings callable within markup. They can be very useful to represent changing data and simplify TIM code. Parameters: Name Type Description Default name str The name that will be used within TIM to call the macro. Must start with a bang ( ! ). required method MacroType The function bound to the name given above. This function will take any number of strings as arguments, and return a terminal-ready (i.e. parsed) string. required Source code in pytermgui/markup/language.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def define ( self , name : str , method : MacroType ) -> None : \"\"\"Defines a markup macro. Macros are essentially function bindings callable within markup. They can be very useful to represent changing data and simplify TIM code. Args: name: The name that will be used within TIM to call the macro. Must start with a bang (`!`). method: The function bound to the name given above. This function will take any number of strings as arguments, and return a terminal-ready (i.e. parsed) string. \"\"\" if not name . startswith ( \"!\" ): raise ValueError ( \"TIM macro names must be prefixed by `!`.\" ) self . _macros [ name ] = method","title":"define()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.MarkupLanguage.get_markup","text":"DEPRECATED: Convert ANSI text into markup. This function does not use context, and thus is out of place here. Source code in pytermgui/markup/language.py 257 258 259 260 261 262 263 264 @staticmethod def get_markup ( text : str ) -> str : \"\"\"DEPRECATED: Convert ANSI text into markup. This function does not use context, and thus is out of place here. \"\"\" return tokens_to_markup ( list ( tokenize_ansi ( text )))","title":"get_markup()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.MarkupLanguage.group_styles","text":"Generate StyledText-s from some text, using our context. See StyledText.group_styles for arguments. Source code in pytermgui/markup/language.py 266 267 268 269 270 271 272 273 274 275 276 def group_styles ( self , text : str , tokenizer : Tokenizer = tokenize_ansi ) -> Generator [ StyledText , None , None ]: \"\"\"Generate StyledText-s from some text, using our context. See `StyledText.group_styles` for arguments. \"\"\" yield from StyledText . group_styles ( text , tokenizer = tokenizer , context = self . context )","title":"group_styles()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.MarkupLanguage.macros","text":"Returns a copy of the macros defined in context. Source code in pytermgui/markup/language.py 87 88 89 90 91 @property def macros ( self ) -> dict [ str , MacroType ]: \"\"\"Returns a copy of the macros defined in context.\"\"\" return self . _macros . copy ()","title":"macros()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.MarkupLanguage.parse","text":"Parses some markup text. This is a thin wrapper around markup.parsing.parse . The main additions of this wrapper are a caching system, as well as state management. Ignoring caching, all calls to this function would be equivalent to: def parse ( self , * args , ** kwargs ) -> str : kwargs [ \"context\" ] = self . context return parse ( * args , ** kwargs ) Source code in pytermgui/markup/language.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def parse ( self , text : str , optimize : bool = False , append_reset : bool = True , ) -> str : \"\"\"Parses some markup text. This is a thin wrapper around [markup.parsing.parse](/reference/ pytermgui/markup/parsing#pytermgui.markup.parsing.parse). The main additions of this wrapper are a caching system, as well as state management. Ignoring caching, all calls to this function would be equivalent to: ```python3 def parse(self, *args, **kwargs) -> str: kwargs[\"context\"] = self.context return parse(*args, **kwargs) ``` \"\"\" key = ( text , optimize , append_reset ) cache_hit = self . _cache . get ( key ) if cache_hit is not None : cached , tokens , has_macro = cache_hit # Re-parse using known tokens when macro is present # # This saves a tiny fraction of time (around 0.2ms) when parsing # macros, for a loss of an even smaller time for the general, # non-macro usecase. if has_macro : output = parse_tokens ( tokens , optimize = optimize , append_reset = append_reset , context = self . context , ignore_unknown_tags = not self . strict , ) return output return cached tokens = list ( tokenize_markup ( text )) output = parse_tokens ( tokens , optimize = optimize , append_reset = append_reset , context = self . context , ignore_unknown_tags = not self . strict , ) has_macro = any ( token . is_macro () for token in tokens ) self . _cache [ key ] = ( output , tokens , has_macro ) return output","title":"parse()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.MarkupLanguage.print","text":"Parse all arguments and pass them through to print, along with kwargs. Source code in pytermgui/markup/language.py 278 279 280 281 282 283 284 285 def print ( self , * args , ** kwargs ) -> None : \"\"\"Parse all arguments and pass them through to print, along with kwargs.\"\"\" parsed = [] for arg in args : parsed . append ( self . parse ( str ( arg ))) get_terminal () . print ( * parsed , ** kwargs )","title":"print()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText","text":"An ANSI style-infused string. This is a sort of helper to handle ANSI texts in a more semantic manner. It keeps track of a sequence and a plain part. Calling len() will return the length of the printable, non-ANSI part, and indexing will return the characters at the given slice, but also include the sequences that are applied to them. To generate StyledText-s, it is recommended to use the StyledText.group_styles classmethod. Source code in pytermgui/markup/language.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 @dataclass ( frozen = True ) class StyledText : \"\"\"An ANSI style-infused string. This is a sort of helper to handle ANSI texts in a more semantic manner. It keeps track of a sequence and a plain part. Calling `len()` will return the length of the printable, non-ANSI part, and indexing will return the characters at the given slice, but also include the sequences that are applied to them. To generate StyledText-s, it is recommended to use the `StyledText.group_styles` classmethod. \"\"\" __slots__ = ( \"plain\" , \"sequences\" , \"tokens\" , \"link\" , \"__dict__\" ) sequences : str plain : str tokens : list [ Token ] link : str | None @cached_property def foreground ( self ) -> Color | None : \"\"\"Returns the foreground color of this object.\"\"\" colors = [ tkn for tkn in self . tokens if Token . is_color ( tkn ) and not tkn . color . background ] if len ( colors ) == 0 : return None return colors [ - 1 ] . color @cached_property def background ( self ) -> Color | None : \"\"\"Returns the background color of this object.\"\"\" colors = [ tkn for tkn in self . tokens if Token . is_color ( tkn ) and tkn . color . background ] if len ( colors ) == 0 : return None return colors [ - 1 ] . color @cached_property def bold ( self ) -> bool : \"\"\"Returns this text is bold.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"bold\" for tkn in self . tokens ) @cached_property def dim ( self ) -> bool : \"\"\"Returns this text is dimmed.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"dim\" for tkn in self . tokens ) @cached_property def italic ( self ) -> bool : \"\"\"Returns this text is italicized.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"italic\" for tkn in self . tokens ) @cached_property def underline ( self ) -> bool : \"\"\"Returns this text is underlined.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"underline\" for tkn in self . tokens ) @cached_property def blink ( self ) -> bool : \"\"\"Returns this text is blinking.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"blink\" for tkn in self . tokens ) @cached_property def blink2 ( self ) -> bool : \"\"\"Returns this text is alternate-blinking.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"blink2\" for tkn in self . tokens ) @cached_property def strikethrough ( self ) -> bool : \"\"\"Returns this text is striked out.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"strikethrough\" for tkn in self . tokens ) @cached_property def inverse ( self ) -> bool : \"\"\"Returns this text has its colors inversed.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"inverse\" for tkn in self . tokens ) @cached_property def overline ( self ) -> bool : \"\"\"Returns this text is overlined.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"overline\" for tkn in self . tokens ) @staticmethod def group_styles ( text : str , tokenizer : Tokenizer = tokenize_ansi , context : ContextDict | None = None , ) -> Generator [ StyledText , None , None ]: \"\"\"Yields StyledTexts from an ANSI coded string. A new StyledText will be created each time a non-plain token follows a plain token, thus all texts will represent a single (ANSI)PLAIN group of characters. \"\"\" context = context if context is not None else create_context_dict () parsers = PARSERS link = None def _parse ( token : Token ) -> str : nonlocal link if token . is_macro (): return token . markup if token . is_hyperlink (): link = token return \"\" if link is not None and Token . is_clear ( token ) and token . targets ( link ): link = None if token . is_clear () and token . value not in CLEARERS : return token . markup # The full text (last arg) is not relevant here, as ANSI parsing doesn't # use any context-defined tags, so no errors will occur. return parsers [ type ( token )]( token , context , lambda : \"\" ) # type: ignore tokens : list [ Token ] = [] token : Token for token in tokenizer ( text ): if token . is_plain (): yield StyledText ( \"\" . join ( _parse ( tkn ) for tkn in tokens ), token . value , tokens + [ token ], link . value if link is not None else None , ) tokens = [ tkn for tkn in tokens if not tkn . is_cursor ()] continue if Token . is_clear ( token ): tokens = [ tkn for tkn in tokens if not token . targets ( tkn )] if len ( tokens ) > 0 and tokens [ - 1 ] == token : continue if len ( tokens ) > 0 and all ( tkn . is_clear () for tkn in tokens ): tokens = [] tokens . append ( token ) # if len(tokens) > 0: # token = PlainToken(\"\") # yield StyledText( # \"\".join(_parse(tkn) for tkn in tokens), # token.value, # tokens + [token], # link.value if link is not None else None, # ) @classmethod def first_of ( cls , text : str ) -> StyledText | None : \"\"\"Returns the first element of cls.group_styles(text).\"\"\" for item in cls . group_styles ( text ): return item return None def __len__ ( self ) -> int : return len ( self . plain ) def __str__ ( self ) -> str : return self . sequences + self . plain def __getitem__ ( self , sli : int | slice ) -> str : return self . sequences + self . plain [ sli ]","title":"StyledText"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.background","text":"Returns the background color of this object. Source code in pytermgui/markup/language.py 328 329 330 331 332 333 334 335 336 337 338 339 @cached_property def background ( self ) -> Color | None : \"\"\"Returns the background color of this object.\"\"\" colors = [ tkn for tkn in self . tokens if Token . is_color ( tkn ) and tkn . color . background ] if len ( colors ) == 0 : return None return colors [ - 1 ] . color","title":"background()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.blink","text":"Returns this text is blinking. Source code in pytermgui/markup/language.py 369 370 371 372 373 @cached_property def blink ( self ) -> bool : \"\"\"Returns this text is blinking.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"blink\" for tkn in self . tokens )","title":"blink()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.blink2","text":"Returns this text is alternate-blinking. Source code in pytermgui/markup/language.py 375 376 377 378 379 380 381 @cached_property def blink2 ( self ) -> bool : \"\"\"Returns this text is alternate-blinking.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"blink2\" for tkn in self . tokens )","title":"blink2()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.bold","text":"Returns this text is bold. Source code in pytermgui/markup/language.py 341 342 343 344 345 @cached_property def bold ( self ) -> bool : \"\"\"Returns this text is bold.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"bold\" for tkn in self . tokens )","title":"bold()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.dim","text":"Returns this text is dimmed. Source code in pytermgui/markup/language.py 347 348 349 350 351 @cached_property def dim ( self ) -> bool : \"\"\"Returns this text is dimmed.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"dim\" for tkn in self . tokens )","title":"dim()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.first_of","text":"Returns the first element of cls.group_styles(text). Source code in pytermgui/markup/language.py 481 482 483 484 485 486 487 488 @classmethod def first_of ( cls , text : str ) -> StyledText | None : \"\"\"Returns the first element of cls.group_styles(text).\"\"\" for item in cls . group_styles ( text ): return item return None","title":"first_of()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.foreground","text":"Returns the foreground color of this object. Source code in pytermgui/markup/language.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 @cached_property def foreground ( self ) -> Color | None : \"\"\"Returns the foreground color of this object.\"\"\" colors = [ tkn for tkn in self . tokens if Token . is_color ( tkn ) and not tkn . color . background ] if len ( colors ) == 0 : return None return colors [ - 1 ] . color","title":"foreground()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.group_styles","text":"Yields StyledTexts from an ANSI coded string. A new StyledText will be created each time a non-plain token follows a plain token, thus all texts will represent a single (ANSI)PLAIN group of characters. Source code in pytermgui/markup/language.py 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 @staticmethod def group_styles ( text : str , tokenizer : Tokenizer = tokenize_ansi , context : ContextDict | None = None , ) -> Generator [ StyledText , None , None ]: \"\"\"Yields StyledTexts from an ANSI coded string. A new StyledText will be created each time a non-plain token follows a plain token, thus all texts will represent a single (ANSI)PLAIN group of characters. \"\"\" context = context if context is not None else create_context_dict () parsers = PARSERS link = None def _parse ( token : Token ) -> str : nonlocal link if token . is_macro (): return token . markup if token . is_hyperlink (): link = token return \"\" if link is not None and Token . is_clear ( token ) and token . targets ( link ): link = None if token . is_clear () and token . value not in CLEARERS : return token . markup # The full text (last arg) is not relevant here, as ANSI parsing doesn't # use any context-defined tags, so no errors will occur. return parsers [ type ( token )]( token , context , lambda : \"\" ) # type: ignore tokens : list [ Token ] = [] token : Token for token in tokenizer ( text ): if token . is_plain (): yield StyledText ( \"\" . join ( _parse ( tkn ) for tkn in tokens ), token . value , tokens + [ token ], link . value if link is not None else None , ) tokens = [ tkn for tkn in tokens if not tkn . is_cursor ()] continue if Token . is_clear ( token ): tokens = [ tkn for tkn in tokens if not token . targets ( tkn )] if len ( tokens ) > 0 and tokens [ - 1 ] == token : continue if len ( tokens ) > 0 and all ( tkn . is_clear () for tkn in tokens ): tokens = [] tokens . append ( token )","title":"group_styles()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.inverse","text":"Returns this text has its colors inversed. Source code in pytermgui/markup/language.py 391 392 393 394 395 396 397 @cached_property def inverse ( self ) -> bool : \"\"\"Returns this text has its colors inversed.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"inverse\" for tkn in self . tokens )","title":"inverse()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.italic","text":"Returns this text is italicized. Source code in pytermgui/markup/language.py 353 354 355 356 357 358 359 @cached_property def italic ( self ) -> bool : \"\"\"Returns this text is italicized.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"italic\" for tkn in self . tokens )","title":"italic()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.overline","text":"Returns this text is overlined. Source code in pytermgui/markup/language.py 399 400 401 402 403 404 405 @cached_property def overline ( self ) -> bool : \"\"\"Returns this text is overlined.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"overline\" for tkn in self . tokens )","title":"overline()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.strikethrough","text":"Returns this text is striked out. Source code in pytermgui/markup/language.py 383 384 385 386 387 388 389 @cached_property def strikethrough ( self ) -> bool : \"\"\"Returns this text is striked out.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"strikethrough\" for tkn in self . tokens )","title":"strikethrough()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.underline","text":"Returns this text is underlined. Source code in pytermgui/markup/language.py 361 362 363 364 365 366 367 @cached_property def underline ( self ) -> bool : \"\"\"Returns this text is underlined.\"\"\" return any ( Token . is_style ( tkn ) and tkn . markup == \"underline\" for tkn in self . tokens )","title":"underline()"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.escape","text":"Escapes any markup found within the given text. Source code in pytermgui/markup/language.py 41 42 43 44 45 46 47 48 49 def escape ( text : str ) -> str : \"\"\"Escapes any markup found within the given text.\"\"\" def _repl ( matchobj : Match ) -> str : full , * _ = matchobj . groups () return f \" \\\\ { full } \" return RE_MARKUP . sub ( _repl , text )","title":"escape()"},{"location":"reference/pytermgui/markup/macros/","text":"All PTG-builtin TIM macros. apply_default_macros ( lang ) Applies all macros in DEFAULT_MACROS . Parameters: Name Type Description Default lang MarkupLanguage The language to apply the macros to. required Source code in pytermgui/markup/macros.py 28 29 30 31 32 33 34 35 36 def apply_default_macros ( lang : MarkupLanguage ) -> None : \"\"\"Applies all macros in `DEFAULT_MACROS`. Args: lang: The language to apply the macros to. \"\"\" for name , value in DEFAULT_MACROS . items (): lang . define ( name , value ) export_macro ( func ) A decorator to add a function to DEFAULT_MACROS . Source code in pytermgui/markup/macros.py 18 19 20 21 22 23 24 25 def export_macro ( func : MacroTemplate ) -> MacroTemplate : \"\"\"A decorator to add a function to `DEFAULT_MACROS`.\"\"\" name = \"_\" . join ( func . __name__ . split ( \"_\" )[ 1 :]) # type: ignore DEFAULT_MACROS [ f \"! { name } \" ] = func return func macro_align ( width , alignment , content ) Aligns given text using fstrings. Parameters: Name Type Description Default width str The width to align to. required alignment str One of \"left\", \"center\", \"right\". required content str The content to align; implicit argument. required Source code in pytermgui/markup/macros.py 60 61 62 63 64 65 66 67 68 69 70 71 @export_macro def macro_align ( width : str , alignment : str , content : str ) -> str : \"\"\"Aligns given text using fstrings. Args: width: The width to align to. alignment: One of \"left\", \"center\", \"right\". content: The content to align; implicit argument. \"\"\" aligner = \"<\" if alignment == \"left\" else ( \">\" if alignment == \"right\" else \"^\" ) return f \" { content :{ aligner }{ width }} \" macro_expand ( lang , tag ) Expands a tag alias. Source code in pytermgui/markup/macros.py 74 75 76 77 78 79 80 81 @export_macro def macro_expand ( lang : MarkupLanguage , tag : str ) -> str : \"\"\"Expands a tag alias.\"\"\" if not tag in lang . user_tags : return tag return lang . get_markup ( f \" \\x1b [ { lang . user_tags [ tag ] } m \" )[: - 1 ] macro_gradient ( base_str , item ) Creates an xterm-256 gradient from a base color. This exploits the way the colors are arranged in the xterm color table; every 36th color is the next item of a single gradient. The start of this given gradient is calculated by decreasing the given base by 36 on every iteration as long as the point is a valid gradient start. After that, the 6 colors of this gradient are calculated and applied. Source code in pytermgui/markup/macros.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 @export_macro def macro_gradient ( base_str : str , item : str ) -> str : \"\"\"Creates an xterm-256 gradient from a base color. This exploits the way the colors are arranged in the xterm color table; every 36th color is the next item of a single gradient. The start of this given gradient is calculated by decreasing the given base by 36 on every iteration as long as the point is a valid gradient start. After that, the 6 colors of this gradient are calculated and applied. \"\"\" if not base_str . isdigit (): raise ValueError ( f \"Gradient base has to be a digit, got { base_str } .\" ) base = int ( base_str ) if base < 16 or base > 231 : raise ValueError ( \"Gradient base must be between 16 and 232\" ) while base > 52 : base -= 36 colors = [] for i in range ( 6 ): colors . append ( base + 36 * i ) return _apply_colors ( colors , item ) macro_lower ( text ) Turns the text into lowercase. Source code in pytermgui/markup/macros.py 46 47 48 49 50 @export_macro def macro_lower ( text : str ) -> str : \"\"\"Turns the text into lowercase.\"\"\" return text . lower () macro_rainbow ( item ) Creates rainbow-colored text. Source code in pytermgui/markup/macros.py 111 112 113 114 115 116 117 @export_macro def macro_rainbow ( item : str ) -> str : \"\"\"Creates rainbow-colored text.\"\"\" colors = [ \"red\" , \"orange\" , \"yellow\" , \"green\" , \"blue\" , \"indigo\" , \"violet\" ] return _apply_colors ( colors , item ) macro_shuffle ( item ) Shuffles a string using shuffle.shuffle on its list cast. Source code in pytermgui/markup/macros.py 84 85 86 87 88 89 90 91 @export_macro def macro_shuffle ( item : str ) -> str : \"\"\"Shuffles a string using shuffle.shuffle on its list cast.\"\"\" shuffled = list ( item ) shuffle ( shuffled ) return \"\" . join ( shuffled ) macro_title ( text ) Turns the text into titlecase. Source code in pytermgui/markup/macros.py 53 54 55 56 57 @export_macro def macro_title ( text : str ) -> str : \"\"\"Turns the text into titlecase.\"\"\" return text . title () macro_upper ( text ) Turns the text into uppercase. Source code in pytermgui/markup/macros.py 39 40 41 42 43 @export_macro def macro_upper ( text : str ) -> str : \"\"\"Turns the text into uppercase.\"\"\" return text . upper ()","title":"macros"},{"location":"reference/pytermgui/markup/macros/#pytermgui.markup.macros.apply_default_macros","text":"Applies all macros in DEFAULT_MACROS . Parameters: Name Type Description Default lang MarkupLanguage The language to apply the macros to. required Source code in pytermgui/markup/macros.py 28 29 30 31 32 33 34 35 36 def apply_default_macros ( lang : MarkupLanguage ) -> None : \"\"\"Applies all macros in `DEFAULT_MACROS`. Args: lang: The language to apply the macros to. \"\"\" for name , value in DEFAULT_MACROS . items (): lang . define ( name , value )","title":"apply_default_macros()"},{"location":"reference/pytermgui/markup/macros/#pytermgui.markup.macros.export_macro","text":"A decorator to add a function to DEFAULT_MACROS . Source code in pytermgui/markup/macros.py 18 19 20 21 22 23 24 25 def export_macro ( func : MacroTemplate ) -> MacroTemplate : \"\"\"A decorator to add a function to `DEFAULT_MACROS`.\"\"\" name = \"_\" . join ( func . __name__ . split ( \"_\" )[ 1 :]) # type: ignore DEFAULT_MACROS [ f \"! { name } \" ] = func return func","title":"export_macro()"},{"location":"reference/pytermgui/markup/macros/#pytermgui.markup.macros.macro_align","text":"Aligns given text using fstrings. Parameters: Name Type Description Default width str The width to align to. required alignment str One of \"left\", \"center\", \"right\". required content str The content to align; implicit argument. required Source code in pytermgui/markup/macros.py 60 61 62 63 64 65 66 67 68 69 70 71 @export_macro def macro_align ( width : str , alignment : str , content : str ) -> str : \"\"\"Aligns given text using fstrings. Args: width: The width to align to. alignment: One of \"left\", \"center\", \"right\". content: The content to align; implicit argument. \"\"\" aligner = \"<\" if alignment == \"left\" else ( \">\" if alignment == \"right\" else \"^\" ) return f \" { content :{ aligner }{ width }} \"","title":"macro_align()"},{"location":"reference/pytermgui/markup/macros/#pytermgui.markup.macros.macro_expand","text":"Expands a tag alias. Source code in pytermgui/markup/macros.py 74 75 76 77 78 79 80 81 @export_macro def macro_expand ( lang : MarkupLanguage , tag : str ) -> str : \"\"\"Expands a tag alias.\"\"\" if not tag in lang . user_tags : return tag return lang . get_markup ( f \" \\x1b [ { lang . user_tags [ tag ] } m \" )[: - 1 ]","title":"macro_expand()"},{"location":"reference/pytermgui/markup/macros/#pytermgui.markup.macros.macro_gradient","text":"Creates an xterm-256 gradient from a base color. This exploits the way the colors are arranged in the xterm color table; every 36th color is the next item of a single gradient. The start of this given gradient is calculated by decreasing the given base by 36 on every iteration as long as the point is a valid gradient start. After that, the 6 colors of this gradient are calculated and applied. Source code in pytermgui/markup/macros.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 @export_macro def macro_gradient ( base_str : str , item : str ) -> str : \"\"\"Creates an xterm-256 gradient from a base color. This exploits the way the colors are arranged in the xterm color table; every 36th color is the next item of a single gradient. The start of this given gradient is calculated by decreasing the given base by 36 on every iteration as long as the point is a valid gradient start. After that, the 6 colors of this gradient are calculated and applied. \"\"\" if not base_str . isdigit (): raise ValueError ( f \"Gradient base has to be a digit, got { base_str } .\" ) base = int ( base_str ) if base < 16 or base > 231 : raise ValueError ( \"Gradient base must be between 16 and 232\" ) while base > 52 : base -= 36 colors = [] for i in range ( 6 ): colors . append ( base + 36 * i ) return _apply_colors ( colors , item )","title":"macro_gradient()"},{"location":"reference/pytermgui/markup/macros/#pytermgui.markup.macros.macro_lower","text":"Turns the text into lowercase. Source code in pytermgui/markup/macros.py 46 47 48 49 50 @export_macro def macro_lower ( text : str ) -> str : \"\"\"Turns the text into lowercase.\"\"\" return text . lower ()","title":"macro_lower()"},{"location":"reference/pytermgui/markup/macros/#pytermgui.markup.macros.macro_rainbow","text":"Creates rainbow-colored text. Source code in pytermgui/markup/macros.py 111 112 113 114 115 116 117 @export_macro def macro_rainbow ( item : str ) -> str : \"\"\"Creates rainbow-colored text.\"\"\" colors = [ \"red\" , \"orange\" , \"yellow\" , \"green\" , \"blue\" , \"indigo\" , \"violet\" ] return _apply_colors ( colors , item )","title":"macro_rainbow()"},{"location":"reference/pytermgui/markup/macros/#pytermgui.markup.macros.macro_shuffle","text":"Shuffles a string using shuffle.shuffle on its list cast. Source code in pytermgui/markup/macros.py 84 85 86 87 88 89 90 91 @export_macro def macro_shuffle ( item : str ) -> str : \"\"\"Shuffles a string using shuffle.shuffle on its list cast.\"\"\" shuffled = list ( item ) shuffle ( shuffled ) return \"\" . join ( shuffled )","title":"macro_shuffle()"},{"location":"reference/pytermgui/markup/macros/#pytermgui.markup.macros.macro_title","text":"Turns the text into titlecase. Source code in pytermgui/markup/macros.py 53 54 55 56 57 @export_macro def macro_title ( text : str ) -> str : \"\"\"Turns the text into titlecase.\"\"\" return text . title ()","title":"macro_title()"},{"location":"reference/pytermgui/markup/macros/#pytermgui.markup.macros.macro_upper","text":"Turns the text into uppercase. Source code in pytermgui/markup/macros.py 39 40 41 42 43 @export_macro def macro_upper ( text : str ) -> str : \"\"\"Turns the text into uppercase.\"\"\" return text . upper ()","title":"macro_upper()"},{"location":"reference/pytermgui/markup/parsing/","text":"The internals of the TIM engine. ContextDict Bases: TypedDict A dictionary to hold context about a markup language's environment. It has two sub-dicts: aliases macros For information about what they do and contain, see the MarkupLanguage docs . Source code in pytermgui/markup/parsing.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class ContextDict ( TypedDict ): \"\"\"A dictionary to hold context about a markup language's environment. It has two sub-dicts: - aliases - macros For information about what they do and contain, see the [MarkupLanguage docs](/reference/pytermgui/markup/ language#pytermgui.markup.language.MarkupLanguage). \"\"\" aliases : dict [ str , str ] macros : dict [ str , MacroType ] MacroType Bases: Protocol A protocol for TIM macros. Source code in pytermgui/markup/parsing.py 49 50 51 52 53 54 55 class MacroType ( Protocol ): # pylint: disable=too-few-public-methods \"\"\"A protocol for TIM macros.\"\"\" def __call__ ( # pylint: disable=no-method-argument, no-self-argument * args : str , ) -> str : \"\"\"Applies the macro.\"\"\" __call__ ( args ) Applies the macro. Source code in pytermgui/markup/parsing.py 52 53 54 55 def __call__ ( # pylint: disable=no-method-argument, no-self-argument * args : str , ) -> str : \"\"\"Applies the macro.\"\"\" consume_tag ( tag ) Consumes a tag text, returns the associated Token. Source code in pytermgui/markup/parsing.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def consume_tag ( tag : str ) -> Token : # pylint: disable=too-many-return-statements \"\"\"Consumes a tag text, returns the associated Token.\"\"\" if tag in STYLES : return StyleToken ( tag ) if tag . startswith ( \"/\" ): return ClearToken ( tag ) if tag . startswith ( \"!\" ): matchobj = RE_MACRO . match ( tag ) if matchobj is not None : name , args = matchobj . groups () if args is None : return MacroToken ( name , tuple ()) return MacroToken ( name , tuple ( args . split ( \":\" ))) if tag . startswith ( \"~\" ): return HLinkToken ( tag [ 1 :]) if tag . startswith ( \"(\" ) and tag . endswith ( \")\" ): values = tag [ 1 : - 1 ] . split ( \";\" ) if len ( values ) != 2 : raise MarkupSyntaxError ( tag , f \"should have exactly 2 values separated by `;`, not { len ( values ) } \" , \"\" , ) return CursorToken ( tag [ 1 : - 1 ], * map ( int , values )) if tag == \"#auto\" : return PseudoToken ( \"#auto\" ) token : Token try : token = ColorToken ( tag , Color . parse ( tag , localize = False )) except ColorSyntaxError : token = AliasToken ( tag ) finally : return token # pylint: disable=lost-exception create_context_dict () Creates a new context dictionary, initializing its sub-dicts. Returns: Type Description ContextDict A dictionary with aliases and macros defined as empty sub-dicts. Source code in pytermgui/markup/parsing.py 75 76 77 78 79 80 81 82 def create_context_dict () -> ContextDict : \"\"\"Creates a new context dictionary, initializing its sub-dicts. Returns: A dictionary with `aliases` and `macros` defined as empty sub-dicts. \"\"\" return { \"aliases\" : {}, \"macros\" : {}} eval_alias ( text , context ) Evaluates a space-delimited string of alias tags into their underlying value. Parameters: Name Type Description Default text str A space-separated string containing the aliases. required Returns: Type Description str The space-separated string that the input aliases represent. Source code in pytermgui/markup/parsing.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 def eval_alias ( text : str , context : ContextDict ) -> str : \"\"\"Evaluates a space-delimited string of alias tags into their underlying value. Args: text: A space-separated string containing the aliases. Returns: The space-separated string that the input aliases represent. \"\"\" aliases = context [ \"aliases\" ] evaluated = \"\" for tag in text . split (): if tag not in aliases : evaluated += tag + \" \" continue evaluated += eval_alias ( aliases [ tag ], context ) + \" \" return evaluated . rstrip ( \" \" ) get_markup ( text ) Gets the markup representing an ANSI-coded string. Source code in pytermgui/markup/parsing.py 527 528 529 530 def get_markup ( text : str ) -> str : \"\"\"Gets the markup representing an ANSI-coded string.\"\"\" return tokens_to_markup ( list ( tokenize_ansi ( text ))) optimize_markup ( markup ) Optimizes markup by tokenizing it, optimizing the tokens and converting it back to markup. Source code in pytermgui/markup/parsing.py 533 534 535 536 def optimize_markup ( markup : str ) -> str : \"\"\"Optimizes markup by tokenizing it, optimizing the tokens and converting it back to markup.\"\"\" return tokens_to_markup ( list ( optimize_tokens ( list ( tokenize_markup ( markup ))))) optimize_tokens ( tokens ) Optimizes a stream of tokens, only yielding functionally relevant ones. Parameters: Name Type Description Default tokens list [ Token ] Any list of Token objects. Usually obtained from tokenize_markup or tokenize_ansi . required Yields: Type Description Iterator [ Token ] All those tokens within the input iterator that are functionally relevant, keeping their order. Source code in pytermgui/markup/parsing.py 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 def optimize_tokens ( tokens : list [ Token ]) -> Iterator [ Token ]: \"\"\"Optimizes a stream of tokens, only yielding functionally relevant ones. Args: tokens: Any list of Token objects. Usually obtained from `tokenize_markup` or `tokenize_ansi`. Yields: All those tokens within the input iterator that are functionally relevant, keeping their order. \"\"\" previous : list [ Token ] = [] current_tag_group : list [ Token ] = [] def _diff_previous () -> Iterator [ Token ]: \"\"\"Find difference from the previously active list of tokens.\"\"\" applied = previous . copy () for tkn in current_tag_group : targets = [] clearer = Token . is_clear ( tkn ) if Token . is_clear ( tkn ): targets = [ tkn . targets ( tag ) for tag in applied ] if tkn in previous and not clearer : continue if clearer and not any ( targets ): continue applied . append ( tkn ) yield tkn def _remove_redundant_color ( token : Token ) -> None : \"\"\"Removes non-functional colors. These happen in the following ways: - Multiple colors of the same channel (fg/bg) are present. - A color is applied, then a clearer clears it. \"\"\" for applied in current_tag_group . copy (): if Token . is_clear ( applied ) and applied . targets ( token ): current_tag_group . remove ( applied ) if not Token . is_color ( applied ): continue old = applied . color if old . background == new . background : current_tag_group . remove ( applied ) for token in tokens : if Token . is_plain ( token ): yield from _diff_previous () yield token previous = current_tag_group . copy () continue if Token . is_color ( token ): new = token . color _remove_redundant_color ( token ) if not any ( token . markup == applied . markup for applied in current_tag_group ): current_tag_group . append ( token ) continue if token . is_style (): if not any ( token == tag for tag in current_tag_group ): current_tag_group . append ( token ) continue if Token . is_clear ( token ): applied = False for tag in current_tag_group . copy (): if token . targets ( tag ) or token == tag : current_tag_group . remove ( tag ) applied = True if not applied : continue current_tag_group . append ( token ) yield from _diff_previous () parse ( text , optimize = False , context = None , append_reset = True , ignore_unknown_tags = True ) Parses markup into the ANSI-coded string it represents. Parameters: Name Type Description Default text str Any valid markup. required optimize bool If set, optimize_tokens will optimize the tokens found within the input markup before usage. This will incur a (minor) performance hit. False context ContextDict | None The context that aliases and macros found within the markup will be searched in. None append_reset bool If set, [/] will be appended to the token iterator, clearing all styles. True ignore_unknown_tags bool If set, the MarkupSyntaxError coming from unknown tags will be silenced. True Returns: Type Description str The ANSI-coded string that the markup represents. Source code in pytermgui/markup/parsing.py 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 def parse ( text : str , optimize : bool = False , context : ContextDict | None = None , append_reset : bool = True , ignore_unknown_tags : bool = True , ) -> str : \"\"\"Parses markup into the ANSI-coded string it represents. Args: text: Any valid markup. optimize: If set, `optimize_tokens` will optimize the tokens found within the input markup before usage. This will incur a (minor) performance hit. context: The context that aliases and macros found within the markup will be searched in. append_reset: If set, `[/]` will be appended to the token iterator, clearing all styles. ignore_unknown_tags: If set, the `MarkupSyntaxError` coming from unknown tags will be silenced. Returns: The ANSI-coded string that the markup represents. \"\"\" if context is None : context = create_context_dict () if append_reset and not text . endswith ( \"/]\" ): text += \"[/]\" tokens = list ( tokenize_markup ( text )) return parse_tokens ( tokens , optimize = optimize , context = context , append_reset = append_reset , ignore_unknown_tags = ignore_unknown_tags , ) parse_alias ( token , context , get_full ) Parses an alias token. Source code in pytermgui/markup/parsing.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 def parse_alias ( token : AliasToken , context : ContextDict , get_full : Callable [[], str ] ) -> str : \"\"\"Parses an alias token.\"\"\" if token . value not in context [ \"aliases\" ]: dump = json . dumps ( context [ \"aliases\" ], indent = 2 , default = str ) raise MarkupSyntaxError ( token . value , f \"not defined in alias context: { dump } \" , get_full () ) meaning = context [ \"aliases\" ][ token . value ] return eval_alias ( meaning , context ) . rstrip ( \" \" ) parse_clear ( token , _ , get_full ) Parses a clearer token. Source code in pytermgui/markup/parsing.py 380 381 382 383 384 385 386 387 388 389 def parse_clear ( token : ClearToken , _ : ContextDict , get_full : Callable [[], str ]) -> str : \"\"\"Parses a clearer token.\"\"\" index = CLEARERS . get ( token . value ) if index is None : raise MarkupSyntaxError ( token . value , \"not a recognized clearer or alias\" , get_full () ) return f \" \\x1b [ { index } m\" parse_color ( token , _ , __ ) Parses a color token. Source code in pytermgui/markup/parsing.py 327 328 329 330 def parse_color ( token : ColorToken , _ : ContextDict , __ : Callable [[], str ]) -> str : \"\"\"Parses a color token.\"\"\" return token . color . get_localized () . sequence parse_cursor ( token , _ , __ ) Parses a cursor token. Source code in pytermgui/markup/parsing.py 392 393 394 395 396 397 def parse_cursor ( token : CursorToken , _ : ContextDict , __ : Callable [[], str ]) -> str : \"\"\"Parses a cursor token.\"\"\" ypos , xpos = map ( lambda i : \"\" if i is None else i , token ) return f \" \\x1b [ { ypos } ; { xpos } H\" parse_macro ( token , context , get_full ) Parses a macro token. Returns: Type Description MacroType A tuple containing the callable bound to the name, as well as the arguments tuple [ str , ...] passed to it. Source code in pytermgui/markup/parsing.py 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def parse_macro ( token : MacroToken , context : ContextDict , get_full : Callable [[], str ] ) -> tuple [ MacroType , tuple [ str , ... ]]: \"\"\"Parses a macro token. Returns: A tuple containing the callable bound to the name, as well as the arguments passed to it. \"\"\" func = context [ \"macros\" ] . get ( token . value ) if func is None : dump = json . dumps ( context [ \"macros\" ], indent = 2 , default = str ) raise MarkupSyntaxError ( token . value , f \"not defined in macro context: { dump } \" , get_full () ) return func , token . arguments parse_plain ( token , _ , __ ) Parses a plain token. Source code in pytermgui/markup/parsing.py 321 322 323 324 def parse_plain ( token : PlainToken , _ : ContextDict , __ : Callable [[], str ]) -> str : \"\"\"Parses a plain token.\"\"\" return token . value parse_style ( token , _ , __ ) Parses a style token. Source code in pytermgui/markup/parsing.py 333 334 335 336 337 338 def parse_style ( token : StyleToken , _ : ContextDict , __ : Callable [[], str ]) -> str : \"\"\"Parses a style token.\"\"\" index = STYLES [ token . value ] return f \" \\x1b [ { index } m\" parse_tokens ( tokens , * , optimize = False , context = None , append_reset = True , ignore_unknown_tags = True ) Parses a stream of tokens into the ANSI-coded string they represent. Parameters: Name Type Description Default tokens list [ Token ] Any list of Tokens, usually obtained from either tokenize_ansi or tokenize_markup . required optimize bool If set, optimize_tokens will optimize the input iterator before usage. This will incur a (minor) performance hit. False context ContextDict | None The context that aliases and macros found within the tokens will be searched in. None append_reset bool If set, ClearToken(\"/\") will be appended to the token iterator, clearing all styles. True ignore_unknown_tags bool If set, the MarkupSyntaxError coming from unknown tags will be silenced. True Returns: Type Description str The ANSI-coded string that the token stream represents. Source code in pytermgui/markup/parsing.py 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 def parse_tokens ( # pylint: disable=too-many-branches, too-many-locals, too-many-statements tokens : list [ Token ], * , optimize : bool = False , context : ContextDict | None = None , append_reset : bool = True , ignore_unknown_tags : bool = True , ) -> str : \"\"\"Parses a stream of tokens into the ANSI-coded string they represent. Args: tokens: Any list of Tokens, usually obtained from either `tokenize_ansi` or `tokenize_markup`. optimize: If set, `optimize_tokens` will optimize the input iterator before usage. This will incur a (minor) performance hit. context: The context that aliases and macros found within the tokens will be searched in. append_reset: If set, `ClearToken(\"/\")` will be appended to the token iterator, clearing all styles. ignore_unknown_tags: If set, the `MarkupSyntaxError` coming from unknown tags will be silenced. Returns: The ANSI-coded string that the token stream represents. \"\"\" if context is None : context = create_context_dict () token_list = _sub_aliases ( tokens , context ) # It's more computationally efficient to create this lambda once and reuse it # every time. There is no need to define a full function, as it just returns # a function return. get_full = ( lambda : tokens_to_markup ( # pylint: disable=unnecessary-lambda-assignment token_list ) ) if optimize : token_list = list ( optimize_tokens ( token_list )) if append_reset : token_list . append ( ClearToken ( \"/\" )) link = None output = \"\" segment = \"\" background = Color . parse ( \"#000000\" ) macros : list [ MacroToken ] = [] unknown_aliases : list [ Token ] = [] for token in token_list : if token . is_plain (): value = _apply_macros ( token . value , ( parse_macro ( macro , context , get_full ) for macro in macros ) ) if len ( unknown_aliases ) > 0 : output += f \"[ { ' ' . join ( tkn . value for tkn in unknown_aliases ) } ]\" unknown_aliases = [] output += segment + ( value if link is None else LINK_TEMPLATE . format ( uri = link , label = value ) ) segment = \"\" continue if token . is_hyperlink (): link = token . value continue if Token . is_macro ( token ): macros . append ( token ) continue if Token . is_clear ( token ): if token . value in ( \"/\" , \"/~\" ): link = None found = False for macro in macros . copy (): if token . targets ( macro ): macros . remove ( macro ) found = True break if found and token . value != \"/\" : continue if token . value . startswith ( \"/!\" ): raise MarkupSyntaxError ( token . value , \"has nothing to target\" , get_full () ) if Token . is_color ( token ) and token . color . background : background = token . color if Token . is_pseudo ( token ): if token . value == \"#auto\" : token = ColorToken ( \"#auto\" , background . contrast ) try : segment += PARSERS [ type ( token )]( token , context , get_full ) # type: ignore except MarkupSyntaxError : if not ignore_unknown_tags : raise unknown_aliases . append ( token ) if len ( unknown_aliases ) > 0 : output += f \"[ { ' ' . join ( tkn . value for tkn in unknown_aliases ) } ]\" output += segment return output tokenize_ansi ( text ) Converts some ANSI-coded text into a stream of tokens. Parameters: Name Type Description Default text str Any valid ANSI-coded text. required Yields: Type Description Iterator [ Token ] The generated tokens, in the order they occur within the text. Source code in pytermgui/markup/parsing.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def tokenize_ansi ( # pylint: disable=too-many-locals, too-many-branches, too-many-statements text : str , ) -> Iterator [ Token ]: \"\"\"Converts some ANSI-coded text into a stream of tokens. Args: text: Any valid ANSI-coded text. Yields: The generated tokens, in the order they occur within the text. \"\"\" cursor = 0 for matchobj in RE_ANSI . finditer ( text ): start , end = matchobj . span () csi = matchobj . groups ()[ 0 : 2 ] link_osc = matchobj . groups ()[ 2 : 4 ] if link_osc != ( None , None ): cursor = end uri , label = link_osc yield HLinkToken ( uri ) yield PlainToken ( label ) continue full , content = csi if cursor < start : yield PlainToken ( text [ cursor : start ]) cursor = end code = \"\" # Position posmatch = RE_POSITION . match ( full ) if posmatch is not None : ypos , xpos = posmatch . groups () if not ypos and not xpos : raise ValueError ( f \"Cannot parse cursor when no position is supplied. Match: { posmatch !r} \" ) yield CursorToken ( content , int ( ypos ) or None , int ( xpos ) or None ) continue parts = content . split ( \";\" ) state = None color_code = \"\" for part in parts : if state is None : if part in REVERSE_STYLES : yield StyleToken ( REVERSE_STYLES [ part ]) continue if part in REVERSE_CLEARERS : yield ClearToken ( REVERSE_CLEARERS [ part ]) continue if part in ( \"38\" , \"48\" ): state = \"COLOR\" color_code += part + \";\" continue # standard colors try : yield ColorToken ( part , Color . parse ( part , localize = False )) continue except ColorSyntaxError as exc : raise ValueError ( f \"Could not parse color tag { part !r} .\" ) from exc if state != \"COLOR\" : continue color_code += part + \";\" # Ignore incomplete RGB colors if ( color_code . startswith (( \"38;2;\" , \"48;2;\" )) and len ( color_code . split ( \";\" )) != 6 ): continue try : code = color_code if code . startswith (( \"38;2;\" , \"48;2;\" , \"38;5;\" , \"48;5;\" )): stripped = code [ 5 : - 1 ] if code . startswith ( \"4\" ): stripped = \"@\" + stripped code = stripped yield ColorToken ( code , Color . parse ( code , localize = False )) except ColorSyntaxError : continue state = None color_code = \"\" remaining = text [ cursor :] if len ( remaining ) > 0 : yield PlainToken ( remaining ) tokenize_markup ( text ) Converts some markup text into a stream of tokens. Parameters: Name Type Description Default text str Any valid markup. required Yields: Type Description Iterator [ Token ] The generated tokens, in the order they occur within the markup. Source code in pytermgui/markup/parsing.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def tokenize_markup ( text : str ) -> Iterator [ Token ]: \"\"\"Converts some markup text into a stream of tokens. Args: text: Any valid markup. Yields: The generated tokens, in the order they occur within the markup. \"\"\" cursor = 0 length = len ( text ) has_inverse = False for matchobj in RE_MARKUP . finditer ( text ): full , escapes , content = matchobj . groups () start , end = matchobj . span () if cursor < start : yield PlainToken ( text [ cursor : start ]) if not escapes == \"\" : _ , remaining = divmod ( len ( escapes ), 2 ) yield PlainToken ( full [ max ( 1 - remaining , 1 ) :]) cursor = end continue for tag in content . split (): if tag == \"inverse\" : has_inverse = True if tag == \"/inverse\" : has_inverse = False consumed = consume_tag ( tag ) if has_inverse : if consumed . markup == \"/fg\" : consumed = ClearToken ( \"/fg\" ) elif consumed . markup == \"/bg\" : consumed = ClearToken ( \"/bg\" ) yield consumed cursor = end if cursor < length : yield PlainToken ( text [ cursor : length ]) tokens_to_markup ( tokens ) Converts a token stream into the markup of its tokens. Parameters: Name Type Description Default tokens list [ Token ] Any list of Token objects. Usually obtained from tokenize_markup or tokenize_ansi . required Returns: Type Description str The markup the given tokens represent. Source code in pytermgui/markup/parsing.py 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 def tokens_to_markup ( tokens : list [ Token ]) -> str : \"\"\"Converts a token stream into the markup of its tokens. Args: tokens: Any list of Token objects. Usually obtained from `tokenize_markup` or `tokenize_ansi`. Returns: The markup the given tokens represent. \"\"\" tags : list [ Token ] = [] markup = \"\" for token in tokens : if token . is_plain (): if len ( tags ) > 0 : markup += f \"[ { ' ' . join ( tag . markup for tag in tags ) } ]\" markup += token . value tags = [] else : tags . append ( token ) if len ( tags ) > 0 : markup += f \"[ { ' ' . join ( tag . markup for tag in tags ) } ]\" return markup","title":"parsing"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.ContextDict","text":"Bases: TypedDict A dictionary to hold context about a markup language's environment. It has two sub-dicts: aliases macros For information about what they do and contain, see the MarkupLanguage docs . Source code in pytermgui/markup/parsing.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class ContextDict ( TypedDict ): \"\"\"A dictionary to hold context about a markup language's environment. It has two sub-dicts: - aliases - macros For information about what they do and contain, see the [MarkupLanguage docs](/reference/pytermgui/markup/ language#pytermgui.markup.language.MarkupLanguage). \"\"\" aliases : dict [ str , str ] macros : dict [ str , MacroType ]","title":"ContextDict"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.MacroType","text":"Bases: Protocol A protocol for TIM macros. Source code in pytermgui/markup/parsing.py 49 50 51 52 53 54 55 class MacroType ( Protocol ): # pylint: disable=too-few-public-methods \"\"\"A protocol for TIM macros.\"\"\" def __call__ ( # pylint: disable=no-method-argument, no-self-argument * args : str , ) -> str : \"\"\"Applies the macro.\"\"\"","title":"MacroType"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.MacroType.__call__","text":"Applies the macro. Source code in pytermgui/markup/parsing.py 52 53 54 55 def __call__ ( # pylint: disable=no-method-argument, no-self-argument * args : str , ) -> str : \"\"\"Applies the macro.\"\"\"","title":"__call__()"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.consume_tag","text":"Consumes a tag text, returns the associated Token. Source code in pytermgui/markup/parsing.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def consume_tag ( tag : str ) -> Token : # pylint: disable=too-many-return-statements \"\"\"Consumes a tag text, returns the associated Token.\"\"\" if tag in STYLES : return StyleToken ( tag ) if tag . startswith ( \"/\" ): return ClearToken ( tag ) if tag . startswith ( \"!\" ): matchobj = RE_MACRO . match ( tag ) if matchobj is not None : name , args = matchobj . groups () if args is None : return MacroToken ( name , tuple ()) return MacroToken ( name , tuple ( args . split ( \":\" ))) if tag . startswith ( \"~\" ): return HLinkToken ( tag [ 1 :]) if tag . startswith ( \"(\" ) and tag . endswith ( \")\" ): values = tag [ 1 : - 1 ] . split ( \";\" ) if len ( values ) != 2 : raise MarkupSyntaxError ( tag , f \"should have exactly 2 values separated by `;`, not { len ( values ) } \" , \"\" , ) return CursorToken ( tag [ 1 : - 1 ], * map ( int , values )) if tag == \"#auto\" : return PseudoToken ( \"#auto\" ) token : Token try : token = ColorToken ( tag , Color . parse ( tag , localize = False )) except ColorSyntaxError : token = AliasToken ( tag ) finally : return token # pylint: disable=lost-exception","title":"consume_tag()"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.create_context_dict","text":"Creates a new context dictionary, initializing its sub-dicts. Returns: Type Description ContextDict A dictionary with aliases and macros defined as empty sub-dicts. Source code in pytermgui/markup/parsing.py 75 76 77 78 79 80 81 82 def create_context_dict () -> ContextDict : \"\"\"Creates a new context dictionary, initializing its sub-dicts. Returns: A dictionary with `aliases` and `macros` defined as empty sub-dicts. \"\"\" return { \"aliases\" : {}, \"macros\" : {}}","title":"create_context_dict()"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.eval_alias","text":"Evaluates a space-delimited string of alias tags into their underlying value. Parameters: Name Type Description Default text str A space-separated string containing the aliases. required Returns: Type Description str The space-separated string that the input aliases represent. Source code in pytermgui/markup/parsing.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 def eval_alias ( text : str , context : ContextDict ) -> str : \"\"\"Evaluates a space-delimited string of alias tags into their underlying value. Args: text: A space-separated string containing the aliases. Returns: The space-separated string that the input aliases represent. \"\"\" aliases = context [ \"aliases\" ] evaluated = \"\" for tag in text . split (): if tag not in aliases : evaluated += tag + \" \" continue evaluated += eval_alias ( aliases [ tag ], context ) + \" \" return evaluated . rstrip ( \" \" )","title":"eval_alias()"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.get_markup","text":"Gets the markup representing an ANSI-coded string. Source code in pytermgui/markup/parsing.py 527 528 529 530 def get_markup ( text : str ) -> str : \"\"\"Gets the markup representing an ANSI-coded string.\"\"\" return tokens_to_markup ( list ( tokenize_ansi ( text )))","title":"get_markup()"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.optimize_markup","text":"Optimizes markup by tokenizing it, optimizing the tokens and converting it back to markup. Source code in pytermgui/markup/parsing.py 533 534 535 536 def optimize_markup ( markup : str ) -> str : \"\"\"Optimizes markup by tokenizing it, optimizing the tokens and converting it back to markup.\"\"\" return tokens_to_markup ( list ( optimize_tokens ( list ( tokenize_markup ( markup )))))","title":"optimize_markup()"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.optimize_tokens","text":"Optimizes a stream of tokens, only yielding functionally relevant ones. Parameters: Name Type Description Default tokens list [ Token ] Any list of Token objects. Usually obtained from tokenize_markup or tokenize_ansi . required Yields: Type Description Iterator [ Token ] All those tokens within the input iterator that are functionally relevant, keeping their order. Source code in pytermgui/markup/parsing.py 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 def optimize_tokens ( tokens : list [ Token ]) -> Iterator [ Token ]: \"\"\"Optimizes a stream of tokens, only yielding functionally relevant ones. Args: tokens: Any list of Token objects. Usually obtained from `tokenize_markup` or `tokenize_ansi`. Yields: All those tokens within the input iterator that are functionally relevant, keeping their order. \"\"\" previous : list [ Token ] = [] current_tag_group : list [ Token ] = [] def _diff_previous () -> Iterator [ Token ]: \"\"\"Find difference from the previously active list of tokens.\"\"\" applied = previous . copy () for tkn in current_tag_group : targets = [] clearer = Token . is_clear ( tkn ) if Token . is_clear ( tkn ): targets = [ tkn . targets ( tag ) for tag in applied ] if tkn in previous and not clearer : continue if clearer and not any ( targets ): continue applied . append ( tkn ) yield tkn def _remove_redundant_color ( token : Token ) -> None : \"\"\"Removes non-functional colors. These happen in the following ways: - Multiple colors of the same channel (fg/bg) are present. - A color is applied, then a clearer clears it. \"\"\" for applied in current_tag_group . copy (): if Token . is_clear ( applied ) and applied . targets ( token ): current_tag_group . remove ( applied ) if not Token . is_color ( applied ): continue old = applied . color if old . background == new . background : current_tag_group . remove ( applied ) for token in tokens : if Token . is_plain ( token ): yield from _diff_previous () yield token previous = current_tag_group . copy () continue if Token . is_color ( token ): new = token . color _remove_redundant_color ( token ) if not any ( token . markup == applied . markup for applied in current_tag_group ): current_tag_group . append ( token ) continue if token . is_style (): if not any ( token == tag for tag in current_tag_group ): current_tag_group . append ( token ) continue if Token . is_clear ( token ): applied = False for tag in current_tag_group . copy (): if token . targets ( tag ) or token == tag : current_tag_group . remove ( tag ) applied = True if not applied : continue current_tag_group . append ( token ) yield from _diff_previous ()","title":"optimize_tokens()"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.parse","text":"Parses markup into the ANSI-coded string it represents. Parameters: Name Type Description Default text str Any valid markup. required optimize bool If set, optimize_tokens will optimize the tokens found within the input markup before usage. This will incur a (minor) performance hit. False context ContextDict | None The context that aliases and macros found within the markup will be searched in. None append_reset bool If set, [/] will be appended to the token iterator, clearing all styles. True ignore_unknown_tags bool If set, the MarkupSyntaxError coming from unknown tags will be silenced. True Returns: Type Description str The ANSI-coded string that the markup represents. Source code in pytermgui/markup/parsing.py 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 def parse ( text : str , optimize : bool = False , context : ContextDict | None = None , append_reset : bool = True , ignore_unknown_tags : bool = True , ) -> str : \"\"\"Parses markup into the ANSI-coded string it represents. Args: text: Any valid markup. optimize: If set, `optimize_tokens` will optimize the tokens found within the input markup before usage. This will incur a (minor) performance hit. context: The context that aliases and macros found within the markup will be searched in. append_reset: If set, `[/]` will be appended to the token iterator, clearing all styles. ignore_unknown_tags: If set, the `MarkupSyntaxError` coming from unknown tags will be silenced. Returns: The ANSI-coded string that the markup represents. \"\"\" if context is None : context = create_context_dict () if append_reset and not text . endswith ( \"/]\" ): text += \"[/]\" tokens = list ( tokenize_markup ( text )) return parse_tokens ( tokens , optimize = optimize , context = context , append_reset = append_reset , ignore_unknown_tags = ignore_unknown_tags , )","title":"parse()"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.parse_alias","text":"Parses an alias token. Source code in pytermgui/markup/parsing.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 def parse_alias ( token : AliasToken , context : ContextDict , get_full : Callable [[], str ] ) -> str : \"\"\"Parses an alias token.\"\"\" if token . value not in context [ \"aliases\" ]: dump = json . dumps ( context [ \"aliases\" ], indent = 2 , default = str ) raise MarkupSyntaxError ( token . value , f \"not defined in alias context: { dump } \" , get_full () ) meaning = context [ \"aliases\" ][ token . value ] return eval_alias ( meaning , context ) . rstrip ( \" \" )","title":"parse_alias()"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.parse_clear","text":"Parses a clearer token. Source code in pytermgui/markup/parsing.py 380 381 382 383 384 385 386 387 388 389 def parse_clear ( token : ClearToken , _ : ContextDict , get_full : Callable [[], str ]) -> str : \"\"\"Parses a clearer token.\"\"\" index = CLEARERS . get ( token . value ) if index is None : raise MarkupSyntaxError ( token . value , \"not a recognized clearer or alias\" , get_full () ) return f \" \\x1b [ { index } m\"","title":"parse_clear()"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.parse_color","text":"Parses a color token. Source code in pytermgui/markup/parsing.py 327 328 329 330 def parse_color ( token : ColorToken , _ : ContextDict , __ : Callable [[], str ]) -> str : \"\"\"Parses a color token.\"\"\" return token . color . get_localized () . sequence","title":"parse_color()"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.parse_cursor","text":"Parses a cursor token. Source code in pytermgui/markup/parsing.py 392 393 394 395 396 397 def parse_cursor ( token : CursorToken , _ : ContextDict , __ : Callable [[], str ]) -> str : \"\"\"Parses a cursor token.\"\"\" ypos , xpos = map ( lambda i : \"\" if i is None else i , token ) return f \" \\x1b [ { ypos } ; { xpos } H\"","title":"parse_cursor()"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.parse_macro","text":"Parses a macro token. Returns: Type Description MacroType A tuple containing the callable bound to the name, as well as the arguments tuple [ str , ...] passed to it. Source code in pytermgui/markup/parsing.py 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def parse_macro ( token : MacroToken , context : ContextDict , get_full : Callable [[], str ] ) -> tuple [ MacroType , tuple [ str , ... ]]: \"\"\"Parses a macro token. Returns: A tuple containing the callable bound to the name, as well as the arguments passed to it. \"\"\" func = context [ \"macros\" ] . get ( token . value ) if func is None : dump = json . dumps ( context [ \"macros\" ], indent = 2 , default = str ) raise MarkupSyntaxError ( token . value , f \"not defined in macro context: { dump } \" , get_full () ) return func , token . arguments","title":"parse_macro()"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.parse_plain","text":"Parses a plain token. Source code in pytermgui/markup/parsing.py 321 322 323 324 def parse_plain ( token : PlainToken , _ : ContextDict , __ : Callable [[], str ]) -> str : \"\"\"Parses a plain token.\"\"\" return token . value","title":"parse_plain()"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.parse_style","text":"Parses a style token. Source code in pytermgui/markup/parsing.py 333 334 335 336 337 338 def parse_style ( token : StyleToken , _ : ContextDict , __ : Callable [[], str ]) -> str : \"\"\"Parses a style token.\"\"\" index = STYLES [ token . value ] return f \" \\x1b [ { index } m\"","title":"parse_style()"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.parse_tokens","text":"Parses a stream of tokens into the ANSI-coded string they represent. Parameters: Name Type Description Default tokens list [ Token ] Any list of Tokens, usually obtained from either tokenize_ansi or tokenize_markup . required optimize bool If set, optimize_tokens will optimize the input iterator before usage. This will incur a (minor) performance hit. False context ContextDict | None The context that aliases and macros found within the tokens will be searched in. None append_reset bool If set, ClearToken(\"/\") will be appended to the token iterator, clearing all styles. True ignore_unknown_tags bool If set, the MarkupSyntaxError coming from unknown tags will be silenced. True Returns: Type Description str The ANSI-coded string that the token stream represents. Source code in pytermgui/markup/parsing.py 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 def parse_tokens ( # pylint: disable=too-many-branches, too-many-locals, too-many-statements tokens : list [ Token ], * , optimize : bool = False , context : ContextDict | None = None , append_reset : bool = True , ignore_unknown_tags : bool = True , ) -> str : \"\"\"Parses a stream of tokens into the ANSI-coded string they represent. Args: tokens: Any list of Tokens, usually obtained from either `tokenize_ansi` or `tokenize_markup`. optimize: If set, `optimize_tokens` will optimize the input iterator before usage. This will incur a (minor) performance hit. context: The context that aliases and macros found within the tokens will be searched in. append_reset: If set, `ClearToken(\"/\")` will be appended to the token iterator, clearing all styles. ignore_unknown_tags: If set, the `MarkupSyntaxError` coming from unknown tags will be silenced. Returns: The ANSI-coded string that the token stream represents. \"\"\" if context is None : context = create_context_dict () token_list = _sub_aliases ( tokens , context ) # It's more computationally efficient to create this lambda once and reuse it # every time. There is no need to define a full function, as it just returns # a function return. get_full = ( lambda : tokens_to_markup ( # pylint: disable=unnecessary-lambda-assignment token_list ) ) if optimize : token_list = list ( optimize_tokens ( token_list )) if append_reset : token_list . append ( ClearToken ( \"/\" )) link = None output = \"\" segment = \"\" background = Color . parse ( \"#000000\" ) macros : list [ MacroToken ] = [] unknown_aliases : list [ Token ] = [] for token in token_list : if token . is_plain (): value = _apply_macros ( token . value , ( parse_macro ( macro , context , get_full ) for macro in macros ) ) if len ( unknown_aliases ) > 0 : output += f \"[ { ' ' . join ( tkn . value for tkn in unknown_aliases ) } ]\" unknown_aliases = [] output += segment + ( value if link is None else LINK_TEMPLATE . format ( uri = link , label = value ) ) segment = \"\" continue if token . is_hyperlink (): link = token . value continue if Token . is_macro ( token ): macros . append ( token ) continue if Token . is_clear ( token ): if token . value in ( \"/\" , \"/~\" ): link = None found = False for macro in macros . copy (): if token . targets ( macro ): macros . remove ( macro ) found = True break if found and token . value != \"/\" : continue if token . value . startswith ( \"/!\" ): raise MarkupSyntaxError ( token . value , \"has nothing to target\" , get_full () ) if Token . is_color ( token ) and token . color . background : background = token . color if Token . is_pseudo ( token ): if token . value == \"#auto\" : token = ColorToken ( \"#auto\" , background . contrast ) try : segment += PARSERS [ type ( token )]( token , context , get_full ) # type: ignore except MarkupSyntaxError : if not ignore_unknown_tags : raise unknown_aliases . append ( token ) if len ( unknown_aliases ) > 0 : output += f \"[ { ' ' . join ( tkn . value for tkn in unknown_aliases ) } ]\" output += segment return output","title":"parse_tokens()"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.tokenize_ansi","text":"Converts some ANSI-coded text into a stream of tokens. Parameters: Name Type Description Default text str Any valid ANSI-coded text. required Yields: Type Description Iterator [ Token ] The generated tokens, in the order they occur within the text. Source code in pytermgui/markup/parsing.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def tokenize_ansi ( # pylint: disable=too-many-locals, too-many-branches, too-many-statements text : str , ) -> Iterator [ Token ]: \"\"\"Converts some ANSI-coded text into a stream of tokens. Args: text: Any valid ANSI-coded text. Yields: The generated tokens, in the order they occur within the text. \"\"\" cursor = 0 for matchobj in RE_ANSI . finditer ( text ): start , end = matchobj . span () csi = matchobj . groups ()[ 0 : 2 ] link_osc = matchobj . groups ()[ 2 : 4 ] if link_osc != ( None , None ): cursor = end uri , label = link_osc yield HLinkToken ( uri ) yield PlainToken ( label ) continue full , content = csi if cursor < start : yield PlainToken ( text [ cursor : start ]) cursor = end code = \"\" # Position posmatch = RE_POSITION . match ( full ) if posmatch is not None : ypos , xpos = posmatch . groups () if not ypos and not xpos : raise ValueError ( f \"Cannot parse cursor when no position is supplied. Match: { posmatch !r} \" ) yield CursorToken ( content , int ( ypos ) or None , int ( xpos ) or None ) continue parts = content . split ( \";\" ) state = None color_code = \"\" for part in parts : if state is None : if part in REVERSE_STYLES : yield StyleToken ( REVERSE_STYLES [ part ]) continue if part in REVERSE_CLEARERS : yield ClearToken ( REVERSE_CLEARERS [ part ]) continue if part in ( \"38\" , \"48\" ): state = \"COLOR\" color_code += part + \";\" continue # standard colors try : yield ColorToken ( part , Color . parse ( part , localize = False )) continue except ColorSyntaxError as exc : raise ValueError ( f \"Could not parse color tag { part !r} .\" ) from exc if state != \"COLOR\" : continue color_code += part + \";\" # Ignore incomplete RGB colors if ( color_code . startswith (( \"38;2;\" , \"48;2;\" )) and len ( color_code . split ( \";\" )) != 6 ): continue try : code = color_code if code . startswith (( \"38;2;\" , \"48;2;\" , \"38;5;\" , \"48;5;\" )): stripped = code [ 5 : - 1 ] if code . startswith ( \"4\" ): stripped = \"@\" + stripped code = stripped yield ColorToken ( code , Color . parse ( code , localize = False )) except ColorSyntaxError : continue state = None color_code = \"\" remaining = text [ cursor :] if len ( remaining ) > 0 : yield PlainToken ( remaining )","title":"tokenize_ansi()"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.tokenize_markup","text":"Converts some markup text into a stream of tokens. Parameters: Name Type Description Default text str Any valid markup. required Yields: Type Description Iterator [ Token ] The generated tokens, in the order they occur within the markup. Source code in pytermgui/markup/parsing.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def tokenize_markup ( text : str ) -> Iterator [ Token ]: \"\"\"Converts some markup text into a stream of tokens. Args: text: Any valid markup. Yields: The generated tokens, in the order they occur within the markup. \"\"\" cursor = 0 length = len ( text ) has_inverse = False for matchobj in RE_MARKUP . finditer ( text ): full , escapes , content = matchobj . groups () start , end = matchobj . span () if cursor < start : yield PlainToken ( text [ cursor : start ]) if not escapes == \"\" : _ , remaining = divmod ( len ( escapes ), 2 ) yield PlainToken ( full [ max ( 1 - remaining , 1 ) :]) cursor = end continue for tag in content . split (): if tag == \"inverse\" : has_inverse = True if tag == \"/inverse\" : has_inverse = False consumed = consume_tag ( tag ) if has_inverse : if consumed . markup == \"/fg\" : consumed = ClearToken ( \"/fg\" ) elif consumed . markup == \"/bg\" : consumed = ClearToken ( \"/bg\" ) yield consumed cursor = end if cursor < length : yield PlainToken ( text [ cursor : length ])","title":"tokenize_markup()"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.tokens_to_markup","text":"Converts a token stream into the markup of its tokens. Parameters: Name Type Description Default tokens list [ Token ] Any list of Token objects. Usually obtained from tokenize_markup or tokenize_ansi . required Returns: Type Description str The markup the given tokens represent. Source code in pytermgui/markup/parsing.py 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 def tokens_to_markup ( tokens : list [ Token ]) -> str : \"\"\"Converts a token stream into the markup of its tokens. Args: tokens: Any list of Token objects. Usually obtained from `tokenize_markup` or `tokenize_ansi`. Returns: The markup the given tokens represent. \"\"\" tags : list [ Token ] = [] markup = \"\" for token in tokens : if token . is_plain (): if len ( tags ) > 0 : markup += f \"[ { ' ' . join ( tag . markup for tag in tags ) } ]\" markup += token . value tags = [] else : tags . append ( token ) if len ( tags ) > 0 : markup += f \"[ { ' ' . join ( tag . markup for tag in tags ) } ]\" return markup","title":"tokens_to_markup()"},{"location":"reference/pytermgui/markup/tokens/","text":"The building blocks of the TIM language, Use pytermgui.markup.parsing.tokenize_markup and pytermgui.markup.parsing.tokenize_ansi to generate. AliasToken dataclass Bases: Token A way to reference a set of tags from one central name. Source code in pytermgui/markup/tokens.py 260 261 262 263 264 265 266 @dataclass ( frozen = True , repr = False ) class AliasToken ( Token ): \"\"\"A way to reference a set of tags from one central name.\"\"\" __slots__ = ( \"value\" ,) value : str ClearToken dataclass Bases: Token A tag-clearer. These tokens are prefixed by / , and followed by the name of the tag they target. To reset color information in the current text, use the /fg and /bg special tags. We cannot unset a specific color due to how the terminal works; all these do is \"reset\" the current stroke color to the default of the terminal. Additionally, there are some other special identifiers: / : Clears all tags, including styles, colors, macros, links and more. /! : Clears all currently applied macros. /~ : Clears all currently applied links. Source code in pytermgui/markup/tokens.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 @dataclass ( frozen = True , repr = False ) class ClearToken ( Token ): \"\"\"A tag-clearer. These tokens are prefixed by `/`, and followed by the name of the tag they target. To reset color information in the current text, use the `/fg` and `/bg` special tags. We cannot unset a specific color due to how the terminal works; all these do is \"reset\" the current stroke color to the default of the terminal. Additionally, there are some other special identifiers: - `/`: Clears all tags, including styles, colors, macros, links and more. - `/!`: Clears all currently applied macros. - `/~`: Clears all currently applied links. \"\"\" __slots__ = ( \"value\" ,) value : str @cached_property def prettified_markup ( self ) -> str : target = self . markup [ 1 :] return f \"[210 strikethrough]/[/fg] { target } [/]\" def __eq__ ( self , other : object ) -> bool : if not isinstance ( other , Token ): return False return super () . __eq__ ( other ) or all ( obj . markup in [ \"/dim\" , \"/bold\" ] for obj in [ self , other ] ) def targets ( # pylint: disable=too-many-return-statements self , token : Token ) -> bool : \"\"\"Returns True if this token targets the one given as an argument.\"\"\" if token . is_clear () or token . is_cursor (): return False if self . value in ( \"/\" , f \"/ { token . value } \" ): return True if token . is_hyperlink () and self . value == \"/~\" : return True if token . is_macro () and self . value == \"/!\" : return True if not Token . is_color ( token ): return False if self . value == \"/fg\" and not token . color . background : return True return self . value == \"/bg\" and token . color . background targets ( token ) Returns True if this token targets the one given as an argument. Source code in pytermgui/markup/tokens.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def targets ( # pylint: disable=too-many-return-statements self , token : Token ) -> bool : \"\"\"Returns True if this token targets the one given as an argument.\"\"\" if token . is_clear () or token . is_cursor (): return False if self . value in ( \"/\" , f \"/ { token . value } \" ): return True if token . is_hyperlink () and self . value == \"/~\" : return True if token . is_macro () and self . value == \"/!\" : return True if not Token . is_color ( token ): return False if self . value == \"/fg\" and not token . color . background : return True return self . value == \"/bg\" and token . color . background ColorToken dataclass Bases: Token A color identifier. It stores the markup that created it, as well as the pytermgui.colors.Color object that it represents. Source code in pytermgui/markup/tokens.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 @dataclass ( frozen = True , repr = False ) class ColorToken ( Token ): \"\"\"A color identifier. It stores the markup that created it, as well as the `pytermgui.colors.Color` object that it represents. \"\"\" __slots__ = ( \"value\" ,) value : str color : Color @cached_property def markup ( self ) -> str : return self . color . markup @cached_property def prettified_markup ( self ) -> str : clearer = \"bg\" if self . color . background else \"fg\" return f \"[ { self . markup } ] { self . markup } [/ { clearer } ]\" CursorToken dataclass Bases: Token A cursor location. These can be used to move the terminal's cursor. Source code in pytermgui/markup/tokens.py 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 @dataclass ( frozen = True , repr = False ) class CursorToken ( Token ): \"\"\"A cursor location. These can be used to move the terminal's cursor. \"\"\" __slots__ = ( \"value\" , \"y\" , \"x\" ) value : str y : int | None x : int | None def __iter__ ( self ) -> Iterator [ int | None ]: return iter (( self . y , self . x )) def __repr__ ( self ) -> str : return f \"< { type ( self ) . __name__ } position: { ( ';' . join ( map ( str , self ))) } >\" def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: yield self . __repr__ () @cached_property def markup ( self ) -> str : return f \"( { self . value } )\" HLinkToken dataclass Bases: Token A terminal hyperlink. See https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda. Source code in pytermgui/markup/tokens.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 @dataclass ( frozen = True , repr = False ) class HLinkToken ( Token ): \"\"\"A terminal hyperlink. See https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda. \"\"\" __slots__ = ( \"value\" ,) value : str @cached_property def markup ( self ) -> str : return f \"~ { self . value } \" @cached_property def prettified_markup ( self ) -> str : return f \"[ { self . markup } ]~[blue underline] { self . value } [/fg /underline /~]\" MacroToken dataclass Bases: Token A binding of a Python function to a markup name. See the docs on information about syntax & semantics. Source code in pytermgui/markup/tokens.py 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 @dataclass ( frozen = True , repr = False ) class MacroToken ( Token ): \"\"\"A binding of a Python function to a markup name. See the docs on information about syntax & semantics. \"\"\" __slots__ = ( \"value\" , \"arguments\" ) value : str arguments : tuple [ str , ... ] def __iter__ ( self ) -> Iterator [ Any ]: return iter (( self . value , self . arguments )) @cached_property def prettified_markup ( self ) -> str : target = self . markup [ 1 :] return f \"[210 bold]![/] { target } \" @cached_property def markup ( self ) -> str : return f \" { self . value } \" + ( f \"( { ':' . join ( self . arguments ) } )\" if len ( self . arguments ) > 0 else \"\" ) PlainToken dataclass Bases: Token A plain piece of text. These are the parts of data in-between markup tag groups. Source code in pytermgui/markup/tokens.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 @dataclass ( frozen = True , repr = False ) class PlainToken ( Token ): \"\"\"A plain piece of text. These are the parts of data in-between markup tag groups. \"\"\" __slots__ = ( \"value\" ,) value : str def __repr__ ( self ) -> str : return f \"< { type ( self ) . __name__ } markup: { self . markup !r} >\" def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: yield f \"< { type ( self ) . __name__ } markup: { self . markup !r} >\" PseudoToken dataclass Bases: Token A token that can modify it's context, but doesn't hold information of its own. Source code in pytermgui/markup/tokens.py 136 137 138 139 140 141 142 143 144 @dataclass ( frozen = True , repr = False ) class PseudoToken ( Token ): \"\"\"A token that can modify it's context, but doesn't hold information of its own.\"\"\" value : str @cached_property def prettified_markup ( self ) -> str : return f \"[245 italic] { self . markup } [/]\" StyleToken dataclass Bases: Token A terminal-style identifier. Most terminals support a set of 9 styles: bold dim italic underline blink blink2 inverse invisible strikethrough This token will store the style it represents by its name in the value field. Note that other, less widely supported styles may be available; for an up-to-date list, run ptg -i pytermgui.markup.style_maps.STYLES . ``` Source code in pytermgui/markup/tokens.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 @dataclass ( frozen = True , repr = False ) class StyleToken ( Token ): \"\"\"A terminal-style identifier. Most terminals support a set of 9 styles: - bold - dim - italic - underline - blink - blink2 - inverse - invisible - strikethrough This token will store the style it represents by its name in the `value` field. Note that other, less widely supported styles *may* be available; for an up-to-date list, run `ptg -i pytermgui.markup.style_maps.STYLES`. ``` \"\"\" __slots__ = ( \"value\" ,) value : str Token A piece of markup information. All tokens must have at least a value field, and have markup and prettified_markup properties derived from it in some manner. They are meant to be immutable (frozen), and generated by some tokenization. They are also static representations of the data in its pre-parsed form. Source code in pytermgui/markup/tokens.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 class Token : \"\"\"A piece of markup information. All tokens must have at least a `value` field, and have `markup` and `prettified_markup` properties derived from it in some manner. They are meant to be immutable (frozen), and generated by some tokenization. They are also static representations of the data in its pre-parsed form. \"\"\" value : str @cached_property def markup ( self ) -> str : \"\"\"Returns markup representing this token.\"\"\" return self . value @cached_property def prettified_markup ( self ) -> str : \"\"\"Returns syntax-highlighted markup representing this token.\"\"\" return f \"[ { self . markup } ] { self . markup } [/ { self . markup } ]\" def __eq__ ( self , other : object ) -> bool : return isinstance ( other , type ( self )) and other . value == self . value def __repr__ ( self ) -> str : return f \"< { type ( self ) . __name__ } markup: ' { self . markup } '>\" def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: yield f \"< { type ( self ) . __name__ } markup: \" yield { \"text\" : self . prettified_markup , \"highlight\" : False , } yield \">\" def is_plain ( self ) -> TypeGuard [ \"PlainToken\" ]: \"\"\"Returns True if this token is an instance of PlainToken.\"\"\" return isinstance ( self , PlainToken ) def is_pseudo ( self ) -> TypeGuard [ \"PseudoToken\" ]: \"\"\"Returns True if this token is an instance of PseudoToken.\"\"\" return isinstance ( self , PseudoToken ) def is_color ( self ) -> TypeGuard [ \"ColorToken\" ]: \"\"\"Returns True if this token is an instance of ColorToken.\"\"\" return isinstance ( self , ColorToken ) def is_style ( self ) -> TypeGuard [ \"StyleToken\" ]: \"\"\"Returns True if this token is an instance of StyleToken.\"\"\" return isinstance ( self , StyleToken ) def is_alias ( self ) -> TypeGuard [ \"AliasToken\" ]: \"\"\"Returns True if this token is an instance of AliasToken.\"\"\" return isinstance ( self , AliasToken ) def is_macro ( self ) -> TypeGuard [ \"MacroToken\" ]: \"\"\"Returns True if this token is an instance of MacroToken.\"\"\" return isinstance ( self , MacroToken ) def is_clear ( self ) -> TypeGuard [ \"ClearToken\" ]: \"\"\"Returns True if this token is an instance of ClearToken.\"\"\" return isinstance ( self , ClearToken ) def is_hyperlink ( self ) -> TypeGuard [ \"HLinkToken\" ]: \"\"\"Returns True if this token is an instance of HLinkToken.\"\"\" return isinstance ( self , HLinkToken ) def is_cursor ( self ) -> TypeGuard [ \"CursorToken\" ]: \"\"\"Returns True if this token is an instance of CursorToken.\"\"\" return isinstance ( self , CursorToken ) is_alias () Returns True if this token is an instance of AliasToken. Source code in pytermgui/markup/tokens.py 92 93 94 95 def is_alias ( self ) -> TypeGuard [ \"AliasToken\" ]: \"\"\"Returns True if this token is an instance of AliasToken.\"\"\" return isinstance ( self , AliasToken ) is_clear () Returns True if this token is an instance of ClearToken. Source code in pytermgui/markup/tokens.py 102 103 104 105 def is_clear ( self ) -> TypeGuard [ \"ClearToken\" ]: \"\"\"Returns True if this token is an instance of ClearToken.\"\"\" return isinstance ( self , ClearToken ) is_color () Returns True if this token is an instance of ColorToken. Source code in pytermgui/markup/tokens.py 82 83 84 85 def is_color ( self ) -> TypeGuard [ \"ColorToken\" ]: \"\"\"Returns True if this token is an instance of ColorToken.\"\"\" return isinstance ( self , ColorToken ) is_cursor () Returns True if this token is an instance of CursorToken. Source code in pytermgui/markup/tokens.py 112 113 114 115 def is_cursor ( self ) -> TypeGuard [ \"CursorToken\" ]: \"\"\"Returns True if this token is an instance of CursorToken.\"\"\" return isinstance ( self , CursorToken ) is_hyperlink () Returns True if this token is an instance of HLinkToken. Source code in pytermgui/markup/tokens.py 107 108 109 110 def is_hyperlink ( self ) -> TypeGuard [ \"HLinkToken\" ]: \"\"\"Returns True if this token is an instance of HLinkToken.\"\"\" return isinstance ( self , HLinkToken ) is_macro () Returns True if this token is an instance of MacroToken. Source code in pytermgui/markup/tokens.py 97 98 99 100 def is_macro ( self ) -> TypeGuard [ \"MacroToken\" ]: \"\"\"Returns True if this token is an instance of MacroToken.\"\"\" return isinstance ( self , MacroToken ) is_plain () Returns True if this token is an instance of PlainToken. Source code in pytermgui/markup/tokens.py 72 73 74 75 def is_plain ( self ) -> TypeGuard [ \"PlainToken\" ]: \"\"\"Returns True if this token is an instance of PlainToken.\"\"\" return isinstance ( self , PlainToken ) is_pseudo () Returns True if this token is an instance of PseudoToken. Source code in pytermgui/markup/tokens.py 77 78 79 80 def is_pseudo ( self ) -> TypeGuard [ \"PseudoToken\" ]: \"\"\"Returns True if this token is an instance of PseudoToken.\"\"\" return isinstance ( self , PseudoToken ) is_style () Returns True if this token is an instance of StyleToken. Source code in pytermgui/markup/tokens.py 87 88 89 90 def is_style ( self ) -> TypeGuard [ \"StyleToken\" ]: \"\"\"Returns True if this token is an instance of StyleToken.\"\"\" return isinstance ( self , StyleToken ) markup () property cached Returns markup representing this token. Source code in pytermgui/markup/tokens.py 46 47 48 49 50 @cached_property def markup ( self ) -> str : \"\"\"Returns markup representing this token.\"\"\" return self . value prettified_markup () property cached Returns syntax-highlighted markup representing this token. Source code in pytermgui/markup/tokens.py 52 53 54 55 56 @cached_property def prettified_markup ( self ) -> str : \"\"\"Returns syntax-highlighted markup representing this token.\"\"\" return f \"[ { self . markup } ] { self . markup } [/ { self . markup } ]\"","title":"tokens"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.AliasToken","text":"Bases: Token A way to reference a set of tags from one central name. Source code in pytermgui/markup/tokens.py 260 261 262 263 264 265 266 @dataclass ( frozen = True , repr = False ) class AliasToken ( Token ): \"\"\"A way to reference a set of tags from one central name.\"\"\" __slots__ = ( \"value\" ,) value : str","title":"AliasToken"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.ClearToken","text":"Bases: Token A tag-clearer. These tokens are prefixed by / , and followed by the name of the tag they target. To reset color information in the current text, use the /fg and /bg special tags. We cannot unset a specific color due to how the terminal works; all these do is \"reset\" the current stroke color to the default of the terminal. Additionally, there are some other special identifiers: / : Clears all tags, including styles, colors, macros, links and more. /! : Clears all currently applied macros. /~ : Clears all currently applied links. Source code in pytermgui/markup/tokens.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 @dataclass ( frozen = True , repr = False ) class ClearToken ( Token ): \"\"\"A tag-clearer. These tokens are prefixed by `/`, and followed by the name of the tag they target. To reset color information in the current text, use the `/fg` and `/bg` special tags. We cannot unset a specific color due to how the terminal works; all these do is \"reset\" the current stroke color to the default of the terminal. Additionally, there are some other special identifiers: - `/`: Clears all tags, including styles, colors, macros, links and more. - `/!`: Clears all currently applied macros. - `/~`: Clears all currently applied links. \"\"\" __slots__ = ( \"value\" ,) value : str @cached_property def prettified_markup ( self ) -> str : target = self . markup [ 1 :] return f \"[210 strikethrough]/[/fg] { target } [/]\" def __eq__ ( self , other : object ) -> bool : if not isinstance ( other , Token ): return False return super () . __eq__ ( other ) or all ( obj . markup in [ \"/dim\" , \"/bold\" ] for obj in [ self , other ] ) def targets ( # pylint: disable=too-many-return-statements self , token : Token ) -> bool : \"\"\"Returns True if this token targets the one given as an argument.\"\"\" if token . is_clear () or token . is_cursor (): return False if self . value in ( \"/\" , f \"/ { token . value } \" ): return True if token . is_hyperlink () and self . value == \"/~\" : return True if token . is_macro () and self . value == \"/!\" : return True if not Token . is_color ( token ): return False if self . value == \"/fg\" and not token . color . background : return True return self . value == \"/bg\" and token . color . background","title":"ClearToken"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.ClearToken.targets","text":"Returns True if this token targets the one given as an argument. Source code in pytermgui/markup/tokens.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def targets ( # pylint: disable=too-many-return-statements self , token : Token ) -> bool : \"\"\"Returns True if this token targets the one given as an argument.\"\"\" if token . is_clear () or token . is_cursor (): return False if self . value in ( \"/\" , f \"/ { token . value } \" ): return True if token . is_hyperlink () and self . value == \"/~\" : return True if token . is_macro () and self . value == \"/!\" : return True if not Token . is_color ( token ): return False if self . value == \"/fg\" and not token . color . background : return True return self . value == \"/bg\" and token . color . background","title":"targets()"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.ColorToken","text":"Bases: Token A color identifier. It stores the markup that created it, as well as the pytermgui.colors.Color object that it represents. Source code in pytermgui/markup/tokens.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 @dataclass ( frozen = True , repr = False ) class ColorToken ( Token ): \"\"\"A color identifier. It stores the markup that created it, as well as the `pytermgui.colors.Color` object that it represents. \"\"\" __slots__ = ( \"value\" ,) value : str color : Color @cached_property def markup ( self ) -> str : return self . color . markup @cached_property def prettified_markup ( self ) -> str : clearer = \"bg\" if self . color . background else \"fg\" return f \"[ { self . markup } ] { self . markup } [/ { clearer } ]\"","title":"ColorToken"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.CursorToken","text":"Bases: Token A cursor location. These can be used to move the terminal's cursor. Source code in pytermgui/markup/tokens.py 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 @dataclass ( frozen = True , repr = False ) class CursorToken ( Token ): \"\"\"A cursor location. These can be used to move the terminal's cursor. \"\"\" __slots__ = ( \"value\" , \"y\" , \"x\" ) value : str y : int | None x : int | None def __iter__ ( self ) -> Iterator [ int | None ]: return iter (( self . y , self . x )) def __repr__ ( self ) -> str : return f \"< { type ( self ) . __name__ } position: { ( ';' . join ( map ( str , self ))) } >\" def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: yield self . __repr__ () @cached_property def markup ( self ) -> str : return f \"( { self . value } )\"","title":"CursorToken"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.HLinkToken","text":"Bases: Token A terminal hyperlink. See https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda. Source code in pytermgui/markup/tokens.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 @dataclass ( frozen = True , repr = False ) class HLinkToken ( Token ): \"\"\"A terminal hyperlink. See https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda. \"\"\" __slots__ = ( \"value\" ,) value : str @cached_property def markup ( self ) -> str : return f \"~ { self . value } \" @cached_property def prettified_markup ( self ) -> str : return f \"[ { self . markup } ]~[blue underline] { self . value } [/fg /underline /~]\"","title":"HLinkToken"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.MacroToken","text":"Bases: Token A binding of a Python function to a markup name. See the docs on information about syntax & semantics. Source code in pytermgui/markup/tokens.py 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 @dataclass ( frozen = True , repr = False ) class MacroToken ( Token ): \"\"\"A binding of a Python function to a markup name. See the docs on information about syntax & semantics. \"\"\" __slots__ = ( \"value\" , \"arguments\" ) value : str arguments : tuple [ str , ... ] def __iter__ ( self ) -> Iterator [ Any ]: return iter (( self . value , self . arguments )) @cached_property def prettified_markup ( self ) -> str : target = self . markup [ 1 :] return f \"[210 bold]![/] { target } \" @cached_property def markup ( self ) -> str : return f \" { self . value } \" + ( f \"( { ':' . join ( self . arguments ) } )\" if len ( self . arguments ) > 0 else \"\" )","title":"MacroToken"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.PlainToken","text":"Bases: Token A plain piece of text. These are the parts of data in-between markup tag groups. Source code in pytermgui/markup/tokens.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 @dataclass ( frozen = True , repr = False ) class PlainToken ( Token ): \"\"\"A plain piece of text. These are the parts of data in-between markup tag groups. \"\"\" __slots__ = ( \"value\" ,) value : str def __repr__ ( self ) -> str : return f \"< { type ( self ) . __name__ } markup: { self . markup !r} >\" def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: yield f \"< { type ( self ) . __name__ } markup: { self . markup !r} >\"","title":"PlainToken"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.PseudoToken","text":"Bases: Token A token that can modify it's context, but doesn't hold information of its own. Source code in pytermgui/markup/tokens.py 136 137 138 139 140 141 142 143 144 @dataclass ( frozen = True , repr = False ) class PseudoToken ( Token ): \"\"\"A token that can modify it's context, but doesn't hold information of its own.\"\"\" value : str @cached_property def prettified_markup ( self ) -> str : return f \"[245 italic] { self . markup } [/]\"","title":"PseudoToken"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.StyleToken","text":"Bases: Token A terminal-style identifier. Most terminals support a set of 9 styles: bold dim italic underline blink blink2 inverse invisible strikethrough This token will store the style it represents by its name in the value field. Note that other, less widely supported styles may be available; for an up-to-date list, run ptg -i pytermgui.markup.style_maps.STYLES . ``` Source code in pytermgui/markup/tokens.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 @dataclass ( frozen = True , repr = False ) class StyleToken ( Token ): \"\"\"A terminal-style identifier. Most terminals support a set of 9 styles: - bold - dim - italic - underline - blink - blink2 - inverse - invisible - strikethrough This token will store the style it represents by its name in the `value` field. Note that other, less widely supported styles *may* be available; for an up-to-date list, run `ptg -i pytermgui.markup.style_maps.STYLES`. ``` \"\"\" __slots__ = ( \"value\" ,) value : str","title":"StyleToken"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token","text":"A piece of markup information. All tokens must have at least a value field, and have markup and prettified_markup properties derived from it in some manner. They are meant to be immutable (frozen), and generated by some tokenization. They are also static representations of the data in its pre-parsed form. Source code in pytermgui/markup/tokens.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 class Token : \"\"\"A piece of markup information. All tokens must have at least a `value` field, and have `markup` and `prettified_markup` properties derived from it in some manner. They are meant to be immutable (frozen), and generated by some tokenization. They are also static representations of the data in its pre-parsed form. \"\"\" value : str @cached_property def markup ( self ) -> str : \"\"\"Returns markup representing this token.\"\"\" return self . value @cached_property def prettified_markup ( self ) -> str : \"\"\"Returns syntax-highlighted markup representing this token.\"\"\" return f \"[ { self . markup } ] { self . markup } [/ { self . markup } ]\" def __eq__ ( self , other : object ) -> bool : return isinstance ( other , type ( self )) and other . value == self . value def __repr__ ( self ) -> str : return f \"< { type ( self ) . __name__ } markup: ' { self . markup } '>\" def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: yield f \"< { type ( self ) . __name__ } markup: \" yield { \"text\" : self . prettified_markup , \"highlight\" : False , } yield \">\" def is_plain ( self ) -> TypeGuard [ \"PlainToken\" ]: \"\"\"Returns True if this token is an instance of PlainToken.\"\"\" return isinstance ( self , PlainToken ) def is_pseudo ( self ) -> TypeGuard [ \"PseudoToken\" ]: \"\"\"Returns True if this token is an instance of PseudoToken.\"\"\" return isinstance ( self , PseudoToken ) def is_color ( self ) -> TypeGuard [ \"ColorToken\" ]: \"\"\"Returns True if this token is an instance of ColorToken.\"\"\" return isinstance ( self , ColorToken ) def is_style ( self ) -> TypeGuard [ \"StyleToken\" ]: \"\"\"Returns True if this token is an instance of StyleToken.\"\"\" return isinstance ( self , StyleToken ) def is_alias ( self ) -> TypeGuard [ \"AliasToken\" ]: \"\"\"Returns True if this token is an instance of AliasToken.\"\"\" return isinstance ( self , AliasToken ) def is_macro ( self ) -> TypeGuard [ \"MacroToken\" ]: \"\"\"Returns True if this token is an instance of MacroToken.\"\"\" return isinstance ( self , MacroToken ) def is_clear ( self ) -> TypeGuard [ \"ClearToken\" ]: \"\"\"Returns True if this token is an instance of ClearToken.\"\"\" return isinstance ( self , ClearToken ) def is_hyperlink ( self ) -> TypeGuard [ \"HLinkToken\" ]: \"\"\"Returns True if this token is an instance of HLinkToken.\"\"\" return isinstance ( self , HLinkToken ) def is_cursor ( self ) -> TypeGuard [ \"CursorToken\" ]: \"\"\"Returns True if this token is an instance of CursorToken.\"\"\" return isinstance ( self , CursorToken )","title":"Token"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token.is_alias","text":"Returns True if this token is an instance of AliasToken. Source code in pytermgui/markup/tokens.py 92 93 94 95 def is_alias ( self ) -> TypeGuard [ \"AliasToken\" ]: \"\"\"Returns True if this token is an instance of AliasToken.\"\"\" return isinstance ( self , AliasToken )","title":"is_alias()"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token.is_clear","text":"Returns True if this token is an instance of ClearToken. Source code in pytermgui/markup/tokens.py 102 103 104 105 def is_clear ( self ) -> TypeGuard [ \"ClearToken\" ]: \"\"\"Returns True if this token is an instance of ClearToken.\"\"\" return isinstance ( self , ClearToken )","title":"is_clear()"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token.is_color","text":"Returns True if this token is an instance of ColorToken. Source code in pytermgui/markup/tokens.py 82 83 84 85 def is_color ( self ) -> TypeGuard [ \"ColorToken\" ]: \"\"\"Returns True if this token is an instance of ColorToken.\"\"\" return isinstance ( self , ColorToken )","title":"is_color()"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token.is_cursor","text":"Returns True if this token is an instance of CursorToken. Source code in pytermgui/markup/tokens.py 112 113 114 115 def is_cursor ( self ) -> TypeGuard [ \"CursorToken\" ]: \"\"\"Returns True if this token is an instance of CursorToken.\"\"\" return isinstance ( self , CursorToken )","title":"is_cursor()"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token.is_hyperlink","text":"Returns True if this token is an instance of HLinkToken. Source code in pytermgui/markup/tokens.py 107 108 109 110 def is_hyperlink ( self ) -> TypeGuard [ \"HLinkToken\" ]: \"\"\"Returns True if this token is an instance of HLinkToken.\"\"\" return isinstance ( self , HLinkToken )","title":"is_hyperlink()"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token.is_macro","text":"Returns True if this token is an instance of MacroToken. Source code in pytermgui/markup/tokens.py 97 98 99 100 def is_macro ( self ) -> TypeGuard [ \"MacroToken\" ]: \"\"\"Returns True if this token is an instance of MacroToken.\"\"\" return isinstance ( self , MacroToken )","title":"is_macro()"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token.is_plain","text":"Returns True if this token is an instance of PlainToken. Source code in pytermgui/markup/tokens.py 72 73 74 75 def is_plain ( self ) -> TypeGuard [ \"PlainToken\" ]: \"\"\"Returns True if this token is an instance of PlainToken.\"\"\" return isinstance ( self , PlainToken )","title":"is_plain()"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token.is_pseudo","text":"Returns True if this token is an instance of PseudoToken. Source code in pytermgui/markup/tokens.py 77 78 79 80 def is_pseudo ( self ) -> TypeGuard [ \"PseudoToken\" ]: \"\"\"Returns True if this token is an instance of PseudoToken.\"\"\" return isinstance ( self , PseudoToken )","title":"is_pseudo()"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token.is_style","text":"Returns True if this token is an instance of StyleToken. Source code in pytermgui/markup/tokens.py 87 88 89 90 def is_style ( self ) -> TypeGuard [ \"StyleToken\" ]: \"\"\"Returns True if this token is an instance of StyleToken.\"\"\" return isinstance ( self , StyleToken )","title":"is_style()"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token.markup","text":"Returns markup representing this token. Source code in pytermgui/markup/tokens.py 46 47 48 49 50 @cached_property def markup ( self ) -> str : \"\"\"Returns markup representing this token.\"\"\" return self . value","title":"markup()"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token.prettified_markup","text":"Returns syntax-highlighted markup representing this token. Source code in pytermgui/markup/tokens.py 52 53 54 55 56 @cached_property def prettified_markup ( self ) -> str : \"\"\"Returns syntax-highlighted markup representing this token.\"\"\" return f \"[ { self . markup } ] { self . markup } [/ { self . markup } ]\"","title":"prettified_markup()"},{"location":"reference/pytermgui/widgets/","text":"The widget system.","title":"Index"},{"location":"reference/pytermgui/widgets/base/","text":"The basic building blocks making up the Widget system. Label Bases: Widget A Widget to display a string By default, this widget uses pytermgui.widgets.styles.MARKUP . This allows it to house markup text that is parsed before display, such as: print(\"hello world\") import pytermgui as ptg with ptg . alt_buffer (): root = ptg . Container ( ptg . Label ( \"[italic 141 bold]This is some [green]fancy [white inverse]text!\" ) ) root . print () ptg . getch () Source code in pytermgui/widgets/base.py 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 class Label ( Widget ): \"\"\"A Widget to display a string By default, this widget uses `pytermgui.widgets.styles.MARKUP`. This allows it to house markup text that is parsed before display, such as: ```termage-svg print(\"hello world\") ``` ```python3 import pytermgui as ptg with ptg.alt_buffer(): root = ptg.Container( ptg.Label(\"[italic 141 bold]This is some [green]fancy [white inverse]text!\") ) root.print() ptg.getch() ``` <p style=\"text-align: center\"> <img src=\"https://github.com/bczsalba/pytermgui/blob/master/assets/docs/widgets/label.png?raw=true\" width=100%> </p> \"\"\" serialized = Widget . serialized + [ \"*value\" , \"align\" , \"padding\" ] styles = w_styles . StyleManager ( value = \"\" ) def __init__ ( self , value : str = \"\" , style : str | w_styles . StyleValue = \"\" , padding : int = 0 , non_first_padding : int = 0 , ** attrs : Any , ) -> None : \"\"\"Initializes a Label. Args: value: The value of this string. Using the default value style (`pytermgui.widgets.styles.MARKUP`), style: A pre-set value for self.styles.value. padding: The number of space (\" \") characters to prepend to every line after line breaking. non_first_padding: The number of space characters to prepend to every non-first line of `get_lines`. This is applied on top of `padding`. \"\"\" super () . __init__ ( ** attrs ) self . value = value self . padding = padding self . non_first_padding = non_first_padding self . width = real_length ( value ) + self . padding if style != \"\" : self . styles . value = style def get_lines ( self ) -> list [ str ]: \"\"\"Get lines representing this Label, breaking lines as necessary\"\"\" lines = [] limit = self . width - self . padding broken = break_line ( self . styles . value ( self . value ), limit = limit , non_first_limit = limit - self . non_first_padding , ) for i , line in enumerate ( broken ): if i == 0 : lines . append ( self . padding * \" \" + line ) continue lines . append ( self . padding * \" \" + self . non_first_padding * \" \" + line ) return lines or [ \"\" ] __init__ ( value = '' , style = '' , padding = 0 , non_first_padding = 0 , attrs ) Initializes a Label. Parameters: Name Type Description Default value str The value of this string. Using the default value style ( pytermgui.widgets.styles.MARKUP ), '' style str | w_styles . StyleValue A pre-set value for self.styles.value. '' padding int The number of space (\" \") characters to prepend to every line after line breaking. 0 non_first_padding int The number of space characters to prepend to every non-first line of get_lines . This is applied on top of padding . 0 Source code in pytermgui/widgets/base.py 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 def __init__ ( self , value : str = \"\" , style : str | w_styles . StyleValue = \"\" , padding : int = 0 , non_first_padding : int = 0 , ** attrs : Any , ) -> None : \"\"\"Initializes a Label. Args: value: The value of this string. Using the default value style (`pytermgui.widgets.styles.MARKUP`), style: A pre-set value for self.styles.value. padding: The number of space (\" \") characters to prepend to every line after line breaking. non_first_padding: The number of space characters to prepend to every non-first line of `get_lines`. This is applied on top of `padding`. \"\"\" super () . __init__ ( ** attrs ) self . value = value self . padding = padding self . non_first_padding = non_first_padding self . width = real_length ( value ) + self . padding if style != \"\" : self . styles . value = style get_lines () Get lines representing this Label, breaking lines as necessary Source code in pytermgui/widgets/base.py 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 def get_lines ( self ) -> list [ str ]: \"\"\"Get lines representing this Label, breaking lines as necessary\"\"\" lines = [] limit = self . width - self . padding broken = break_line ( self . styles . value ( self . value ), limit = limit , non_first_limit = limit - self . non_first_padding , ) for i , line in enumerate ( broken ): if i == 0 : lines . append ( self . padding * \" \" + line ) continue lines . append ( self . padding * \" \" + self . non_first_padding * \" \" + line ) return lines or [ \"\" ] ScrollableWidget Bases: Widget A widget with some scrolling helper methods. This is not an implementation of the scrolling behaviour itself, just the user-facing API for it. It provides a _scroll_offset attribute, which is an integer describing the current scroll state offset from the top, as well as some methods to modify the state. Source code in pytermgui/widgets/base.py 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 class ScrollableWidget ( Widget ): \"\"\"A widget with some scrolling helper methods. This is not an implementation of the scrolling behaviour itself, just the user-facing API for it. It provides a `_scroll_offset` attribute, which is an integer describing the current scroll state offset from the top, as well as some methods to modify the state.\"\"\" def __init__ ( self , ** attrs : Any ) -> None : \"\"\"Initializes the scrollable widget.\"\"\" super () . __init__ ( ** attrs ) self . _max_scroll = 0 self . _scroll_offset = 0 def scroll ( self , offset : int ) -> bool : \"\"\"Scrolls to given offset, returns the new scroll_offset. Args: offset: The amount to scroll by. Positive offsets scroll down, negative up. Returns: True if the scroll offset changed, False otherwise. \"\"\" base = self . _scroll_offset self . _scroll_offset = min ( max ( 0 , self . _scroll_offset + offset ), self . _max_scroll ) return base != self . _scroll_offset def scroll_end ( self , end : int ) -> int : \"\"\"Scrolls to either top or bottom end of this object. Args: end: The offset to scroll to. 0 goes to the very top, -1 to the very bottom. Returns: True if the scroll offset changed, False otherwise. \"\"\" base = self . _scroll_offset if end == 0 : self . _scroll_offset = 0 elif end == - 1 : self . _scroll_offset = self . _max_scroll return base != self . _scroll_offset def get_lines ( self ) -> list [ str ]: ... __init__ ( attrs ) Initializes the scrollable widget. Source code in pytermgui/widgets/base.py 770 771 772 773 774 775 776 def __init__ ( self , ** attrs : Any ) -> None : \"\"\"Initializes the scrollable widget.\"\"\" super () . __init__ ( ** attrs ) self . _max_scroll = 0 self . _scroll_offset = 0 scroll ( offset ) Scrolls to given offset, returns the new scroll_offset. Parameters: Name Type Description Default offset int The amount to scroll by. Positive offsets scroll down, negative up. required Returns: Type Description bool True if the scroll offset changed, False otherwise. Source code in pytermgui/widgets/base.py 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 def scroll ( self , offset : int ) -> bool : \"\"\"Scrolls to given offset, returns the new scroll_offset. Args: offset: The amount to scroll by. Positive offsets scroll down, negative up. Returns: True if the scroll offset changed, False otherwise. \"\"\" base = self . _scroll_offset self . _scroll_offset = min ( max ( 0 , self . _scroll_offset + offset ), self . _max_scroll ) return base != self . _scroll_offset scroll_end ( end ) Scrolls to either top or bottom end of this object. Parameters: Name Type Description Default end int The offset to scroll to. 0 goes to the very top, -1 to the very bottom. required Returns: Type Description int True if the scroll offset changed, False otherwise. Source code in pytermgui/widgets/base.py 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 def scroll_end ( self , end : int ) -> int : \"\"\"Scrolls to either top or bottom end of this object. Args: end: The offset to scroll to. 0 goes to the very top, -1 to the very bottom. Returns: True if the scroll offset changed, False otherwise. \"\"\" base = self . _scroll_offset if end == 0 : self . _scroll_offset = 0 elif end == - 1 : self . _scroll_offset = self . _max_scroll return base != self . _scroll_offset Widget The base of the Widget system Source code in pytermgui/widgets/base.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 class Widget : # pylint: disable=too-many-public-methods \"\"\"The base of the Widget system\"\"\" set_style = classmethod ( _set_obj_or_cls_style ) set_char = classmethod ( _set_obj_or_cls_char ) styles = w_styles . StyleManager () \"\"\"Default styles for this class\"\"\" chars : dict [ str , w_styles . CharType ] = {} \"\"\"Default characters for this class\"\"\" keys : dict [ str , set [ str ]] = {} \"\"\"Groups of keys that are used in `handle_key`\"\"\" serialized : list [ str ] = [ \"id\" , \"pos\" , \"depth\" , \"width\" , \"height\" , \"selected_index\" , \"selectables_length\" , ] \"\"\"Fields of widget that shall be serialized by `pytermgui.serializer.Serializer`\"\"\" # This class is loaded after this module, # and thus mypy doesn't see its existence. _id_manager : Optional [ \"_IDManager\" ] = None # type: ignore size_policy = SizePolicy . get_default () \"\"\"`pytermgui.enums.SizePolicy` to set widget's width according to\"\"\" parent_align = HorizontalAlignment . get_default () \"\"\"`pytermgui.enums.HorizontalAlignment` to align widget by\"\"\" from_data : Callable [ ... , Widget | list [ Widget ] | None ] # We cannot import boxes here due to cyclic imports. box : Any def __init__ ( self , ** attrs : Any ) -> None : \"\"\"Initialize object\"\"\" self . set_style = lambda key , value : _set_obj_or_cls_style ( self , key , value ) self . set_char = lambda key , value : _set_obj_or_cls_char ( self , key , value ) self . width = 1 self . height = 1 self . pos = self . terminal . origin self . depth = 0 self . styles = type ( self ) . styles . branch ( self ) self . chars = type ( self ) . chars . copy () self . parent : Widget | None = None self . selected_index : int | None = None self . _selectables_length = 0 self . _id : Optional [ str ] = None self . _serialized_fields = type ( self ) . serialized self . _bindings : dict [ str | Type [ MouseEvent ], tuple [ BoundCallback , str ]] = {} self . _relative_width : float | None = None self . _previous_state : tuple [ tuple [ int , int ], list [ str ]] | None = None self . positioned_line_buffer : list [ tuple [ tuple [ int , int ], str ]] = [] for attr , value in attrs . items (): setattr ( self , attr , value ) def __repr__ ( self ) -> str : \"\"\"Return repr string of this widget. Returns: Whatever this widget's `debug` method gives. \"\"\" return self . debug () def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Yields the repr of this object, then a preview of it.\"\"\" yield self . debug () yield \" \\n\\n \" yield { \"text\" : \" \\n \" . join (( line + reset () for line in self . get_lines ())), \"highlight\" : False , } def __iter__ ( self ) -> Iterator [ Widget ]: \"\"\"Return self for iteration\"\"\" yield self @property def bindings ( self ) -> dict [ str | Type [ MouseEvent ], tuple [ BoundCallback , str ]]: \"\"\"Gets a copy of the bindings internal dictionary. Returns: A copy of the internal bindings dictionary, such as: ``` { \"*\": (star_callback, \"This is a callback activated when '*' is pressed.\") } ``` \"\"\" return self . _bindings . copy () @property def id ( self ) -> Optional [ str ]: # pylint: disable=invalid-name \"\"\"Gets this widget's id property Returns: The id string if one is present, None otherwise. \"\"\" return self . _id @id . setter def id ( self , value : str ) -> None : # pylint: disable=invalid-name \"\"\"Registers a widget to the Widget._id_manager. If this widget already had an id, the old value is deregistered before the new one is assigned. Args: value: The new id this widget will be registered as. \"\"\" if self . _id == value : return manager = Widget . _id_manager assert manager is not None old = manager . get_id ( self ) if old is not None : manager . deregister ( old ) self . _id = value manager . register ( self ) @property def selectables_length ( self ) -> int : \"\"\"Gets how many selectables this widget contains. Returns: An integer describing the amount of selectables in this widget. \"\"\" return self . _selectables_length @property def selectables ( self ) -> list [ tuple [ Widget , int ]]: \"\"\"Gets a list of all selectables within this widget Returns: A list of tuples. In the default implementation this will be a list of one tuple, containing a reference to `self`, as well as the lowest index, 0. \"\"\" return [( self , 0 )] @property def is_selectable ( self ) -> bool : \"\"\"Determines whether this widget has any selectables. Returns: A boolean, representing `self.selectables_length != 0`. \"\"\" return self . selectables_length != 0 @property def static_width ( self ) -> int : \"\"\"Allows for a shorter way of setting a width, and SizePolicy.STATIC. Args: value: The new width integer. Returns: None, as this is setter only. \"\"\" return None # type: ignore @static_width . setter def static_width ( self , value : int ) -> None : \"\"\"See the static_width getter.\"\"\" self . width = value self . size_policy = SizePolicy . STATIC @property def relative_width ( self ) -> float | None : \"\"\"Sets this widget's relative width, and changes size_policy to RELATIVE. The value is clamped to 1.0. If a Container holds a width of 30, and it has a subwidget with a relative width of 0.5, it will be resized to 15. Args: value: The multiplier to apply to the parent's width. Returns: The current relative_width. \"\"\" return self . _relative_width @relative_width . setter def relative_width ( self , value : float ) -> None : \"\"\"See the relative_width getter.\"\"\" self . size_policy = SizePolicy . RELATIVE self . _relative_width = min ( 1.0 , value ) @property def terminal ( self ) -> Terminal : \"\"\"Returns the current global terminal instance.\"\"\" return get_terminal () def get_change ( self ) -> WidgetChange | None : \"\"\"Determines whether widget lines changed since the last call to this function.\"\"\" lines = self . get_lines () if self . _previous_state is None : self . _previous_state = ( self . width , self . height ), lines return WidgetChange . LINES lines = self . get_lines () ( old_width , old_height ), old_lines = self . _previous_state self . _previous_state = ( self . width , self . height ), lines if old_width != self . width and old_height != self . height : return WidgetChange . SIZE if old_width != self . width : return WidgetChange . WIDTH if old_height != self . height : return WidgetChange . HEIGHT if old_lines != lines : return WidgetChange . LINES return None def contains ( self , pos : tuple [ int , int ]) -> bool : \"\"\"Determines whether widget contains `pos`. Args: pos: Position to compare. Returns: Boolean describing whether the position is inside this widget. \"\"\" rect = self . pos , ( self . pos [ 0 ] + self . width , self . pos [ 1 ] + self . height , ) ( left , top ), ( right , bottom ) = rect return left <= pos [ 0 ] < right and top <= pos [ 1 ] < bottom def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Tries to call the most specific mouse handler function available. This function looks for a set of mouse action handlers. Each handler follows the format on_{event_name} For example, the handler triggered on MouseAction.LEFT_CLICK would be `on_left_click`. If no handler is found nothing is done. You can also define more general handlers, for example to group left & right clicks you can use `on_click`, and to catch both up and down scroll you can use `on_scroll`. General handlers are only used if they are the most specific ones, i.e. there is no \"specific\" handler. Args: event: The event to handle. Returns: Whether the parent of this widget should treat it as one to \"stick\" events to, e.g. to keep sending mouse events to it. One can \"unstick\" a widget by returning False in the handler. \"\"\" def _get_names ( action : MouseAction ) -> tuple [ str , ... ]: if action . value in [ \"hover\" , \"release\" ]: return ( action . value ,) parts = action . value . split ( \"_\" ) # left click & right click if parts [ 0 ] in [ \"left\" , \"right\" ]: return ( action . value , parts [ 1 ]) if parts [ 0 ] == \"shift\" : return ( action . value , f \"shift_ { parts [ 1 ] } \" , parts [ 1 ]) # scroll up & down return ( action . value , parts [ 0 ]) possible_names = _get_names ( event . action ) for name in possible_names : if hasattr ( self , f \"on_ { name } \" ): handle = getattr ( self , f \"on_ { name } \" ) return handle ( event ) return False def handle_key ( self , key : str ) -> bool : \"\"\"Handles a mouse event, returning its success. Args: key: String representation of input string. The `pytermgui.input.keys` object can be used to retrieve special keys. Returns: A boolean describing whether the key was handled. \"\"\" return False and hasattr ( self , key ) def serialize ( self ) -> dict [ str , Any ]: \"\"\"Serializes a widget. The fields looked at are defined `Widget.serialized`. Note that this method is not very commonly used at the moment, so it might not have full functionality in non-nuclear widgets. Returns: Dictionary of widget attributes. The dictionary will always have a `type` field. Any styles are converted into markup strings during serialization, so they can be loaded again in their original form. Example return: ``` { \"type\": \"Label\", \"value\": \"[210 bold]I am a title\", \"parent_align\": 0, ... } ``` \"\"\" fields = self . _serialized_fields out : dict [ str , Any ] = { \"type\" : type ( self ) . __name__ } for key in fields : # Detect styled values if key . startswith ( \"*\" ): style = True key = key [ 1 :] else : style = False value = getattr ( self , key ) # Convert styled value into markup if style : style_call = self . _get_style ( key ) if isinstance ( value , list ): out [ key ] = [ get_markup ( style_call ( char )) for char in value ] else : out [ key ] = get_markup ( style_call ( value )) continue out [ key ] = value # The chars need to be handled separately out [ \"chars\" ] = {} for key , value in self . chars . items (): style_call = self . _get_style ( key ) if isinstance ( value , list ): out [ \"chars\" ][ key ] = [ get_markup ( style_call ( char )) for char in value ] else : out [ \"chars\" ][ key ] = get_markup ( style_call ( value )) return out def copy ( self ) -> Widget : \"\"\"Creates a deep copy of this widget\"\"\" return deepcopy ( self ) def _get_style ( self , key : str ) -> w_styles . DepthlessStyleType : \"\"\"Gets style call from its key. This is analogous to using `self.styles.{key}` Args: key: A key into the widget's style manager. Returns: A `pytermgui.styles.StyleCall` object containing the referenced style. StyleCall objects should only be used internally inside a widget. Raises: KeyError: Style key is invalid. \"\"\" return self . styles [ key ] def _get_char ( self , key : str ) -> w_styles . CharType : \"\"\"Gets character from its key. Args: key: A key into the widget's chars dictionary. Returns: Either a `list[str]` or a simple `str`, depending on the character. Raises: KeyError: Style key is invalid. \"\"\" chars = self . chars [ key ] if isinstance ( chars , str ): if chars . startswith ( \"u:\" ): identifier = \" \" . join ( chars [ 2 :] . split ( \"_\" )) chars = u_lookup ( identifier ) return chars return chars . copy () def get_lines ( self ) -> list [ str ]: \"\"\"Gets lines representing this widget. These lines have to be equal to the widget in length. All widgets must provide this method. Make sure to keep it performant, as it will be called very often, often multiple times per WindowManager frame. Any longer actions should be done outside of this method, and only their result should be looked up here. Returns: Nothing by default. Raises: NotImplementedError: As this method is required for **all** widgets, not having it defined will raise NotImplementedError. \"\"\" raise NotImplementedError ( f \"get_lines() is not defined for type { type ( self ) } .\" ) def bind ( self , key : str , action : BoundCallback , description : Optional [ str ] = None ) -> None : \"\"\"Binds an action to a keypress. This function is only called by implementations above this layer. To use this functionality use `pytermgui.window_manager.WindowManager`, or write your own custom layer. Special keys: - keys.ANY_KEY: Any and all keypresses execute this binding. - keys.MouseAction: Any and all mouse inputs execute this binding. Args: key: The key that the action will be bound to. action: The action executed when the key is pressed. description: An optional description for this binding. It is not really used anywhere, but you can provide a helper menu and display them. \"\"\" if description is None : description = f \"Binding of { key } to { action } \" self . _bindings [ key ] = ( action , description ) def unbind ( self , key : str ) -> None : \"\"\"Unbinds the given key.\"\"\" del self . _bindings [ key ] def execute_binding ( self , key : Any , ignore_any : bool = False ) -> bool : \"\"\"Executes a binding belonging to key, when present. Use this method inside custom widget `handle_keys` methods, or to run a callback without its corresponding key having been pressed. Args: key: Usually a string, indexing into the `_bindings` dictionary. These are the same strings as defined in `Widget.bind`. ignore_any: If set, `keys.ANY_KEY` bindings will not be executed. Returns: True if the binding was found, False otherwise. Bindings will always be executed if they are found. \"\"\" # Execute special binding if not ignore_any and keys . ANY_KEY in self . _bindings : method , _ = self . _bindings [ keys . ANY_KEY ] method ( self , key ) if key in self . _bindings : method , _ = self . _bindings [ key ] method ( self , key ) return True return False def select ( self , index : int | None = None ) -> None : \"\"\"Selects a part of this Widget. Args: index: The index to select. Raises: TypeError: This widget has no selectables, i.e. widget.is_selectable == False. \"\"\" if not self . is_selectable : raise TypeError ( f \"Object of type { type ( self ) } has no selectables.\" ) if index is not None : index = min ( max ( 0 , index ), self . selectables_length - 1 ) self . selected_index = index def print ( self ) -> None : \"\"\"Prints this widget\"\"\" for line in self . get_lines (): print ( line ) def debug ( self ) -> str : \"\"\"Returns identifiable information about this widget. This method is used to easily differentiate between widgets. By default, all widget's __repr__ method is an alias to this. The signature of each widget is used to generate the return value. Returns: A string almost exactly matching the line of code that could have defined the widget. Example return: ``` Container(Label(value=\"This is a label\", padding=0), Button(label=\"This is a button\", padding=0), **attrs) ``` \"\"\" constructor = \"(\" for name in signature ( getattr ( self , \"__init__\" )) . parameters : current = \"\" if name == \"attrs\" : current += \"**attrs\" continue if len ( constructor ) > 1 : current += \", \" current += name attr = getattr ( self , name , None ) if attr is None : continue current += \"=\" if isinstance ( attr , str ): current += f '\" { attr } \"' else : current += str ( attr ) constructor += current constructor += \")\" return type ( self ) . __name__ + constructor keys : dict [ str , set [ str ]] = {} class-attribute Groups of keys that are used in handle_key parent_align = HorizontalAlignment . get_default () class-attribute pytermgui.enums.HorizontalAlignment to align widget by serialized : list [ str ] = [ 'id' , 'pos' , 'depth' , 'width' , 'height' , 'selected_index' , 'selectables_length' ] class-attribute Fields of widget that shall be serialized by pytermgui.serializer.Serializer size_policy = SizePolicy . get_default () class-attribute pytermgui.enums.SizePolicy to set widget's width according to __fancy_repr__ () Yields the repr of this object, then a preview of it. Source code in pytermgui/widgets/base.py 159 160 161 162 163 164 165 166 167 def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Yields the repr of this object, then a preview of it.\"\"\" yield self . debug () yield \" \\n\\n \" yield { \"text\" : \" \\n \" . join (( line + reset () for line in self . get_lines ())), \"highlight\" : False , } __init__ ( attrs ) Initialize object Source code in pytermgui/widgets/base.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def __init__ ( self , ** attrs : Any ) -> None : \"\"\"Initialize object\"\"\" self . set_style = lambda key , value : _set_obj_or_cls_style ( self , key , value ) self . set_char = lambda key , value : _set_obj_or_cls_char ( self , key , value ) self . width = 1 self . height = 1 self . pos = self . terminal . origin self . depth = 0 self . styles = type ( self ) . styles . branch ( self ) self . chars = type ( self ) . chars . copy () self . parent : Widget | None = None self . selected_index : int | None = None self . _selectables_length = 0 self . _id : Optional [ str ] = None self . _serialized_fields = type ( self ) . serialized self . _bindings : dict [ str | Type [ MouseEvent ], tuple [ BoundCallback , str ]] = {} self . _relative_width : float | None = None self . _previous_state : tuple [ tuple [ int , int ], list [ str ]] | None = None self . positioned_line_buffer : list [ tuple [ tuple [ int , int ], str ]] = [] for attr , value in attrs . items (): setattr ( self , attr , value ) __iter__ () Return self for iteration Source code in pytermgui/widgets/base.py 169 170 171 172 def __iter__ ( self ) -> Iterator [ Widget ]: \"\"\"Return self for iteration\"\"\" yield self __repr__ () Return repr string of this widget. Returns: Type Description str Whatever this widget's debug method gives. Source code in pytermgui/widgets/base.py 150 151 152 153 154 155 156 157 def __repr__ ( self ) -> str : \"\"\"Return repr string of this widget. Returns: Whatever this widget's `debug` method gives. \"\"\" return self . debug () bind ( key , action , description = None ) Binds an action to a keypress. This function is only called by implementations above this layer. To use this functionality use pytermgui.window_manager.WindowManager , or write your own custom layer. Special keys: - keys.ANY_KEY: Any and all keypresses execute this binding. - keys.MouseAction: Any and all mouse inputs execute this binding. Parameters: Name Type Description Default key str The key that the action will be bound to. required action BoundCallback The action executed when the key is pressed. required description Optional [ str ] An optional description for this binding. It is not really used anywhere, but you can provide a helper menu and display them. None Source code in pytermgui/widgets/base.py 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 def bind ( self , key : str , action : BoundCallback , description : Optional [ str ] = None ) -> None : \"\"\"Binds an action to a keypress. This function is only called by implementations above this layer. To use this functionality use `pytermgui.window_manager.WindowManager`, or write your own custom layer. Special keys: - keys.ANY_KEY: Any and all keypresses execute this binding. - keys.MouseAction: Any and all mouse inputs execute this binding. Args: key: The key that the action will be bound to. action: The action executed when the key is pressed. description: An optional description for this binding. It is not really used anywhere, but you can provide a helper menu and display them. \"\"\" if description is None : description = f \"Binding of { key } to { action } \" self . _bindings [ key ] = ( action , description ) bindings () property Gets a copy of the bindings internal dictionary. Returns: Type Description dict [ str | Type [ MouseEvent ], tuple [ BoundCallback , str ]] A copy of the internal bindings dictionary, such as: dict [ str | Type [ MouseEvent ], tuple [ BoundCallback , str ]] ``` dict [ str | Type [ MouseEvent ], tuple [ BoundCallback , str ]] { \" \": (star_callback, \"This is a callback activated when ' ' is pressed.\") dict [ str | Type [ MouseEvent ], tuple [ BoundCallback , str ]] } dict [ str | Type [ MouseEvent ], tuple [ BoundCallback , str ]] ``` Source code in pytermgui/widgets/base.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 @property def bindings ( self ) -> dict [ str | Type [ MouseEvent ], tuple [ BoundCallback , str ]]: \"\"\"Gets a copy of the bindings internal dictionary. Returns: A copy of the internal bindings dictionary, such as: ``` { \"*\": (star_callback, \"This is a callback activated when '*' is pressed.\") } ``` \"\"\" return self . _bindings . copy () contains ( pos ) Determines whether widget contains pos . Parameters: Name Type Description Default pos tuple [ int , int ] Position to compare. required Returns: Type Description bool Boolean describing whether the position is inside this widget. Source code in pytermgui/widgets/base.py 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 def contains ( self , pos : tuple [ int , int ]) -> bool : \"\"\"Determines whether widget contains `pos`. Args: pos: Position to compare. Returns: Boolean describing whether the position is inside this widget. \"\"\" rect = self . pos , ( self . pos [ 0 ] + self . width , self . pos [ 1 ] + self . height , ) ( left , top ), ( right , bottom ) = rect return left <= pos [ 0 ] < right and top <= pos [ 1 ] < bottom copy () Creates a deep copy of this widget Source code in pytermgui/widgets/base.py 480 481 482 483 def copy ( self ) -> Widget : \"\"\"Creates a deep copy of this widget\"\"\" return deepcopy ( self ) debug () Returns identifiable information about this widget. This method is used to easily differentiate between widgets. By default, all widget's repr method is an alias to this. The signature of each widget is used to generate the return value. Returns: Type Description str A string almost exactly matching the line of code that could have defined the widget. str Example return: str ``` str Container(Label(value=\"This is a label\", padding=0), str Button(label=\"This is a button\", padding=0), **attrs) str ``` Source code in pytermgui/widgets/base.py 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 def debug ( self ) -> str : \"\"\"Returns identifiable information about this widget. This method is used to easily differentiate between widgets. By default, all widget's __repr__ method is an alias to this. The signature of each widget is used to generate the return value. Returns: A string almost exactly matching the line of code that could have defined the widget. Example return: ``` Container(Label(value=\"This is a label\", padding=0), Button(label=\"This is a button\", padding=0), **attrs) ``` \"\"\" constructor = \"(\" for name in signature ( getattr ( self , \"__init__\" )) . parameters : current = \"\" if name == \"attrs\" : current += \"**attrs\" continue if len ( constructor ) > 1 : current += \", \" current += name attr = getattr ( self , name , None ) if attr is None : continue current += \"=\" if isinstance ( attr , str ): current += f '\" { attr } \"' else : current += str ( attr ) constructor += current constructor += \")\" return type ( self ) . __name__ + constructor execute_binding ( key , ignore_any = False ) Executes a binding belonging to key, when present. Use this method inside custom widget handle_keys methods, or to run a callback without its corresponding key having been pressed. Parameters: Name Type Description Default key Any Usually a string, indexing into the _bindings dictionary. These are the same strings as defined in Widget.bind . required ignore_any bool If set, keys.ANY_KEY bindings will not be executed. False Returns: Type Description bool True if the binding was found, False otherwise. Bindings will always be executed if they are found. Source code in pytermgui/widgets/base.py 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 def execute_binding ( self , key : Any , ignore_any : bool = False ) -> bool : \"\"\"Executes a binding belonging to key, when present. Use this method inside custom widget `handle_keys` methods, or to run a callback without its corresponding key having been pressed. Args: key: Usually a string, indexing into the `_bindings` dictionary. These are the same strings as defined in `Widget.bind`. ignore_any: If set, `keys.ANY_KEY` bindings will not be executed. Returns: True if the binding was found, False otherwise. Bindings will always be executed if they are found. \"\"\" # Execute special binding if not ignore_any and keys . ANY_KEY in self . _bindings : method , _ = self . _bindings [ keys . ANY_KEY ] method ( self , key ) if key in self . _bindings : method , _ = self . _bindings [ key ] method ( self , key ) return True return False get_change () Determines whether widget lines changed since the last call to this function. Source code in pytermgui/widgets/base.py 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 def get_change ( self ) -> WidgetChange | None : \"\"\"Determines whether widget lines changed since the last call to this function.\"\"\" lines = self . get_lines () if self . _previous_state is None : self . _previous_state = ( self . width , self . height ), lines return WidgetChange . LINES lines = self . get_lines () ( old_width , old_height ), old_lines = self . _previous_state self . _previous_state = ( self . width , self . height ), lines if old_width != self . width and old_height != self . height : return WidgetChange . SIZE if old_width != self . width : return WidgetChange . WIDTH if old_height != self . height : return WidgetChange . HEIGHT if old_lines != lines : return WidgetChange . LINES return None get_lines () Gets lines representing this widget. These lines have to be equal to the widget in length. All widgets must provide this method. Make sure to keep it performant, as it will be called very often, often multiple times per WindowManager frame. Any longer actions should be done outside of this method, and only their result should be looked up here. Returns: Type Description list [ str ] Nothing by default. Raises: Type Description NotImplementedError As this method is required for all widgets, not having it defined will raise NotImplementedError. Source code in pytermgui/widgets/base.py 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def get_lines ( self ) -> list [ str ]: \"\"\"Gets lines representing this widget. These lines have to be equal to the widget in length. All widgets must provide this method. Make sure to keep it performant, as it will be called very often, often multiple times per WindowManager frame. Any longer actions should be done outside of this method, and only their result should be looked up here. Returns: Nothing by default. Raises: NotImplementedError: As this method is required for **all** widgets, not having it defined will raise NotImplementedError. \"\"\" raise NotImplementedError ( f \"get_lines() is not defined for type { type ( self ) } .\" ) handle_key ( key ) Handles a mouse event, returning its success. Parameters: Name Type Description Default key str String representation of input string. The pytermgui.input.keys object can be used to retrieve special keys. required Returns: Type Description bool A boolean describing whether the key was handled. Source code in pytermgui/widgets/base.py 405 406 407 408 409 410 411 412 413 414 415 416 417 def handle_key ( self , key : str ) -> bool : \"\"\"Handles a mouse event, returning its success. Args: key: String representation of input string. The `pytermgui.input.keys` object can be used to retrieve special keys. Returns: A boolean describing whether the key was handled. \"\"\" return False and hasattr ( self , key ) handle_mouse ( event ) Tries to call the most specific mouse handler function available. This function looks for a set of mouse action handlers. Each handler follows the format on_{event_name} For example, the handler triggered on MouseAction.LEFT_CLICK would be on_left_click . If no handler is found nothing is done. You can also define more general handlers, for example to group left & right clicks you can use on_click , and to catch both up and down scroll you can use on_scroll . General handlers are only used if they are the most specific ones, i.e. there is no \"specific\" handler. Parameters: Name Type Description Default event MouseEvent The event to handle. required Returns: Type Description bool Whether the parent of this widget should treat it as one to \"stick\" events bool to, e.g. to keep sending mouse events to it. One can \"unstick\" a widget by bool returning False in the handler. Source code in pytermgui/widgets/base.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Tries to call the most specific mouse handler function available. This function looks for a set of mouse action handlers. Each handler follows the format on_{event_name} For example, the handler triggered on MouseAction.LEFT_CLICK would be `on_left_click`. If no handler is found nothing is done. You can also define more general handlers, for example to group left & right clicks you can use `on_click`, and to catch both up and down scroll you can use `on_scroll`. General handlers are only used if they are the most specific ones, i.e. there is no \"specific\" handler. Args: event: The event to handle. Returns: Whether the parent of this widget should treat it as one to \"stick\" events to, e.g. to keep sending mouse events to it. One can \"unstick\" a widget by returning False in the handler. \"\"\" def _get_names ( action : MouseAction ) -> tuple [ str , ... ]: if action . value in [ \"hover\" , \"release\" ]: return ( action . value ,) parts = action . value . split ( \"_\" ) # left click & right click if parts [ 0 ] in [ \"left\" , \"right\" ]: return ( action . value , parts [ 1 ]) if parts [ 0 ] == \"shift\" : return ( action . value , f \"shift_ { parts [ 1 ] } \" , parts [ 1 ]) # scroll up & down return ( action . value , parts [ 0 ]) possible_names = _get_names ( event . action ) for name in possible_names : if hasattr ( self , f \"on_ { name } \" ): handle = getattr ( self , f \"on_ { name } \" ) return handle ( event ) return False id () property writable Gets this widget's id property Returns: Type Description Optional [ str ] The id string if one is present, None otherwise. Source code in pytermgui/widgets/base.py 190 191 192 193 194 195 196 197 198 @property def id ( self ) -> Optional [ str ]: # pylint: disable=invalid-name \"\"\"Gets this widget's id property Returns: The id string if one is present, None otherwise. \"\"\" return self . _id is_selectable () property Determines whether this widget has any selectables. Returns: Type Description bool A boolean, representing self.selectables_length != 0 . Source code in pytermgui/widgets/base.py 246 247 248 249 250 251 252 253 254 @property def is_selectable ( self ) -> bool : \"\"\"Determines whether this widget has any selectables. Returns: A boolean, representing `self.selectables_length != 0`. \"\"\" return self . selectables_length != 0 print () Prints this widget Source code in pytermgui/widgets/base.py 624 625 626 627 628 def print ( self ) -> None : \"\"\"Prints this widget\"\"\" for line in self . get_lines (): print ( line ) relative_width () property writable Sets this widget's relative width, and changes size_policy to RELATIVE. The value is clamped to 1.0. If a Container holds a width of 30, and it has a subwidget with a relative width of 0.5, it will be resized to 15. Parameters: Name Type Description Default value The multiplier to apply to the parent's width. required Returns: Type Description float | None The current relative_width. Source code in pytermgui/widgets/base.py 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 @property def relative_width ( self ) -> float | None : \"\"\"Sets this widget's relative width, and changes size_policy to RELATIVE. The value is clamped to 1.0. If a Container holds a width of 30, and it has a subwidget with a relative width of 0.5, it will be resized to 15. Args: value: The multiplier to apply to the parent's width. Returns: The current relative_width. \"\"\" return self . _relative_width select ( index = None ) Selects a part of this Widget. Parameters: Name Type Description Default index int | None The index to select. None Raises: Type Description TypeError This widget has no selectables, i.e. widget.is_selectable == False. Source code in pytermgui/widgets/base.py 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 def select ( self , index : int | None = None ) -> None : \"\"\"Selects a part of this Widget. Args: index: The index to select. Raises: TypeError: This widget has no selectables, i.e. widget.is_selectable == False. \"\"\" if not self . is_selectable : raise TypeError ( f \"Object of type { type ( self ) } has no selectables.\" ) if index is not None : index = min ( max ( 0 , index ), self . selectables_length - 1 ) self . selected_index = index selectables () property Gets a list of all selectables within this widget Returns: Type Description list [ tuple [ Widget , int ]] A list of tuples. In the default implementation this will be list [ tuple [ Widget , int ]] a list of one tuple, containing a reference to self , as well list [ tuple [ Widget , int ]] as the lowest index, 0. Source code in pytermgui/widgets/base.py 234 235 236 237 238 239 240 241 242 243 244 @property def selectables ( self ) -> list [ tuple [ Widget , int ]]: \"\"\"Gets a list of all selectables within this widget Returns: A list of tuples. In the default implementation this will be a list of one tuple, containing a reference to `self`, as well as the lowest index, 0. \"\"\" return [( self , 0 )] selectables_length () property Gets how many selectables this widget contains. Returns: Type Description int An integer describing the amount of selectables in this widget. Source code in pytermgui/widgets/base.py 224 225 226 227 228 229 230 231 232 @property def selectables_length ( self ) -> int : \"\"\"Gets how many selectables this widget contains. Returns: An integer describing the amount of selectables in this widget. \"\"\" return self . _selectables_length serialize () Serializes a widget. The fields looked at are defined Widget.serialized . Note that this method is not very commonly used at the moment, so it might not have full functionality in non-nuclear widgets. Returns: Type Description dict [ str , Any ] Dictionary of widget attributes. The dictionary will always dict [ str , Any ] have a type field. Any styles are converted into markup dict [ str , Any ] strings during serialization, so they can be loaded again in dict [ str , Any ] their original form. dict [ str , Any ] Example return: dict [ str , Any ] ``` { \"type\": \"Label\", \"value\": \"[210 bold]I am a title\", \"parent_align\": 0, ... } dict [ str , Any ] ``` Source code in pytermgui/widgets/base.py 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 def serialize ( self ) -> dict [ str , Any ]: \"\"\"Serializes a widget. The fields looked at are defined `Widget.serialized`. Note that this method is not very commonly used at the moment, so it might not have full functionality in non-nuclear widgets. Returns: Dictionary of widget attributes. The dictionary will always have a `type` field. Any styles are converted into markup strings during serialization, so they can be loaded again in their original form. Example return: ``` { \"type\": \"Label\", \"value\": \"[210 bold]I am a title\", \"parent_align\": 0, ... } ``` \"\"\" fields = self . _serialized_fields out : dict [ str , Any ] = { \"type\" : type ( self ) . __name__ } for key in fields : # Detect styled values if key . startswith ( \"*\" ): style = True key = key [ 1 :] else : style = False value = getattr ( self , key ) # Convert styled value into markup if style : style_call = self . _get_style ( key ) if isinstance ( value , list ): out [ key ] = [ get_markup ( style_call ( char )) for char in value ] else : out [ key ] = get_markup ( style_call ( value )) continue out [ key ] = value # The chars need to be handled separately out [ \"chars\" ] = {} for key , value in self . chars . items (): style_call = self . _get_style ( key ) if isinstance ( value , list ): out [ \"chars\" ][ key ] = [ get_markup ( style_call ( char )) for char in value ] else : out [ \"chars\" ][ key ] = get_markup ( style_call ( value )) return out static_width () property writable Allows for a shorter way of setting a width, and SizePolicy.STATIC. Parameters: Name Type Description Default value The new width integer. required Returns: Type Description int None, as this is setter only. Source code in pytermgui/widgets/base.py 256 257 258 259 260 261 262 263 264 265 266 267 @property def static_width ( self ) -> int : \"\"\"Allows for a shorter way of setting a width, and SizePolicy.STATIC. Args: value: The new width integer. Returns: None, as this is setter only. \"\"\" return None # type: ignore terminal () property Returns the current global terminal instance. Source code in pytermgui/widgets/base.py 301 302 303 304 305 @property def terminal ( self ) -> Terminal : \"\"\"Returns the current global terminal instance.\"\"\" return get_terminal () unbind ( key ) Unbinds the given key. Source code in pytermgui/widgets/base.py 573 574 575 576 def unbind ( self , key : str ) -> None : \"\"\"Unbinds the given key.\"\"\" del self . _bindings [ key ]","title":"base"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Label","text":"Bases: Widget A Widget to display a string By default, this widget uses pytermgui.widgets.styles.MARKUP . This allows it to house markup text that is parsed before display, such as: print(\"hello world\") import pytermgui as ptg with ptg . alt_buffer (): root = ptg . Container ( ptg . Label ( \"[italic 141 bold]This is some [green]fancy [white inverse]text!\" ) ) root . print () ptg . getch () Source code in pytermgui/widgets/base.py 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 class Label ( Widget ): \"\"\"A Widget to display a string By default, this widget uses `pytermgui.widgets.styles.MARKUP`. This allows it to house markup text that is parsed before display, such as: ```termage-svg print(\"hello world\") ``` ```python3 import pytermgui as ptg with ptg.alt_buffer(): root = ptg.Container( ptg.Label(\"[italic 141 bold]This is some [green]fancy [white inverse]text!\") ) root.print() ptg.getch() ``` <p style=\"text-align: center\"> <img src=\"https://github.com/bczsalba/pytermgui/blob/master/assets/docs/widgets/label.png?raw=true\" width=100%> </p> \"\"\" serialized = Widget . serialized + [ \"*value\" , \"align\" , \"padding\" ] styles = w_styles . StyleManager ( value = \"\" ) def __init__ ( self , value : str = \"\" , style : str | w_styles . StyleValue = \"\" , padding : int = 0 , non_first_padding : int = 0 , ** attrs : Any , ) -> None : \"\"\"Initializes a Label. Args: value: The value of this string. Using the default value style (`pytermgui.widgets.styles.MARKUP`), style: A pre-set value for self.styles.value. padding: The number of space (\" \") characters to prepend to every line after line breaking. non_first_padding: The number of space characters to prepend to every non-first line of `get_lines`. This is applied on top of `padding`. \"\"\" super () . __init__ ( ** attrs ) self . value = value self . padding = padding self . non_first_padding = non_first_padding self . width = real_length ( value ) + self . padding if style != \"\" : self . styles . value = style def get_lines ( self ) -> list [ str ]: \"\"\"Get lines representing this Label, breaking lines as necessary\"\"\" lines = [] limit = self . width - self . padding broken = break_line ( self . styles . value ( self . value ), limit = limit , non_first_limit = limit - self . non_first_padding , ) for i , line in enumerate ( broken ): if i == 0 : lines . append ( self . padding * \" \" + line ) continue lines . append ( self . padding * \" \" + self . non_first_padding * \" \" + line ) return lines or [ \"\" ]","title":"Label"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Label.__init__","text":"Initializes a Label. Parameters: Name Type Description Default value str The value of this string. Using the default value style ( pytermgui.widgets.styles.MARKUP ), '' style str | w_styles . StyleValue A pre-set value for self.styles.value. '' padding int The number of space (\" \") characters to prepend to every line after line breaking. 0 non_first_padding int The number of space characters to prepend to every non-first line of get_lines . This is applied on top of padding . 0 Source code in pytermgui/widgets/base.py 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 def __init__ ( self , value : str = \"\" , style : str | w_styles . StyleValue = \"\" , padding : int = 0 , non_first_padding : int = 0 , ** attrs : Any , ) -> None : \"\"\"Initializes a Label. Args: value: The value of this string. Using the default value style (`pytermgui.widgets.styles.MARKUP`), style: A pre-set value for self.styles.value. padding: The number of space (\" \") characters to prepend to every line after line breaking. non_first_padding: The number of space characters to prepend to every non-first line of `get_lines`. This is applied on top of `padding`. \"\"\" super () . __init__ ( ** attrs ) self . value = value self . padding = padding self . non_first_padding = non_first_padding self . width = real_length ( value ) + self . padding if style != \"\" : self . styles . value = style","title":"__init__()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Label.get_lines","text":"Get lines representing this Label, breaking lines as necessary Source code in pytermgui/widgets/base.py 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 def get_lines ( self ) -> list [ str ]: \"\"\"Get lines representing this Label, breaking lines as necessary\"\"\" lines = [] limit = self . width - self . padding broken = break_line ( self . styles . value ( self . value ), limit = limit , non_first_limit = limit - self . non_first_padding , ) for i , line in enumerate ( broken ): if i == 0 : lines . append ( self . padding * \" \" + line ) continue lines . append ( self . padding * \" \" + self . non_first_padding * \" \" + line ) return lines or [ \"\" ]","title":"get_lines()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.ScrollableWidget","text":"Bases: Widget A widget with some scrolling helper methods. This is not an implementation of the scrolling behaviour itself, just the user-facing API for it. It provides a _scroll_offset attribute, which is an integer describing the current scroll state offset from the top, as well as some methods to modify the state. Source code in pytermgui/widgets/base.py 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 class ScrollableWidget ( Widget ): \"\"\"A widget with some scrolling helper methods. This is not an implementation of the scrolling behaviour itself, just the user-facing API for it. It provides a `_scroll_offset` attribute, which is an integer describing the current scroll state offset from the top, as well as some methods to modify the state.\"\"\" def __init__ ( self , ** attrs : Any ) -> None : \"\"\"Initializes the scrollable widget.\"\"\" super () . __init__ ( ** attrs ) self . _max_scroll = 0 self . _scroll_offset = 0 def scroll ( self , offset : int ) -> bool : \"\"\"Scrolls to given offset, returns the new scroll_offset. Args: offset: The amount to scroll by. Positive offsets scroll down, negative up. Returns: True if the scroll offset changed, False otherwise. \"\"\" base = self . _scroll_offset self . _scroll_offset = min ( max ( 0 , self . _scroll_offset + offset ), self . _max_scroll ) return base != self . _scroll_offset def scroll_end ( self , end : int ) -> int : \"\"\"Scrolls to either top or bottom end of this object. Args: end: The offset to scroll to. 0 goes to the very top, -1 to the very bottom. Returns: True if the scroll offset changed, False otherwise. \"\"\" base = self . _scroll_offset if end == 0 : self . _scroll_offset = 0 elif end == - 1 : self . _scroll_offset = self . _max_scroll return base != self . _scroll_offset def get_lines ( self ) -> list [ str ]: ...","title":"ScrollableWidget"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.ScrollableWidget.__init__","text":"Initializes the scrollable widget. Source code in pytermgui/widgets/base.py 770 771 772 773 774 775 776 def __init__ ( self , ** attrs : Any ) -> None : \"\"\"Initializes the scrollable widget.\"\"\" super () . __init__ ( ** attrs ) self . _max_scroll = 0 self . _scroll_offset = 0","title":"__init__()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.ScrollableWidget.scroll","text":"Scrolls to given offset, returns the new scroll_offset. Parameters: Name Type Description Default offset int The amount to scroll by. Positive offsets scroll down, negative up. required Returns: Type Description bool True if the scroll offset changed, False otherwise. Source code in pytermgui/widgets/base.py 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 def scroll ( self , offset : int ) -> bool : \"\"\"Scrolls to given offset, returns the new scroll_offset. Args: offset: The amount to scroll by. Positive offsets scroll down, negative up. Returns: True if the scroll offset changed, False otherwise. \"\"\" base = self . _scroll_offset self . _scroll_offset = min ( max ( 0 , self . _scroll_offset + offset ), self . _max_scroll ) return base != self . _scroll_offset","title":"scroll()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.ScrollableWidget.scroll_end","text":"Scrolls to either top or bottom end of this object. Parameters: Name Type Description Default end int The offset to scroll to. 0 goes to the very top, -1 to the very bottom. required Returns: Type Description int True if the scroll offset changed, False otherwise. Source code in pytermgui/widgets/base.py 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 def scroll_end ( self , end : int ) -> int : \"\"\"Scrolls to either top or bottom end of this object. Args: end: The offset to scroll to. 0 goes to the very top, -1 to the very bottom. Returns: True if the scroll offset changed, False otherwise. \"\"\" base = self . _scroll_offset if end == 0 : self . _scroll_offset = 0 elif end == - 1 : self . _scroll_offset = self . _max_scroll return base != self . _scroll_offset","title":"scroll_end()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget","text":"The base of the Widget system Source code in pytermgui/widgets/base.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 class Widget : # pylint: disable=too-many-public-methods \"\"\"The base of the Widget system\"\"\" set_style = classmethod ( _set_obj_or_cls_style ) set_char = classmethod ( _set_obj_or_cls_char ) styles = w_styles . StyleManager () \"\"\"Default styles for this class\"\"\" chars : dict [ str , w_styles . CharType ] = {} \"\"\"Default characters for this class\"\"\" keys : dict [ str , set [ str ]] = {} \"\"\"Groups of keys that are used in `handle_key`\"\"\" serialized : list [ str ] = [ \"id\" , \"pos\" , \"depth\" , \"width\" , \"height\" , \"selected_index\" , \"selectables_length\" , ] \"\"\"Fields of widget that shall be serialized by `pytermgui.serializer.Serializer`\"\"\" # This class is loaded after this module, # and thus mypy doesn't see its existence. _id_manager : Optional [ \"_IDManager\" ] = None # type: ignore size_policy = SizePolicy . get_default () \"\"\"`pytermgui.enums.SizePolicy` to set widget's width according to\"\"\" parent_align = HorizontalAlignment . get_default () \"\"\"`pytermgui.enums.HorizontalAlignment` to align widget by\"\"\" from_data : Callable [ ... , Widget | list [ Widget ] | None ] # We cannot import boxes here due to cyclic imports. box : Any def __init__ ( self , ** attrs : Any ) -> None : \"\"\"Initialize object\"\"\" self . set_style = lambda key , value : _set_obj_or_cls_style ( self , key , value ) self . set_char = lambda key , value : _set_obj_or_cls_char ( self , key , value ) self . width = 1 self . height = 1 self . pos = self . terminal . origin self . depth = 0 self . styles = type ( self ) . styles . branch ( self ) self . chars = type ( self ) . chars . copy () self . parent : Widget | None = None self . selected_index : int | None = None self . _selectables_length = 0 self . _id : Optional [ str ] = None self . _serialized_fields = type ( self ) . serialized self . _bindings : dict [ str | Type [ MouseEvent ], tuple [ BoundCallback , str ]] = {} self . _relative_width : float | None = None self . _previous_state : tuple [ tuple [ int , int ], list [ str ]] | None = None self . positioned_line_buffer : list [ tuple [ tuple [ int , int ], str ]] = [] for attr , value in attrs . items (): setattr ( self , attr , value ) def __repr__ ( self ) -> str : \"\"\"Return repr string of this widget. Returns: Whatever this widget's `debug` method gives. \"\"\" return self . debug () def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Yields the repr of this object, then a preview of it.\"\"\" yield self . debug () yield \" \\n\\n \" yield { \"text\" : \" \\n \" . join (( line + reset () for line in self . get_lines ())), \"highlight\" : False , } def __iter__ ( self ) -> Iterator [ Widget ]: \"\"\"Return self for iteration\"\"\" yield self @property def bindings ( self ) -> dict [ str | Type [ MouseEvent ], tuple [ BoundCallback , str ]]: \"\"\"Gets a copy of the bindings internal dictionary. Returns: A copy of the internal bindings dictionary, such as: ``` { \"*\": (star_callback, \"This is a callback activated when '*' is pressed.\") } ``` \"\"\" return self . _bindings . copy () @property def id ( self ) -> Optional [ str ]: # pylint: disable=invalid-name \"\"\"Gets this widget's id property Returns: The id string if one is present, None otherwise. \"\"\" return self . _id @id . setter def id ( self , value : str ) -> None : # pylint: disable=invalid-name \"\"\"Registers a widget to the Widget._id_manager. If this widget already had an id, the old value is deregistered before the new one is assigned. Args: value: The new id this widget will be registered as. \"\"\" if self . _id == value : return manager = Widget . _id_manager assert manager is not None old = manager . get_id ( self ) if old is not None : manager . deregister ( old ) self . _id = value manager . register ( self ) @property def selectables_length ( self ) -> int : \"\"\"Gets how many selectables this widget contains. Returns: An integer describing the amount of selectables in this widget. \"\"\" return self . _selectables_length @property def selectables ( self ) -> list [ tuple [ Widget , int ]]: \"\"\"Gets a list of all selectables within this widget Returns: A list of tuples. In the default implementation this will be a list of one tuple, containing a reference to `self`, as well as the lowest index, 0. \"\"\" return [( self , 0 )] @property def is_selectable ( self ) -> bool : \"\"\"Determines whether this widget has any selectables. Returns: A boolean, representing `self.selectables_length != 0`. \"\"\" return self . selectables_length != 0 @property def static_width ( self ) -> int : \"\"\"Allows for a shorter way of setting a width, and SizePolicy.STATIC. Args: value: The new width integer. Returns: None, as this is setter only. \"\"\" return None # type: ignore @static_width . setter def static_width ( self , value : int ) -> None : \"\"\"See the static_width getter.\"\"\" self . width = value self . size_policy = SizePolicy . STATIC @property def relative_width ( self ) -> float | None : \"\"\"Sets this widget's relative width, and changes size_policy to RELATIVE. The value is clamped to 1.0. If a Container holds a width of 30, and it has a subwidget with a relative width of 0.5, it will be resized to 15. Args: value: The multiplier to apply to the parent's width. Returns: The current relative_width. \"\"\" return self . _relative_width @relative_width . setter def relative_width ( self , value : float ) -> None : \"\"\"See the relative_width getter.\"\"\" self . size_policy = SizePolicy . RELATIVE self . _relative_width = min ( 1.0 , value ) @property def terminal ( self ) -> Terminal : \"\"\"Returns the current global terminal instance.\"\"\" return get_terminal () def get_change ( self ) -> WidgetChange | None : \"\"\"Determines whether widget lines changed since the last call to this function.\"\"\" lines = self . get_lines () if self . _previous_state is None : self . _previous_state = ( self . width , self . height ), lines return WidgetChange . LINES lines = self . get_lines () ( old_width , old_height ), old_lines = self . _previous_state self . _previous_state = ( self . width , self . height ), lines if old_width != self . width and old_height != self . height : return WidgetChange . SIZE if old_width != self . width : return WidgetChange . WIDTH if old_height != self . height : return WidgetChange . HEIGHT if old_lines != lines : return WidgetChange . LINES return None def contains ( self , pos : tuple [ int , int ]) -> bool : \"\"\"Determines whether widget contains `pos`. Args: pos: Position to compare. Returns: Boolean describing whether the position is inside this widget. \"\"\" rect = self . pos , ( self . pos [ 0 ] + self . width , self . pos [ 1 ] + self . height , ) ( left , top ), ( right , bottom ) = rect return left <= pos [ 0 ] < right and top <= pos [ 1 ] < bottom def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Tries to call the most specific mouse handler function available. This function looks for a set of mouse action handlers. Each handler follows the format on_{event_name} For example, the handler triggered on MouseAction.LEFT_CLICK would be `on_left_click`. If no handler is found nothing is done. You can also define more general handlers, for example to group left & right clicks you can use `on_click`, and to catch both up and down scroll you can use `on_scroll`. General handlers are only used if they are the most specific ones, i.e. there is no \"specific\" handler. Args: event: The event to handle. Returns: Whether the parent of this widget should treat it as one to \"stick\" events to, e.g. to keep sending mouse events to it. One can \"unstick\" a widget by returning False in the handler. \"\"\" def _get_names ( action : MouseAction ) -> tuple [ str , ... ]: if action . value in [ \"hover\" , \"release\" ]: return ( action . value ,) parts = action . value . split ( \"_\" ) # left click & right click if parts [ 0 ] in [ \"left\" , \"right\" ]: return ( action . value , parts [ 1 ]) if parts [ 0 ] == \"shift\" : return ( action . value , f \"shift_ { parts [ 1 ] } \" , parts [ 1 ]) # scroll up & down return ( action . value , parts [ 0 ]) possible_names = _get_names ( event . action ) for name in possible_names : if hasattr ( self , f \"on_ { name } \" ): handle = getattr ( self , f \"on_ { name } \" ) return handle ( event ) return False def handle_key ( self , key : str ) -> bool : \"\"\"Handles a mouse event, returning its success. Args: key: String representation of input string. The `pytermgui.input.keys` object can be used to retrieve special keys. Returns: A boolean describing whether the key was handled. \"\"\" return False and hasattr ( self , key ) def serialize ( self ) -> dict [ str , Any ]: \"\"\"Serializes a widget. The fields looked at are defined `Widget.serialized`. Note that this method is not very commonly used at the moment, so it might not have full functionality in non-nuclear widgets. Returns: Dictionary of widget attributes. The dictionary will always have a `type` field. Any styles are converted into markup strings during serialization, so they can be loaded again in their original form. Example return: ``` { \"type\": \"Label\", \"value\": \"[210 bold]I am a title\", \"parent_align\": 0, ... } ``` \"\"\" fields = self . _serialized_fields out : dict [ str , Any ] = { \"type\" : type ( self ) . __name__ } for key in fields : # Detect styled values if key . startswith ( \"*\" ): style = True key = key [ 1 :] else : style = False value = getattr ( self , key ) # Convert styled value into markup if style : style_call = self . _get_style ( key ) if isinstance ( value , list ): out [ key ] = [ get_markup ( style_call ( char )) for char in value ] else : out [ key ] = get_markup ( style_call ( value )) continue out [ key ] = value # The chars need to be handled separately out [ \"chars\" ] = {} for key , value in self . chars . items (): style_call = self . _get_style ( key ) if isinstance ( value , list ): out [ \"chars\" ][ key ] = [ get_markup ( style_call ( char )) for char in value ] else : out [ \"chars\" ][ key ] = get_markup ( style_call ( value )) return out def copy ( self ) -> Widget : \"\"\"Creates a deep copy of this widget\"\"\" return deepcopy ( self ) def _get_style ( self , key : str ) -> w_styles . DepthlessStyleType : \"\"\"Gets style call from its key. This is analogous to using `self.styles.{key}` Args: key: A key into the widget's style manager. Returns: A `pytermgui.styles.StyleCall` object containing the referenced style. StyleCall objects should only be used internally inside a widget. Raises: KeyError: Style key is invalid. \"\"\" return self . styles [ key ] def _get_char ( self , key : str ) -> w_styles . CharType : \"\"\"Gets character from its key. Args: key: A key into the widget's chars dictionary. Returns: Either a `list[str]` or a simple `str`, depending on the character. Raises: KeyError: Style key is invalid. \"\"\" chars = self . chars [ key ] if isinstance ( chars , str ): if chars . startswith ( \"u:\" ): identifier = \" \" . join ( chars [ 2 :] . split ( \"_\" )) chars = u_lookup ( identifier ) return chars return chars . copy () def get_lines ( self ) -> list [ str ]: \"\"\"Gets lines representing this widget. These lines have to be equal to the widget in length. All widgets must provide this method. Make sure to keep it performant, as it will be called very often, often multiple times per WindowManager frame. Any longer actions should be done outside of this method, and only their result should be looked up here. Returns: Nothing by default. Raises: NotImplementedError: As this method is required for **all** widgets, not having it defined will raise NotImplementedError. \"\"\" raise NotImplementedError ( f \"get_lines() is not defined for type { type ( self ) } .\" ) def bind ( self , key : str , action : BoundCallback , description : Optional [ str ] = None ) -> None : \"\"\"Binds an action to a keypress. This function is only called by implementations above this layer. To use this functionality use `pytermgui.window_manager.WindowManager`, or write your own custom layer. Special keys: - keys.ANY_KEY: Any and all keypresses execute this binding. - keys.MouseAction: Any and all mouse inputs execute this binding. Args: key: The key that the action will be bound to. action: The action executed when the key is pressed. description: An optional description for this binding. It is not really used anywhere, but you can provide a helper menu and display them. \"\"\" if description is None : description = f \"Binding of { key } to { action } \" self . _bindings [ key ] = ( action , description ) def unbind ( self , key : str ) -> None : \"\"\"Unbinds the given key.\"\"\" del self . _bindings [ key ] def execute_binding ( self , key : Any , ignore_any : bool = False ) -> bool : \"\"\"Executes a binding belonging to key, when present. Use this method inside custom widget `handle_keys` methods, or to run a callback without its corresponding key having been pressed. Args: key: Usually a string, indexing into the `_bindings` dictionary. These are the same strings as defined in `Widget.bind`. ignore_any: If set, `keys.ANY_KEY` bindings will not be executed. Returns: True if the binding was found, False otherwise. Bindings will always be executed if they are found. \"\"\" # Execute special binding if not ignore_any and keys . ANY_KEY in self . _bindings : method , _ = self . _bindings [ keys . ANY_KEY ] method ( self , key ) if key in self . _bindings : method , _ = self . _bindings [ key ] method ( self , key ) return True return False def select ( self , index : int | None = None ) -> None : \"\"\"Selects a part of this Widget. Args: index: The index to select. Raises: TypeError: This widget has no selectables, i.e. widget.is_selectable == False. \"\"\" if not self . is_selectable : raise TypeError ( f \"Object of type { type ( self ) } has no selectables.\" ) if index is not None : index = min ( max ( 0 , index ), self . selectables_length - 1 ) self . selected_index = index def print ( self ) -> None : \"\"\"Prints this widget\"\"\" for line in self . get_lines (): print ( line ) def debug ( self ) -> str : \"\"\"Returns identifiable information about this widget. This method is used to easily differentiate between widgets. By default, all widget's __repr__ method is an alias to this. The signature of each widget is used to generate the return value. Returns: A string almost exactly matching the line of code that could have defined the widget. Example return: ``` Container(Label(value=\"This is a label\", padding=0), Button(label=\"This is a button\", padding=0), **attrs) ``` \"\"\" constructor = \"(\" for name in signature ( getattr ( self , \"__init__\" )) . parameters : current = \"\" if name == \"attrs\" : current += \"**attrs\" continue if len ( constructor ) > 1 : current += \", \" current += name attr = getattr ( self , name , None ) if attr is None : continue current += \"=\" if isinstance ( attr , str ): current += f '\" { attr } \"' else : current += str ( attr ) constructor += current constructor += \")\" return type ( self ) . __name__ + constructor","title":"Widget"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.keys","text":"Groups of keys that are used in handle_key","title":"keys"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.parent_align","text":"pytermgui.enums.HorizontalAlignment to align widget by","title":"parent_align"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.serialized","text":"Fields of widget that shall be serialized by pytermgui.serializer.Serializer","title":"serialized"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.size_policy","text":"pytermgui.enums.SizePolicy to set widget's width according to","title":"size_policy"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.__fancy_repr__","text":"Yields the repr of this object, then a preview of it. Source code in pytermgui/widgets/base.py 159 160 161 162 163 164 165 166 167 def __fancy_repr__ ( self ) -> Generator [ FancyYield , None , None ]: \"\"\"Yields the repr of this object, then a preview of it.\"\"\" yield self . debug () yield \" \\n\\n \" yield { \"text\" : \" \\n \" . join (( line + reset () for line in self . get_lines ())), \"highlight\" : False , }","title":"__fancy_repr__()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.__init__","text":"Initialize object Source code in pytermgui/widgets/base.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def __init__ ( self , ** attrs : Any ) -> None : \"\"\"Initialize object\"\"\" self . set_style = lambda key , value : _set_obj_or_cls_style ( self , key , value ) self . set_char = lambda key , value : _set_obj_or_cls_char ( self , key , value ) self . width = 1 self . height = 1 self . pos = self . terminal . origin self . depth = 0 self . styles = type ( self ) . styles . branch ( self ) self . chars = type ( self ) . chars . copy () self . parent : Widget | None = None self . selected_index : int | None = None self . _selectables_length = 0 self . _id : Optional [ str ] = None self . _serialized_fields = type ( self ) . serialized self . _bindings : dict [ str | Type [ MouseEvent ], tuple [ BoundCallback , str ]] = {} self . _relative_width : float | None = None self . _previous_state : tuple [ tuple [ int , int ], list [ str ]] | None = None self . positioned_line_buffer : list [ tuple [ tuple [ int , int ], str ]] = [] for attr , value in attrs . items (): setattr ( self , attr , value )","title":"__init__()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.__iter__","text":"Return self for iteration Source code in pytermgui/widgets/base.py 169 170 171 172 def __iter__ ( self ) -> Iterator [ Widget ]: \"\"\"Return self for iteration\"\"\" yield self","title":"__iter__()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.__repr__","text":"Return repr string of this widget. Returns: Type Description str Whatever this widget's debug method gives. Source code in pytermgui/widgets/base.py 150 151 152 153 154 155 156 157 def __repr__ ( self ) -> str : \"\"\"Return repr string of this widget. Returns: Whatever this widget's `debug` method gives. \"\"\" return self . debug ()","title":"__repr__()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.bind","text":"Binds an action to a keypress. This function is only called by implementations above this layer. To use this functionality use pytermgui.window_manager.WindowManager , or write your own custom layer. Special keys: - keys.ANY_KEY: Any and all keypresses execute this binding. - keys.MouseAction: Any and all mouse inputs execute this binding. Parameters: Name Type Description Default key str The key that the action will be bound to. required action BoundCallback The action executed when the key is pressed. required description Optional [ str ] An optional description for this binding. It is not really used anywhere, but you can provide a helper menu and display them. None Source code in pytermgui/widgets/base.py 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 def bind ( self , key : str , action : BoundCallback , description : Optional [ str ] = None ) -> None : \"\"\"Binds an action to a keypress. This function is only called by implementations above this layer. To use this functionality use `pytermgui.window_manager.WindowManager`, or write your own custom layer. Special keys: - keys.ANY_KEY: Any and all keypresses execute this binding. - keys.MouseAction: Any and all mouse inputs execute this binding. Args: key: The key that the action will be bound to. action: The action executed when the key is pressed. description: An optional description for this binding. It is not really used anywhere, but you can provide a helper menu and display them. \"\"\" if description is None : description = f \"Binding of { key } to { action } \" self . _bindings [ key ] = ( action , description )","title":"bind()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.bindings","text":"Gets a copy of the bindings internal dictionary. Returns: Type Description dict [ str | Type [ MouseEvent ], tuple [ BoundCallback , str ]] A copy of the internal bindings dictionary, such as: dict [ str | Type [ MouseEvent ], tuple [ BoundCallback , str ]] ``` dict [ str | Type [ MouseEvent ], tuple [ BoundCallback , str ]] { \" \": (star_callback, \"This is a callback activated when ' ' is pressed.\") dict [ str | Type [ MouseEvent ], tuple [ BoundCallback , str ]] } dict [ str | Type [ MouseEvent ], tuple [ BoundCallback , str ]] ``` Source code in pytermgui/widgets/base.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 @property def bindings ( self ) -> dict [ str | Type [ MouseEvent ], tuple [ BoundCallback , str ]]: \"\"\"Gets a copy of the bindings internal dictionary. Returns: A copy of the internal bindings dictionary, such as: ``` { \"*\": (star_callback, \"This is a callback activated when '*' is pressed.\") } ``` \"\"\" return self . _bindings . copy ()","title":"bindings()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.contains","text":"Determines whether widget contains pos . Parameters: Name Type Description Default pos tuple [ int , int ] Position to compare. required Returns: Type Description bool Boolean describing whether the position is inside this widget. Source code in pytermgui/widgets/base.py 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 def contains ( self , pos : tuple [ int , int ]) -> bool : \"\"\"Determines whether widget contains `pos`. Args: pos: Position to compare. Returns: Boolean describing whether the position is inside this widget. \"\"\" rect = self . pos , ( self . pos [ 0 ] + self . width , self . pos [ 1 ] + self . height , ) ( left , top ), ( right , bottom ) = rect return left <= pos [ 0 ] < right and top <= pos [ 1 ] < bottom","title":"contains()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.copy","text":"Creates a deep copy of this widget Source code in pytermgui/widgets/base.py 480 481 482 483 def copy ( self ) -> Widget : \"\"\"Creates a deep copy of this widget\"\"\" return deepcopy ( self )","title":"copy()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.debug","text":"Returns identifiable information about this widget. This method is used to easily differentiate between widgets. By default, all widget's repr method is an alias to this. The signature of each widget is used to generate the return value. Returns: Type Description str A string almost exactly matching the line of code that could have defined the widget. str Example return: str ``` str Container(Label(value=\"This is a label\", padding=0), str Button(label=\"This is a button\", padding=0), **attrs) str ``` Source code in pytermgui/widgets/base.py 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 def debug ( self ) -> str : \"\"\"Returns identifiable information about this widget. This method is used to easily differentiate between widgets. By default, all widget's __repr__ method is an alias to this. The signature of each widget is used to generate the return value. Returns: A string almost exactly matching the line of code that could have defined the widget. Example return: ``` Container(Label(value=\"This is a label\", padding=0), Button(label=\"This is a button\", padding=0), **attrs) ``` \"\"\" constructor = \"(\" for name in signature ( getattr ( self , \"__init__\" )) . parameters : current = \"\" if name == \"attrs\" : current += \"**attrs\" continue if len ( constructor ) > 1 : current += \", \" current += name attr = getattr ( self , name , None ) if attr is None : continue current += \"=\" if isinstance ( attr , str ): current += f '\" { attr } \"' else : current += str ( attr ) constructor += current constructor += \")\" return type ( self ) . __name__ + constructor","title":"debug()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.execute_binding","text":"Executes a binding belonging to key, when present. Use this method inside custom widget handle_keys methods, or to run a callback without its corresponding key having been pressed. Parameters: Name Type Description Default key Any Usually a string, indexing into the _bindings dictionary. These are the same strings as defined in Widget.bind . required ignore_any bool If set, keys.ANY_KEY bindings will not be executed. False Returns: Type Description bool True if the binding was found, False otherwise. Bindings will always be executed if they are found. Source code in pytermgui/widgets/base.py 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 def execute_binding ( self , key : Any , ignore_any : bool = False ) -> bool : \"\"\"Executes a binding belonging to key, when present. Use this method inside custom widget `handle_keys` methods, or to run a callback without its corresponding key having been pressed. Args: key: Usually a string, indexing into the `_bindings` dictionary. These are the same strings as defined in `Widget.bind`. ignore_any: If set, `keys.ANY_KEY` bindings will not be executed. Returns: True if the binding was found, False otherwise. Bindings will always be executed if they are found. \"\"\" # Execute special binding if not ignore_any and keys . ANY_KEY in self . _bindings : method , _ = self . _bindings [ keys . ANY_KEY ] method ( self , key ) if key in self . _bindings : method , _ = self . _bindings [ key ] method ( self , key ) return True return False","title":"execute_binding()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.get_change","text":"Determines whether widget lines changed since the last call to this function. Source code in pytermgui/widgets/base.py 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 def get_change ( self ) -> WidgetChange | None : \"\"\"Determines whether widget lines changed since the last call to this function.\"\"\" lines = self . get_lines () if self . _previous_state is None : self . _previous_state = ( self . width , self . height ), lines return WidgetChange . LINES lines = self . get_lines () ( old_width , old_height ), old_lines = self . _previous_state self . _previous_state = ( self . width , self . height ), lines if old_width != self . width and old_height != self . height : return WidgetChange . SIZE if old_width != self . width : return WidgetChange . WIDTH if old_height != self . height : return WidgetChange . HEIGHT if old_lines != lines : return WidgetChange . LINES return None","title":"get_change()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.get_lines","text":"Gets lines representing this widget. These lines have to be equal to the widget in length. All widgets must provide this method. Make sure to keep it performant, as it will be called very often, often multiple times per WindowManager frame. Any longer actions should be done outside of this method, and only their result should be looked up here. Returns: Type Description list [ str ] Nothing by default. Raises: Type Description NotImplementedError As this method is required for all widgets, not having it defined will raise NotImplementedError. Source code in pytermgui/widgets/base.py 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def get_lines ( self ) -> list [ str ]: \"\"\"Gets lines representing this widget. These lines have to be equal to the widget in length. All widgets must provide this method. Make sure to keep it performant, as it will be called very often, often multiple times per WindowManager frame. Any longer actions should be done outside of this method, and only their result should be looked up here. Returns: Nothing by default. Raises: NotImplementedError: As this method is required for **all** widgets, not having it defined will raise NotImplementedError. \"\"\" raise NotImplementedError ( f \"get_lines() is not defined for type { type ( self ) } .\" )","title":"get_lines()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.handle_key","text":"Handles a mouse event, returning its success. Parameters: Name Type Description Default key str String representation of input string. The pytermgui.input.keys object can be used to retrieve special keys. required Returns: Type Description bool A boolean describing whether the key was handled. Source code in pytermgui/widgets/base.py 405 406 407 408 409 410 411 412 413 414 415 416 417 def handle_key ( self , key : str ) -> bool : \"\"\"Handles a mouse event, returning its success. Args: key: String representation of input string. The `pytermgui.input.keys` object can be used to retrieve special keys. Returns: A boolean describing whether the key was handled. \"\"\" return False and hasattr ( self , key )","title":"handle_key()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.handle_mouse","text":"Tries to call the most specific mouse handler function available. This function looks for a set of mouse action handlers. Each handler follows the format on_{event_name} For example, the handler triggered on MouseAction.LEFT_CLICK would be on_left_click . If no handler is found nothing is done. You can also define more general handlers, for example to group left & right clicks you can use on_click , and to catch both up and down scroll you can use on_scroll . General handlers are only used if they are the most specific ones, i.e. there is no \"specific\" handler. Parameters: Name Type Description Default event MouseEvent The event to handle. required Returns: Type Description bool Whether the parent of this widget should treat it as one to \"stick\" events bool to, e.g. to keep sending mouse events to it. One can \"unstick\" a widget by bool returning False in the handler. Source code in pytermgui/widgets/base.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Tries to call the most specific mouse handler function available. This function looks for a set of mouse action handlers. Each handler follows the format on_{event_name} For example, the handler triggered on MouseAction.LEFT_CLICK would be `on_left_click`. If no handler is found nothing is done. You can also define more general handlers, for example to group left & right clicks you can use `on_click`, and to catch both up and down scroll you can use `on_scroll`. General handlers are only used if they are the most specific ones, i.e. there is no \"specific\" handler. Args: event: The event to handle. Returns: Whether the parent of this widget should treat it as one to \"stick\" events to, e.g. to keep sending mouse events to it. One can \"unstick\" a widget by returning False in the handler. \"\"\" def _get_names ( action : MouseAction ) -> tuple [ str , ... ]: if action . value in [ \"hover\" , \"release\" ]: return ( action . value ,) parts = action . value . split ( \"_\" ) # left click & right click if parts [ 0 ] in [ \"left\" , \"right\" ]: return ( action . value , parts [ 1 ]) if parts [ 0 ] == \"shift\" : return ( action . value , f \"shift_ { parts [ 1 ] } \" , parts [ 1 ]) # scroll up & down return ( action . value , parts [ 0 ]) possible_names = _get_names ( event . action ) for name in possible_names : if hasattr ( self , f \"on_ { name } \" ): handle = getattr ( self , f \"on_ { name } \" ) return handle ( event ) return False","title":"handle_mouse()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.id","text":"Gets this widget's id property Returns: Type Description Optional [ str ] The id string if one is present, None otherwise. Source code in pytermgui/widgets/base.py 190 191 192 193 194 195 196 197 198 @property def id ( self ) -> Optional [ str ]: # pylint: disable=invalid-name \"\"\"Gets this widget's id property Returns: The id string if one is present, None otherwise. \"\"\" return self . _id","title":"id()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.is_selectable","text":"Determines whether this widget has any selectables. Returns: Type Description bool A boolean, representing self.selectables_length != 0 . Source code in pytermgui/widgets/base.py 246 247 248 249 250 251 252 253 254 @property def is_selectable ( self ) -> bool : \"\"\"Determines whether this widget has any selectables. Returns: A boolean, representing `self.selectables_length != 0`. \"\"\" return self . selectables_length != 0","title":"is_selectable()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.print","text":"Prints this widget Source code in pytermgui/widgets/base.py 624 625 626 627 628 def print ( self ) -> None : \"\"\"Prints this widget\"\"\" for line in self . get_lines (): print ( line )","title":"print()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.relative_width","text":"Sets this widget's relative width, and changes size_policy to RELATIVE. The value is clamped to 1.0. If a Container holds a width of 30, and it has a subwidget with a relative width of 0.5, it will be resized to 15. Parameters: Name Type Description Default value The multiplier to apply to the parent's width. required Returns: Type Description float | None The current relative_width. Source code in pytermgui/widgets/base.py 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 @property def relative_width ( self ) -> float | None : \"\"\"Sets this widget's relative width, and changes size_policy to RELATIVE. The value is clamped to 1.0. If a Container holds a width of 30, and it has a subwidget with a relative width of 0.5, it will be resized to 15. Args: value: The multiplier to apply to the parent's width. Returns: The current relative_width. \"\"\" return self . _relative_width","title":"relative_width()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.select","text":"Selects a part of this Widget. Parameters: Name Type Description Default index int | None The index to select. None Raises: Type Description TypeError This widget has no selectables, i.e. widget.is_selectable == False. Source code in pytermgui/widgets/base.py 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 def select ( self , index : int | None = None ) -> None : \"\"\"Selects a part of this Widget. Args: index: The index to select. Raises: TypeError: This widget has no selectables, i.e. widget.is_selectable == False. \"\"\" if not self . is_selectable : raise TypeError ( f \"Object of type { type ( self ) } has no selectables.\" ) if index is not None : index = min ( max ( 0 , index ), self . selectables_length - 1 ) self . selected_index = index","title":"select()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.selectables","text":"Gets a list of all selectables within this widget Returns: Type Description list [ tuple [ Widget , int ]] A list of tuples. In the default implementation this will be list [ tuple [ Widget , int ]] a list of one tuple, containing a reference to self , as well list [ tuple [ Widget , int ]] as the lowest index, 0. Source code in pytermgui/widgets/base.py 234 235 236 237 238 239 240 241 242 243 244 @property def selectables ( self ) -> list [ tuple [ Widget , int ]]: \"\"\"Gets a list of all selectables within this widget Returns: A list of tuples. In the default implementation this will be a list of one tuple, containing a reference to `self`, as well as the lowest index, 0. \"\"\" return [( self , 0 )]","title":"selectables()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.selectables_length","text":"Gets how many selectables this widget contains. Returns: Type Description int An integer describing the amount of selectables in this widget. Source code in pytermgui/widgets/base.py 224 225 226 227 228 229 230 231 232 @property def selectables_length ( self ) -> int : \"\"\"Gets how many selectables this widget contains. Returns: An integer describing the amount of selectables in this widget. \"\"\" return self . _selectables_length","title":"selectables_length()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.serialize","text":"Serializes a widget. The fields looked at are defined Widget.serialized . Note that this method is not very commonly used at the moment, so it might not have full functionality in non-nuclear widgets. Returns: Type Description dict [ str , Any ] Dictionary of widget attributes. The dictionary will always dict [ str , Any ] have a type field. Any styles are converted into markup dict [ str , Any ] strings during serialization, so they can be loaded again in dict [ str , Any ] their original form. dict [ str , Any ] Example return: dict [ str , Any ] ``` { \"type\": \"Label\", \"value\": \"[210 bold]I am a title\", \"parent_align\": 0, ... } dict [ str , Any ] ``` Source code in pytermgui/widgets/base.py 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 def serialize ( self ) -> dict [ str , Any ]: \"\"\"Serializes a widget. The fields looked at are defined `Widget.serialized`. Note that this method is not very commonly used at the moment, so it might not have full functionality in non-nuclear widgets. Returns: Dictionary of widget attributes. The dictionary will always have a `type` field. Any styles are converted into markup strings during serialization, so they can be loaded again in their original form. Example return: ``` { \"type\": \"Label\", \"value\": \"[210 bold]I am a title\", \"parent_align\": 0, ... } ``` \"\"\" fields = self . _serialized_fields out : dict [ str , Any ] = { \"type\" : type ( self ) . __name__ } for key in fields : # Detect styled values if key . startswith ( \"*\" ): style = True key = key [ 1 :] else : style = False value = getattr ( self , key ) # Convert styled value into markup if style : style_call = self . _get_style ( key ) if isinstance ( value , list ): out [ key ] = [ get_markup ( style_call ( char )) for char in value ] else : out [ key ] = get_markup ( style_call ( value )) continue out [ key ] = value # The chars need to be handled separately out [ \"chars\" ] = {} for key , value in self . chars . items (): style_call = self . _get_style ( key ) if isinstance ( value , list ): out [ \"chars\" ][ key ] = [ get_markup ( style_call ( char )) for char in value ] else : out [ \"chars\" ][ key ] = get_markup ( style_call ( value )) return out","title":"serialize()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.static_width","text":"Allows for a shorter way of setting a width, and SizePolicy.STATIC. Parameters: Name Type Description Default value The new width integer. required Returns: Type Description int None, as this is setter only. Source code in pytermgui/widgets/base.py 256 257 258 259 260 261 262 263 264 265 266 267 @property def static_width ( self ) -> int : \"\"\"Allows for a shorter way of setting a width, and SizePolicy.STATIC. Args: value: The new width integer. Returns: None, as this is setter only. \"\"\" return None # type: ignore","title":"static_width()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.terminal","text":"Returns the current global terminal instance. Source code in pytermgui/widgets/base.py 301 302 303 304 305 @property def terminal ( self ) -> Terminal : \"\"\"Returns the current global terminal instance.\"\"\" return get_terminal ()","title":"terminal()"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.unbind","text":"Unbinds the given key. Source code in pytermgui/widgets/base.py 573 574 575 576 def unbind ( self , key : str ) -> None : \"\"\"Unbinds the given key.\"\"\" del self . _bindings [ key ]","title":"unbind()"},{"location":"reference/pytermgui/widgets/boxes/","text":"Convenience objects for Container corner & border styles. They can be used as: from pytermgui import Container , boxes boxes . DOUBLE_TOP . set_chars_of ( Container ) c = Container () # this will now use the style chosen Boxes are also settable as a property of pytermgui.widgets.Container , and can be referenced & defined in markup file definitions. For more info, check out pytermgui.file_loaders . Box Class for defining border & corner styles lines should be list[str] of length 3, such as: lines = [ \".---.\" , \"| x |\" , \"`---`\" , ] The length of individual lines is arbitrary, only limitation is that the top & bottom border characters should occur most often in their respective lines. You can set corners to be of any length, their end is calculated by finding the index of the most often occuring character, which is assumed to be the border character. Top & bottom borders are currently limited in length to 1, but sides operate similarly to corners. They are separated by finding the index of the fill char from the start or end. The content char is \"x\" by default, however it can be set to anything else by giving the \"content_char\" construction parameter. As such, this: boxes . Box ( [ \"corner1 ________________ corner2\" , \"xleft ################ rightxx\" , \"corner3 ---------------- corner4\" , ], content_char = \"#\" , ) Will result in: Box ( borders = [ 'xleft ' , '_' , ' rightxx' , '-' ], corners = [ 'corner1 ' , ' corner2' , ' corner4' , 'corner3 ' ] ) Source code in pytermgui/widgets/boxes.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 class Box : \"\"\"Class for defining border & corner styles `lines` should be `list[str]` of length 3, such as: ```python3 lines = [ \".---.\", \"| x |\", \"`---`\", ] ``` The length of individual lines is arbitrary, only limitation is that the top & bottom border characters should occur most often in their respective lines. You can set corners to be of any length, their end is calculated by finding the index of the most often occuring character, which is assumed to be the border character. Top & bottom borders are currently limited in length to 1, but sides operate similarly to corners. They are separated by finding the index of the fill char from the start or end. The content char is \"x\" by default, however it can be set to anything else by giving the \"content_char\" construction parameter. As such, this: ```python3 boxes.Box( [ \"corner1 ________________ corner2\", \"xleft ################ rightxx\", \"corner3 ---------------- corner4\", ], content_char=\"#\", ) ``` Will result in: ```python3 Box( borders=['xleft ', '_', ' rightxx', '-'], corners=['corner1 ', ' corner2', ' corner4', 'corner3 '] ) ``` \"\"\" CharType = Tuple [ str , str , str , str ] def __init__ ( self , lines : list [ str ], content_char : str = \"x\" ): \"\"\"Set instance attributes\"\"\" super () . __init__ () self . content_char = content_char top , _ , bottom = lines top_left , top_right = self . _get_corners ( top ) bottom_left , bottom_right = self . _get_corners ( bottom ) self . borders = list ( self . _get_borders ( lines )) self . corners = [ top_left , top_right , bottom_right , bottom_left , ] def __repr__ ( self ) -> str : \"\"\"Return string of self\"\"\" return self . debug () @staticmethod def _find_mode_char ( line : str ) -> str : \"\"\"Find most often consecutively occuring character in string\"\"\" instances = 0 current_char = \"\" results : list [ tuple [ str , int ]] = [] for char in line : if current_char == char : instances += 1 else : if len ( current_char ) > 0 : results . append (( current_char , instances )) instances = 1 current_char = char results . append (( current_char , instances )) results . sort ( key = lambda item : item [ 1 ]) if len ( results ) == 0 : print ( line , instances , current_char ) return results [ - 1 ][ 0 ] def _get_corners ( self , line : str ) -> tuple [ str , str ]: \"\"\"Get corners from a line\"\"\" mode_char = self . _find_mode_char ( line ) left = line [: line . index ( mode_char )] right = line [ real_length ( line ) - ( line [:: - 1 ] . index ( mode_char )) :] return left , right def _get_borders ( self , lines : list [ str ]) -> tuple [ str , str , str , str ]: \"\"\"Get borders from all lines\"\"\" top , middle , bottom = lines middle_reversed = middle [:: - 1 ] top_border = self . _find_mode_char ( top ) left_border = middle [: middle . index ( self . content_char )] right_border = middle [ real_length ( middle ) - middle_reversed . index ( self . content_char ) : ] bottom_border = self . _find_mode_char ( bottom ) # return top_border, left_border, right_border, bottom_border return left_border , top_border , right_border , bottom_border def set_chars_of ( self , cls_or_obj : WidgetType ) -> WidgetType : \"\"\"Set border & corner chars of cls_or_obj to self values\"\"\" # We cannot import any widgets into here due to cyclic imports, # so we have to \"hack\" around it. if not hasattr ( cls_or_obj , \"set_char\" ): raise NotImplementedError ( f \"Object of type { cls_or_obj } does not support `set_char`\" ) cls_or_obj . set_char ( \"border\" , self . borders ) cls_or_obj . set_char ( \"corner\" , self . corners ) return cls_or_obj def debug ( self ) -> str : \"\"\"Return identifiable information about object\"\"\" return f \"Box(borders= { self . borders } , corners= { self . corners } )\" __init__ ( lines , content_char = 'x' ) Set instance attributes Source code in pytermgui/widgets/boxes.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def __init__ ( self , lines : list [ str ], content_char : str = \"x\" ): \"\"\"Set instance attributes\"\"\" super () . __init__ () self . content_char = content_char top , _ , bottom = lines top_left , top_right = self . _get_corners ( top ) bottom_left , bottom_right = self . _get_corners ( bottom ) self . borders = list ( self . _get_borders ( lines )) self . corners = [ top_left , top_right , bottom_right , bottom_left , ] __repr__ () Return string of self Source code in pytermgui/widgets/boxes.py 95 96 97 98 def __repr__ ( self ) -> str : \"\"\"Return string of self\"\"\" return self . debug () debug () Return identifiable information about object Source code in pytermgui/widgets/boxes.py 167 168 169 170 def debug ( self ) -> str : \"\"\"Return identifiable information about object\"\"\" return f \"Box(borders= { self . borders } , corners= { self . corners } )\" set_chars_of ( cls_or_obj ) Set border & corner chars of cls_or_obj to self values Source code in pytermgui/widgets/boxes.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def set_chars_of ( self , cls_or_obj : WidgetType ) -> WidgetType : \"\"\"Set border & corner chars of cls_or_obj to self values\"\"\" # We cannot import any widgets into here due to cyclic imports, # so we have to \"hack\" around it. if not hasattr ( cls_or_obj , \"set_char\" ): raise NotImplementedError ( f \"Object of type { cls_or_obj } does not support `set_char`\" ) cls_or_obj . set_char ( \"border\" , self . borders ) cls_or_obj . set_char ( \"corner\" , self . corners ) return cls_or_obj","title":"boxes"},{"location":"reference/pytermgui/widgets/boxes/#pytermgui.widgets.boxes.Box","text":"Class for defining border & corner styles lines should be list[str] of length 3, such as: lines = [ \".---.\" , \"| x |\" , \"`---`\" , ] The length of individual lines is arbitrary, only limitation is that the top & bottom border characters should occur most often in their respective lines. You can set corners to be of any length, their end is calculated by finding the index of the most often occuring character, which is assumed to be the border character. Top & bottom borders are currently limited in length to 1, but sides operate similarly to corners. They are separated by finding the index of the fill char from the start or end. The content char is \"x\" by default, however it can be set to anything else by giving the \"content_char\" construction parameter. As such, this: boxes . Box ( [ \"corner1 ________________ corner2\" , \"xleft ################ rightxx\" , \"corner3 ---------------- corner4\" , ], content_char = \"#\" , ) Will result in: Box ( borders = [ 'xleft ' , '_' , ' rightxx' , '-' ], corners = [ 'corner1 ' , ' corner2' , ' corner4' , 'corner3 ' ] ) Source code in pytermgui/widgets/boxes.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 class Box : \"\"\"Class for defining border & corner styles `lines` should be `list[str]` of length 3, such as: ```python3 lines = [ \".---.\", \"| x |\", \"`---`\", ] ``` The length of individual lines is arbitrary, only limitation is that the top & bottom border characters should occur most often in their respective lines. You can set corners to be of any length, their end is calculated by finding the index of the most often occuring character, which is assumed to be the border character. Top & bottom borders are currently limited in length to 1, but sides operate similarly to corners. They are separated by finding the index of the fill char from the start or end. The content char is \"x\" by default, however it can be set to anything else by giving the \"content_char\" construction parameter. As such, this: ```python3 boxes.Box( [ \"corner1 ________________ corner2\", \"xleft ################ rightxx\", \"corner3 ---------------- corner4\", ], content_char=\"#\", ) ``` Will result in: ```python3 Box( borders=['xleft ', '_', ' rightxx', '-'], corners=['corner1 ', ' corner2', ' corner4', 'corner3 '] ) ``` \"\"\" CharType = Tuple [ str , str , str , str ] def __init__ ( self , lines : list [ str ], content_char : str = \"x\" ): \"\"\"Set instance attributes\"\"\" super () . __init__ () self . content_char = content_char top , _ , bottom = lines top_left , top_right = self . _get_corners ( top ) bottom_left , bottom_right = self . _get_corners ( bottom ) self . borders = list ( self . _get_borders ( lines )) self . corners = [ top_left , top_right , bottom_right , bottom_left , ] def __repr__ ( self ) -> str : \"\"\"Return string of self\"\"\" return self . debug () @staticmethod def _find_mode_char ( line : str ) -> str : \"\"\"Find most often consecutively occuring character in string\"\"\" instances = 0 current_char = \"\" results : list [ tuple [ str , int ]] = [] for char in line : if current_char == char : instances += 1 else : if len ( current_char ) > 0 : results . append (( current_char , instances )) instances = 1 current_char = char results . append (( current_char , instances )) results . sort ( key = lambda item : item [ 1 ]) if len ( results ) == 0 : print ( line , instances , current_char ) return results [ - 1 ][ 0 ] def _get_corners ( self , line : str ) -> tuple [ str , str ]: \"\"\"Get corners from a line\"\"\" mode_char = self . _find_mode_char ( line ) left = line [: line . index ( mode_char )] right = line [ real_length ( line ) - ( line [:: - 1 ] . index ( mode_char )) :] return left , right def _get_borders ( self , lines : list [ str ]) -> tuple [ str , str , str , str ]: \"\"\"Get borders from all lines\"\"\" top , middle , bottom = lines middle_reversed = middle [:: - 1 ] top_border = self . _find_mode_char ( top ) left_border = middle [: middle . index ( self . content_char )] right_border = middle [ real_length ( middle ) - middle_reversed . index ( self . content_char ) : ] bottom_border = self . _find_mode_char ( bottom ) # return top_border, left_border, right_border, bottom_border return left_border , top_border , right_border , bottom_border def set_chars_of ( self , cls_or_obj : WidgetType ) -> WidgetType : \"\"\"Set border & corner chars of cls_or_obj to self values\"\"\" # We cannot import any widgets into here due to cyclic imports, # so we have to \"hack\" around it. if not hasattr ( cls_or_obj , \"set_char\" ): raise NotImplementedError ( f \"Object of type { cls_or_obj } does not support `set_char`\" ) cls_or_obj . set_char ( \"border\" , self . borders ) cls_or_obj . set_char ( \"corner\" , self . corners ) return cls_or_obj def debug ( self ) -> str : \"\"\"Return identifiable information about object\"\"\" return f \"Box(borders= { self . borders } , corners= { self . corners } )\"","title":"Box"},{"location":"reference/pytermgui/widgets/boxes/#pytermgui.widgets.boxes.Box.__init__","text":"Set instance attributes Source code in pytermgui/widgets/boxes.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def __init__ ( self , lines : list [ str ], content_char : str = \"x\" ): \"\"\"Set instance attributes\"\"\" super () . __init__ () self . content_char = content_char top , _ , bottom = lines top_left , top_right = self . _get_corners ( top ) bottom_left , bottom_right = self . _get_corners ( bottom ) self . borders = list ( self . _get_borders ( lines )) self . corners = [ top_left , top_right , bottom_right , bottom_left , ]","title":"__init__()"},{"location":"reference/pytermgui/widgets/boxes/#pytermgui.widgets.boxes.Box.__repr__","text":"Return string of self Source code in pytermgui/widgets/boxes.py 95 96 97 98 def __repr__ ( self ) -> str : \"\"\"Return string of self\"\"\" return self . debug ()","title":"__repr__()"},{"location":"reference/pytermgui/widgets/boxes/#pytermgui.widgets.boxes.Box.debug","text":"Return identifiable information about object Source code in pytermgui/widgets/boxes.py 167 168 169 170 def debug ( self ) -> str : \"\"\"Return identifiable information about object\"\"\" return f \"Box(borders= { self . borders } , corners= { self . corners } )\"","title":"debug()"},{"location":"reference/pytermgui/widgets/boxes/#pytermgui.widgets.boxes.Box.set_chars_of","text":"Set border & corner chars of cls_or_obj to self values Source code in pytermgui/widgets/boxes.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def set_chars_of ( self , cls_or_obj : WidgetType ) -> WidgetType : \"\"\"Set border & corner chars of cls_or_obj to self values\"\"\" # We cannot import any widgets into here due to cyclic imports, # so we have to \"hack\" around it. if not hasattr ( cls_or_obj , \"set_char\" ): raise NotImplementedError ( f \"Object of type { cls_or_obj } does not support `set_char`\" ) cls_or_obj . set_char ( \"border\" , self . borders ) cls_or_obj . set_char ( \"corner\" , self . corners ) return cls_or_obj","title":"set_chars_of()"},{"location":"reference/pytermgui/widgets/button/","text":"This module contains the Button class. Button Bases: Widget A simple Widget representing a mouse-clickable button Source code in pytermgui/widgets/button.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 class Button ( Widget ): \"\"\"A simple Widget representing a mouse-clickable button\"\"\" styles = w_styles . StyleManager ( label = \"@surface dim #auto\" , highlight = \"@surface+1 dim #auto\" , _current = None , ) chars : dict [ str , w_styles . CharType ] = { \"delimiter\" : [ \"[ \" , \" ]\" ]} def __init__ ( self , label : str = \"Button\" , onclick : Optional [ Callable [[ Button ], Any ]] = None , padding : int = 0 , centered : bool = False , ** attrs : Any , ) -> None : \"\"\"Initialize object\"\"\" super () . __init__ ( ** attrs ) self . _selectables_length = 1 if not any ( \"width\" in attr for attr in attrs ): self . width = len ( label ) self . label = label self . onclick = onclick self . padding = padding self . centered = centered self . styles [ \"_current\" ] = self . styles . label def on_hover ( self , _ ) -> bool : \"\"\"Sets highlight style when hovering.\"\"\" self . styles [ \"_current\" ] = self . styles . highlight return False def on_release ( self , _ ) -> bool : \"\"\"Sets normal style when no longer hovering.\"\"\" self . styles [ \"_current\" ] = self . styles . label return False def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Handles a mouse event\"\"\" if super () . handle_mouse ( event ): return True if event . action == MouseAction . LEFT_CLICK : self . selected_index = 0 if self . onclick is not None : self . onclick ( self ) return True if event . action == MouseAction . RELEASE : self . selected_index = None return True return False def handle_key ( self , key : str ) -> bool : \"\"\"Handles a keypress\"\"\" if key == keys . RETURN and self . onclick is not None : self . onclick ( self ) return True return False def get_lines ( self ) -> list [ str ]: \"\"\"Get object lines\"\"\" delimiters = self . _get_char ( \"delimiter\" ) assert isinstance ( delimiters , list ) and len ( delimiters ) == 2 left , right = delimiters left = left . replace ( \"[\" , r \"\\[\" ) delim_len = real_length ( left + right ) label = self . label if len ( self . label ) > self . width : sli = max ( self . width - delim_len - 3 - self . padding , 0 ) label = self . label [: sli ] + \"...\" elif self . centered : label = self . label . center ( self . width ) if self . selected_index is None : style = self . styles [ \"_current\" ] else : style = self . styles . highlight line = style ( left + label + right + self . padding * \" \" ) return [ line ] __init__ ( label = 'Button' , onclick = None , padding = 0 , centered = False , attrs ) Initialize object Source code in pytermgui/widgets/button.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __init__ ( self , label : str = \"Button\" , onclick : Optional [ Callable [[ Button ], Any ]] = None , padding : int = 0 , centered : bool = False , ** attrs : Any , ) -> None : \"\"\"Initialize object\"\"\" super () . __init__ ( ** attrs ) self . _selectables_length = 1 if not any ( \"width\" in attr for attr in attrs ): self . width = len ( label ) self . label = label self . onclick = onclick self . padding = padding self . centered = centered self . styles [ \"_current\" ] = self . styles . label get_lines () Get object lines Source code in pytermgui/widgets/button.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def get_lines ( self ) -> list [ str ]: \"\"\"Get object lines\"\"\" delimiters = self . _get_char ( \"delimiter\" ) assert isinstance ( delimiters , list ) and len ( delimiters ) == 2 left , right = delimiters left = left . replace ( \"[\" , r \"\\[\" ) delim_len = real_length ( left + right ) label = self . label if len ( self . label ) > self . width : sli = max ( self . width - delim_len - 3 - self . padding , 0 ) label = self . label [: sli ] + \"...\" elif self . centered : label = self . label . center ( self . width ) if self . selected_index is None : style = self . styles [ \"_current\" ] else : style = self . styles . highlight line = style ( left + label + right + self . padding * \" \" ) return [ line ] handle_key ( key ) Handles a keypress Source code in pytermgui/widgets/button.py 80 81 82 83 84 85 86 87 def handle_key ( self , key : str ) -> bool : \"\"\"Handles a keypress\"\"\" if key == keys . RETURN and self . onclick is not None : self . onclick ( self ) return True return False handle_mouse ( event ) Handles a mouse event Source code in pytermgui/widgets/button.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Handles a mouse event\"\"\" if super () . handle_mouse ( event ): return True if event . action == MouseAction . LEFT_CLICK : self . selected_index = 0 if self . onclick is not None : self . onclick ( self ) return True if event . action == MouseAction . RELEASE : self . selected_index = None return True return False on_hover ( _ ) Sets highlight style when hovering. Source code in pytermgui/widgets/button.py 49 50 51 52 53 def on_hover ( self , _ ) -> bool : \"\"\"Sets highlight style when hovering.\"\"\" self . styles [ \"_current\" ] = self . styles . highlight return False on_release ( _ ) Sets normal style when no longer hovering. Source code in pytermgui/widgets/button.py 55 56 57 58 59 def on_release ( self , _ ) -> bool : \"\"\"Sets normal style when no longer hovering.\"\"\" self . styles [ \"_current\" ] = self . styles . label return False","title":"button"},{"location":"reference/pytermgui/widgets/button/#pytermgui.widgets.button.Button","text":"Bases: Widget A simple Widget representing a mouse-clickable button Source code in pytermgui/widgets/button.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 class Button ( Widget ): \"\"\"A simple Widget representing a mouse-clickable button\"\"\" styles = w_styles . StyleManager ( label = \"@surface dim #auto\" , highlight = \"@surface+1 dim #auto\" , _current = None , ) chars : dict [ str , w_styles . CharType ] = { \"delimiter\" : [ \"[ \" , \" ]\" ]} def __init__ ( self , label : str = \"Button\" , onclick : Optional [ Callable [[ Button ], Any ]] = None , padding : int = 0 , centered : bool = False , ** attrs : Any , ) -> None : \"\"\"Initialize object\"\"\" super () . __init__ ( ** attrs ) self . _selectables_length = 1 if not any ( \"width\" in attr for attr in attrs ): self . width = len ( label ) self . label = label self . onclick = onclick self . padding = padding self . centered = centered self . styles [ \"_current\" ] = self . styles . label def on_hover ( self , _ ) -> bool : \"\"\"Sets highlight style when hovering.\"\"\" self . styles [ \"_current\" ] = self . styles . highlight return False def on_release ( self , _ ) -> bool : \"\"\"Sets normal style when no longer hovering.\"\"\" self . styles [ \"_current\" ] = self . styles . label return False def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Handles a mouse event\"\"\" if super () . handle_mouse ( event ): return True if event . action == MouseAction . LEFT_CLICK : self . selected_index = 0 if self . onclick is not None : self . onclick ( self ) return True if event . action == MouseAction . RELEASE : self . selected_index = None return True return False def handle_key ( self , key : str ) -> bool : \"\"\"Handles a keypress\"\"\" if key == keys . RETURN and self . onclick is not None : self . onclick ( self ) return True return False def get_lines ( self ) -> list [ str ]: \"\"\"Get object lines\"\"\" delimiters = self . _get_char ( \"delimiter\" ) assert isinstance ( delimiters , list ) and len ( delimiters ) == 2 left , right = delimiters left = left . replace ( \"[\" , r \"\\[\" ) delim_len = real_length ( left + right ) label = self . label if len ( self . label ) > self . width : sli = max ( self . width - delim_len - 3 - self . padding , 0 ) label = self . label [: sli ] + \"...\" elif self . centered : label = self . label . center ( self . width ) if self . selected_index is None : style = self . styles [ \"_current\" ] else : style = self . styles . highlight line = style ( left + label + right + self . padding * \" \" ) return [ line ]","title":"Button"},{"location":"reference/pytermgui/widgets/button/#pytermgui.widgets.button.Button.__init__","text":"Initialize object Source code in pytermgui/widgets/button.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __init__ ( self , label : str = \"Button\" , onclick : Optional [ Callable [[ Button ], Any ]] = None , padding : int = 0 , centered : bool = False , ** attrs : Any , ) -> None : \"\"\"Initialize object\"\"\" super () . __init__ ( ** attrs ) self . _selectables_length = 1 if not any ( \"width\" in attr for attr in attrs ): self . width = len ( label ) self . label = label self . onclick = onclick self . padding = padding self . centered = centered self . styles [ \"_current\" ] = self . styles . label","title":"__init__()"},{"location":"reference/pytermgui/widgets/button/#pytermgui.widgets.button.Button.get_lines","text":"Get object lines Source code in pytermgui/widgets/button.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def get_lines ( self ) -> list [ str ]: \"\"\"Get object lines\"\"\" delimiters = self . _get_char ( \"delimiter\" ) assert isinstance ( delimiters , list ) and len ( delimiters ) == 2 left , right = delimiters left = left . replace ( \"[\" , r \"\\[\" ) delim_len = real_length ( left + right ) label = self . label if len ( self . label ) > self . width : sli = max ( self . width - delim_len - 3 - self . padding , 0 ) label = self . label [: sli ] + \"...\" elif self . centered : label = self . label . center ( self . width ) if self . selected_index is None : style = self . styles [ \"_current\" ] else : style = self . styles . highlight line = style ( left + label + right + self . padding * \" \" ) return [ line ]","title":"get_lines()"},{"location":"reference/pytermgui/widgets/button/#pytermgui.widgets.button.Button.handle_key","text":"Handles a keypress Source code in pytermgui/widgets/button.py 80 81 82 83 84 85 86 87 def handle_key ( self , key : str ) -> bool : \"\"\"Handles a keypress\"\"\" if key == keys . RETURN and self . onclick is not None : self . onclick ( self ) return True return False","title":"handle_key()"},{"location":"reference/pytermgui/widgets/button/#pytermgui.widgets.button.Button.handle_mouse","text":"Handles a mouse event Source code in pytermgui/widgets/button.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Handles a mouse event\"\"\" if super () . handle_mouse ( event ): return True if event . action == MouseAction . LEFT_CLICK : self . selected_index = 0 if self . onclick is not None : self . onclick ( self ) return True if event . action == MouseAction . RELEASE : self . selected_index = None return True return False","title":"handle_mouse()"},{"location":"reference/pytermgui/widgets/button/#pytermgui.widgets.button.Button.on_hover","text":"Sets highlight style when hovering. Source code in pytermgui/widgets/button.py 49 50 51 52 53 def on_hover ( self , _ ) -> bool : \"\"\"Sets highlight style when hovering.\"\"\" self . styles [ \"_current\" ] = self . styles . highlight return False","title":"on_hover()"},{"location":"reference/pytermgui/widgets/button/#pytermgui.widgets.button.Button.on_release","text":"Sets normal style when no longer hovering. Source code in pytermgui/widgets/button.py 55 56 57 58 59 def on_release ( self , _ ) -> bool : \"\"\"Sets normal style when no longer hovering.\"\"\" self . styles [ \"_current\" ] = self . styles . label return False","title":"on_release()"},{"location":"reference/pytermgui/widgets/checkbox/","text":"This module contains the Checkbox class. Checkbox Bases: Button A simple checkbox Source code in pytermgui/widgets/checkbox.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class Checkbox ( Button ): \"\"\"A simple checkbox\"\"\" chars = { ** Button . chars , ** { \"delimiter\" : [ \"[\" , \"]\" ], \"checked\" : \"X\" , \"unchecked\" : \" \" }, } def __init__ ( self , callback : Callable [[ Any ], Any ] | None = None , checked : bool = False , ** attrs : Any , ) -> None : \"\"\"Initialize object\"\"\" unchecked = self . _get_char ( \"unchecked\" ) assert isinstance ( unchecked , str ) super () . __init__ ( unchecked , onclick = self . toggle , ** attrs ) self . callback = None self . checked = False if self . checked != checked : self . toggle ( run_callback = False ) self . callback = callback def _run_callback ( self ) -> None : \"\"\"Run the checkbox callback with the new checked flag as its argument\"\"\" if self . callback is not None : self . callback ( self . checked ) def toggle ( self , * _ : Any , run_callback : bool = True ) -> None : \"\"\"Toggle state\"\"\" chars = self . _get_char ( \"checked\" ), self . _get_char ( \"unchecked\" ) assert isinstance ( chars [ 0 ], str ) and isinstance ( chars [ 1 ], str ) self . checked ^= True if self . checked : self . label = chars [ 0 ] else : self . label = chars [ 1 ] self . get_lines () if run_callback : self . _run_callback () __init__ ( callback = None , checked = False , attrs ) Initialize object Source code in pytermgui/widgets/checkbox.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , callback : Callable [[ Any ], Any ] | None = None , checked : bool = False , ** attrs : Any , ) -> None : \"\"\"Initialize object\"\"\" unchecked = self . _get_char ( \"unchecked\" ) assert isinstance ( unchecked , str ) super () . __init__ ( unchecked , onclick = self . toggle , ** attrs ) self . callback = None self . checked = False if self . checked != checked : self . toggle ( run_callback = False ) self . callback = callback toggle ( _ , run_callback = True ) Toggle state Source code in pytermgui/widgets/checkbox.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def toggle ( self , * _ : Any , run_callback : bool = True ) -> None : \"\"\"Toggle state\"\"\" chars = self . _get_char ( \"checked\" ), self . _get_char ( \"unchecked\" ) assert isinstance ( chars [ 0 ], str ) and isinstance ( chars [ 1 ], str ) self . checked ^= True if self . checked : self . label = chars [ 0 ] else : self . label = chars [ 1 ] self . get_lines () if run_callback : self . _run_callback ()","title":"checkbox"},{"location":"reference/pytermgui/widgets/checkbox/#pytermgui.widgets.checkbox.Checkbox","text":"Bases: Button A simple checkbox Source code in pytermgui/widgets/checkbox.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class Checkbox ( Button ): \"\"\"A simple checkbox\"\"\" chars = { ** Button . chars , ** { \"delimiter\" : [ \"[\" , \"]\" ], \"checked\" : \"X\" , \"unchecked\" : \" \" }, } def __init__ ( self , callback : Callable [[ Any ], Any ] | None = None , checked : bool = False , ** attrs : Any , ) -> None : \"\"\"Initialize object\"\"\" unchecked = self . _get_char ( \"unchecked\" ) assert isinstance ( unchecked , str ) super () . __init__ ( unchecked , onclick = self . toggle , ** attrs ) self . callback = None self . checked = False if self . checked != checked : self . toggle ( run_callback = False ) self . callback = callback def _run_callback ( self ) -> None : \"\"\"Run the checkbox callback with the new checked flag as its argument\"\"\" if self . callback is not None : self . callback ( self . checked ) def toggle ( self , * _ : Any , run_callback : bool = True ) -> None : \"\"\"Toggle state\"\"\" chars = self . _get_char ( \"checked\" ), self . _get_char ( \"unchecked\" ) assert isinstance ( chars [ 0 ], str ) and isinstance ( chars [ 1 ], str ) self . checked ^= True if self . checked : self . label = chars [ 0 ] else : self . label = chars [ 1 ] self . get_lines () if run_callback : self . _run_callback ()","title":"Checkbox"},{"location":"reference/pytermgui/widgets/checkbox/#pytermgui.widgets.checkbox.Checkbox.__init__","text":"Initialize object Source code in pytermgui/widgets/checkbox.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , callback : Callable [[ Any ], Any ] | None = None , checked : bool = False , ** attrs : Any , ) -> None : \"\"\"Initialize object\"\"\" unchecked = self . _get_char ( \"unchecked\" ) assert isinstance ( unchecked , str ) super () . __init__ ( unchecked , onclick = self . toggle , ** attrs ) self . callback = None self . checked = False if self . checked != checked : self . toggle ( run_callback = False ) self . callback = callback","title":"__init__()"},{"location":"reference/pytermgui/widgets/checkbox/#pytermgui.widgets.checkbox.Checkbox.toggle","text":"Toggle state Source code in pytermgui/widgets/checkbox.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def toggle ( self , * _ : Any , run_callback : bool = True ) -> None : \"\"\"Toggle state\"\"\" chars = self . _get_char ( \"checked\" ), self . _get_char ( \"unchecked\" ) assert isinstance ( chars [ 0 ], str ) and isinstance ( chars [ 1 ], str ) self . checked ^= True if self . checked : self . label = chars [ 0 ] else : self . label = chars [ 1 ] self . get_lines () if run_callback : self . _run_callback ()","title":"toggle()"},{"location":"reference/pytermgui/widgets/collapsible/","text":"The Collapsible widget type. Collapsible Bases: Container A collapsible section of UI. Source code in pytermgui/widgets/collapsible.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 class Collapsible ( Container ): \"\"\"A collapsible section of UI.\"\"\" def __init__ ( self , label : str , * items : Any , keyboard : bool = False , ** attrs : Any ) -> None : \"\"\"Initializes the widget. Args: label: The label for the trigger toggle. *items: The items that will be hidden when the object is collapsed. keyboard: If set, the first character of the label will be used as a `CTRL_` binding to toggle the object. \"\"\" if keyboard : bind = label [ 0 ] self . trigger = Toggle ( ( f \"\u25b6 ( { bind } ) { label [ 1 :] } \" , f \"\u25bc ( { bind } ) { label [ 1 :] } \" ), lambda * _ : self . toggle (), ) else : self . trigger = Toggle ( ( f \"\u25b6 { label } \" , f \"\u25bc { label } \" ), lambda * _ : self . toggle () ) super () . __init__ ( self . trigger , * items , box = \"EMPTY\" , ** attrs ) if keyboard : self . bind ( getattr ( keys , f \"CTRL_ { bind } \" ), lambda * _ : self . trigger . toggle (), \"Open dropdown\" , ) self . collapsed_height = 1 self . overflow = Overflow . HIDE self . height = self . collapsed_height self . _is_expanded = False def toggle ( self ) -> Collapsible : \"\"\"Toggles expanded state. Returns: This object. \"\"\" if self . trigger . checked != self . _is_expanded : self . trigger . toggle ( run_callback = False ) self . _is_expanded = not self . _is_expanded if self . _is_expanded : self . overflow = Overflow . RESIZE else : self . overflow = Overflow . HIDE self . height = self . collapsed_height return self def collapse ( self ) -> Collapsible : \"\"\"Collapses the dropdown. Does nothing if already collapsed. Returns: This object. \"\"\" if self . _is_expanded : self . toggle () return self def expand ( self ) -> Collapsible : \"\"\"Expands the dropdown. Does nothing if already expanded. Returns: This object. \"\"\" if not self . _is_expanded : self . toggle () return self __init__ ( label , items , keyboard = False , attrs ) Initializes the widget. Parameters: Name Type Description Default label str The label for the trigger toggle. required *items Any The items that will be hidden when the object is collapsed. () keyboard bool If set, the first character of the label will be used as a CTRL_ binding to toggle the object. False Source code in pytermgui/widgets/collapsible.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def __init__ ( self , label : str , * items : Any , keyboard : bool = False , ** attrs : Any ) -> None : \"\"\"Initializes the widget. Args: label: The label for the trigger toggle. *items: The items that will be hidden when the object is collapsed. keyboard: If set, the first character of the label will be used as a `CTRL_` binding to toggle the object. \"\"\" if keyboard : bind = label [ 0 ] self . trigger = Toggle ( ( f \"\u25b6 ( { bind } ) { label [ 1 :] } \" , f \"\u25bc ( { bind } ) { label [ 1 :] } \" ), lambda * _ : self . toggle (), ) else : self . trigger = Toggle ( ( f \"\u25b6 { label } \" , f \"\u25bc { label } \" ), lambda * _ : self . toggle () ) super () . __init__ ( self . trigger , * items , box = \"EMPTY\" , ** attrs ) if keyboard : self . bind ( getattr ( keys , f \"CTRL_ { bind } \" ), lambda * _ : self . trigger . toggle (), \"Open dropdown\" , ) self . collapsed_height = 1 self . overflow = Overflow . HIDE self . height = self . collapsed_height self . _is_expanded = False collapse () Collapses the dropdown. Does nothing if already collapsed. Returns: Type Description Collapsible This object. Source code in pytermgui/widgets/collapsible.py 76 77 78 79 80 81 82 83 84 85 86 87 88 def collapse ( self ) -> Collapsible : \"\"\"Collapses the dropdown. Does nothing if already collapsed. Returns: This object. \"\"\" if self . _is_expanded : self . toggle () return self expand () Expands the dropdown. Does nothing if already expanded. Returns: Type Description Collapsible This object. Source code in pytermgui/widgets/collapsible.py 90 91 92 93 94 95 96 97 98 99 100 101 102 def expand ( self ) -> Collapsible : \"\"\"Expands the dropdown. Does nothing if already expanded. Returns: This object. \"\"\" if not self . _is_expanded : self . toggle () return self toggle () Toggles expanded state. Returns: Type Description Collapsible This object. Source code in pytermgui/widgets/collapsible.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def toggle ( self ) -> Collapsible : \"\"\"Toggles expanded state. Returns: This object. \"\"\" if self . trigger . checked != self . _is_expanded : self . trigger . toggle ( run_callback = False ) self . _is_expanded = not self . _is_expanded if self . _is_expanded : self . overflow = Overflow . RESIZE else : self . overflow = Overflow . HIDE self . height = self . collapsed_height return self","title":"collapsible"},{"location":"reference/pytermgui/widgets/collapsible/#pytermgui.widgets.collapsible.Collapsible","text":"Bases: Container A collapsible section of UI. Source code in pytermgui/widgets/collapsible.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 class Collapsible ( Container ): \"\"\"A collapsible section of UI.\"\"\" def __init__ ( self , label : str , * items : Any , keyboard : bool = False , ** attrs : Any ) -> None : \"\"\"Initializes the widget. Args: label: The label for the trigger toggle. *items: The items that will be hidden when the object is collapsed. keyboard: If set, the first character of the label will be used as a `CTRL_` binding to toggle the object. \"\"\" if keyboard : bind = label [ 0 ] self . trigger = Toggle ( ( f \"\u25b6 ( { bind } ) { label [ 1 :] } \" , f \"\u25bc ( { bind } ) { label [ 1 :] } \" ), lambda * _ : self . toggle (), ) else : self . trigger = Toggle ( ( f \"\u25b6 { label } \" , f \"\u25bc { label } \" ), lambda * _ : self . toggle () ) super () . __init__ ( self . trigger , * items , box = \"EMPTY\" , ** attrs ) if keyboard : self . bind ( getattr ( keys , f \"CTRL_ { bind } \" ), lambda * _ : self . trigger . toggle (), \"Open dropdown\" , ) self . collapsed_height = 1 self . overflow = Overflow . HIDE self . height = self . collapsed_height self . _is_expanded = False def toggle ( self ) -> Collapsible : \"\"\"Toggles expanded state. Returns: This object. \"\"\" if self . trigger . checked != self . _is_expanded : self . trigger . toggle ( run_callback = False ) self . _is_expanded = not self . _is_expanded if self . _is_expanded : self . overflow = Overflow . RESIZE else : self . overflow = Overflow . HIDE self . height = self . collapsed_height return self def collapse ( self ) -> Collapsible : \"\"\"Collapses the dropdown. Does nothing if already collapsed. Returns: This object. \"\"\" if self . _is_expanded : self . toggle () return self def expand ( self ) -> Collapsible : \"\"\"Expands the dropdown. Does nothing if already expanded. Returns: This object. \"\"\" if not self . _is_expanded : self . toggle () return self","title":"Collapsible"},{"location":"reference/pytermgui/widgets/collapsible/#pytermgui.widgets.collapsible.Collapsible.__init__","text":"Initializes the widget. Parameters: Name Type Description Default label str The label for the trigger toggle. required *items Any The items that will be hidden when the object is collapsed. () keyboard bool If set, the first character of the label will be used as a CTRL_ binding to toggle the object. False Source code in pytermgui/widgets/collapsible.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def __init__ ( self , label : str , * items : Any , keyboard : bool = False , ** attrs : Any ) -> None : \"\"\"Initializes the widget. Args: label: The label for the trigger toggle. *items: The items that will be hidden when the object is collapsed. keyboard: If set, the first character of the label will be used as a `CTRL_` binding to toggle the object. \"\"\" if keyboard : bind = label [ 0 ] self . trigger = Toggle ( ( f \"\u25b6 ( { bind } ) { label [ 1 :] } \" , f \"\u25bc ( { bind } ) { label [ 1 :] } \" ), lambda * _ : self . toggle (), ) else : self . trigger = Toggle ( ( f \"\u25b6 { label } \" , f \"\u25bc { label } \" ), lambda * _ : self . toggle () ) super () . __init__ ( self . trigger , * items , box = \"EMPTY\" , ** attrs ) if keyboard : self . bind ( getattr ( keys , f \"CTRL_ { bind } \" ), lambda * _ : self . trigger . toggle (), \"Open dropdown\" , ) self . collapsed_height = 1 self . overflow = Overflow . HIDE self . height = self . collapsed_height self . _is_expanded = False","title":"__init__()"},{"location":"reference/pytermgui/widgets/collapsible/#pytermgui.widgets.collapsible.Collapsible.collapse","text":"Collapses the dropdown. Does nothing if already collapsed. Returns: Type Description Collapsible This object. Source code in pytermgui/widgets/collapsible.py 76 77 78 79 80 81 82 83 84 85 86 87 88 def collapse ( self ) -> Collapsible : \"\"\"Collapses the dropdown. Does nothing if already collapsed. Returns: This object. \"\"\" if self . _is_expanded : self . toggle () return self","title":"collapse()"},{"location":"reference/pytermgui/widgets/collapsible/#pytermgui.widgets.collapsible.Collapsible.expand","text":"Expands the dropdown. Does nothing if already expanded. Returns: Type Description Collapsible This object. Source code in pytermgui/widgets/collapsible.py 90 91 92 93 94 95 96 97 98 99 100 101 102 def expand ( self ) -> Collapsible : \"\"\"Expands the dropdown. Does nothing if already expanded. Returns: This object. \"\"\" if not self . _is_expanded : self . toggle () return self","title":"expand()"},{"location":"reference/pytermgui/widgets/collapsible/#pytermgui.widgets.collapsible.Collapsible.toggle","text":"Toggles expanded state. Returns: Type Description Collapsible This object. Source code in pytermgui/widgets/collapsible.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def toggle ( self ) -> Collapsible : \"\"\"Toggles expanded state. Returns: This object. \"\"\" if self . trigger . checked != self . _is_expanded : self . trigger . toggle ( run_callback = False ) self . _is_expanded = not self . _is_expanded if self . _is_expanded : self . overflow = Overflow . RESIZE else : self . overflow = Overflow . HIDE self . height = self . collapsed_height return self","title":"toggle()"},{"location":"reference/pytermgui/widgets/color_picker/","text":"The module containing the ColorPicker widget, as well as some helpers it needs. To test out the widget, run ptg --color ! ColorPicker Bases: Container A simple ColorPicker widget. This is used to visualize xterm-255 colors. RGB colors are not included here, as it is probably easier to use a web-based picker for those anyways. Source code in pytermgui/widgets/color_picker.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 class ColorPicker ( Container ): \"\"\"A simple ColorPicker widget. This is used to visualize xterm-255 colors. RGB colors are not included here, as it is probably easier to use a web-based picker for those anyways. \"\"\" size_policy = SizePolicy . STATIC def __init__ ( self , show_output : bool = True , ** attrs : Any ) -> None : \"\"\"Initializes a ColorPicker. Attrs: show_output: Decides whether the output Container should be added. If not set, the widget will only display the PixelMatrix of colors. \"\"\" super () . __init__ ( ** attrs ) self . show_output = show_output self . _matrix = PixelMatrix . from_matrix ( _get_xterm_matrix ()) self . width = 72 self . box = boxes . EMPTY self . _add_widget ( self . _matrix , run_get_lines = False ) self . chosen = Joiner () self . _output = Container ( self . chosen , \"\" , \"\" , \"\" ) if self . show_output : self . _add_widget ( self . _output ) @property def selectables_length ( self ) -> int : \"\"\"Returns either the button count or 1.\"\"\" return max ( super () . selectables_length , 1 ) def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Handles mouse events. On hover, the widget will display the currently hovered color and some testing text. On click, it will add a _FadeInButton for the currently hovered color. Args: event: The event to handle. \"\"\" if super () . handle_mouse ( event ): return True if not self . show_output or not self . _matrix . contains ( event . position ): return False if event . action is MouseAction . LEFT_CLICK : if self . _matrix . selected_pixel is None : return True _ , color = self . _matrix . selected_pixel if len ( color ) == 0 : return False button = _FadeInButton ( f \" { color : ^5 } \" , width = 5 ) button . styles . label = f \"@ { color } \" self . chosen . lazy_add ( button ) return True return False def get_lines ( self ) -> list [ str ]: \"\"\"Updates self._output and gets widget lines.\"\"\" if self . show_output and self . _matrix . selected_pixel is not None : _ , color = self . _matrix . selected_pixel if len ( color ) == 0 : return super () . get_lines () color_obj = str_to_color ( color ) rgb = color_obj . rgb hex_ = color_obj . hex lines : list [ Widget ] = [ Label ( f \"[@ { color } #auto] { color } [/ { color } ] { color } \" ), Label ( f \"[ { color } bold]Here[/bold italic] is \" + \"[/italic underline]some[/underline dim] example[/dim] text\" ), Label (), Label ( f \"RGB: [ { ';' . join ( map ( str , rgb )) } ]\" + f \"rgb( { rgb [ 0 ] : >3 } , { rgb [ 1 ] : >3 } , { rgb [ 2 ] : >3 } )\" ), Label ( f \"HEX: [ { hex_ } ] { hex_ } \" ), ] self . _output . set_widgets ( lines + [ Label (), self . chosen ]) return super () . get_lines () return super () . get_lines () __init__ ( show_output = True , attrs ) Initializes a ColorPicker. Attrs show_output: Decides whether the output Container should be added. If not set, the widget will only display the PixelMatrix of colors. Source code in pytermgui/widgets/color_picker.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def __init__ ( self , show_output : bool = True , ** attrs : Any ) -> None : \"\"\"Initializes a ColorPicker. Attrs: show_output: Decides whether the output Container should be added. If not set, the widget will only display the PixelMatrix of colors. \"\"\" super () . __init__ ( ** attrs ) self . show_output = show_output self . _matrix = PixelMatrix . from_matrix ( _get_xterm_matrix ()) self . width = 72 self . box = boxes . EMPTY self . _add_widget ( self . _matrix , run_get_lines = False ) self . chosen = Joiner () self . _output = Container ( self . chosen , \"\" , \"\" , \"\" ) if self . show_output : self . _add_widget ( self . _output ) get_lines () Updates self._output and gets widget lines. Source code in pytermgui/widgets/color_picker.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 def get_lines ( self ) -> list [ str ]: \"\"\"Updates self._output and gets widget lines.\"\"\" if self . show_output and self . _matrix . selected_pixel is not None : _ , color = self . _matrix . selected_pixel if len ( color ) == 0 : return super () . get_lines () color_obj = str_to_color ( color ) rgb = color_obj . rgb hex_ = color_obj . hex lines : list [ Widget ] = [ Label ( f \"[@ { color } #auto] { color } [/ { color } ] { color } \" ), Label ( f \"[ { color } bold]Here[/bold italic] is \" + \"[/italic underline]some[/underline dim] example[/dim] text\" ), Label (), Label ( f \"RGB: [ { ';' . join ( map ( str , rgb )) } ]\" + f \"rgb( { rgb [ 0 ] : >3 } , { rgb [ 1 ] : >3 } , { rgb [ 2 ] : >3 } )\" ), Label ( f \"HEX: [ { hex_ } ] { hex_ } \" ), ] self . _output . set_widgets ( lines + [ Label (), self . chosen ]) return super () . get_lines () return super () . get_lines () handle_mouse ( event ) Handles mouse events. On hover, the widget will display the currently hovered color and some testing text. On click, it will add a _FadeInButton for the currently hovered color. Parameters: Name Type Description Default event MouseEvent The event to handle. required Source code in pytermgui/widgets/color_picker.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Handles mouse events. On hover, the widget will display the currently hovered color and some testing text. On click, it will add a _FadeInButton for the currently hovered color. Args: event: The event to handle. \"\"\" if super () . handle_mouse ( event ): return True if not self . show_output or not self . _matrix . contains ( event . position ): return False if event . action is MouseAction . LEFT_CLICK : if self . _matrix . selected_pixel is None : return True _ , color = self . _matrix . selected_pixel if len ( color ) == 0 : return False button = _FadeInButton ( f \" { color : ^5 } \" , width = 5 ) button . styles . label = f \"@ { color } \" self . chosen . lazy_add ( button ) return True return False selectables_length () property Returns either the button count or 1. Source code in pytermgui/widgets/color_picker.py 208 209 210 211 212 @property def selectables_length ( self ) -> int : \"\"\"Returns either the button count or 1.\"\"\" return max ( super () . selectables_length , 1 ) Joiner Bases: Container A Container that stacks widgets horizontally, without filling up the available space. This works slightly differently to Splitter, as that applies padding & custom widths to any Widget it finds. This works much more simply, and only joins their lines together as they come. Source code in pytermgui/widgets/color_picker.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 class Joiner ( Container ): \"\"\"A Container that stacks widgets horizontally, without filling up the available space. This works slightly differently to Splitter, as that applies padding & custom widths to any Widget it finds. This works much more simply, and only joins their lines together as they come. \"\"\" parent_align = HorizontalAlignment . LEFT chars = { \"separator\" : \" \" } def get_lines ( self ) -> list [ str ]: \"\"\"Does magic\"\"\" lines : list [ str ] = [] separator = self . _get_char ( \"separator\" ) assert isinstance ( separator , str ) line = \"\" for widget in self . _widgets : if len ( line ) > 0 : line += separator widget . pos = ( self . pos [ 0 ] + real_length ( line ), self . pos [ 1 ] + len ( lines )) widget_line = widget . get_lines ()[ 0 ] if real_length ( line + widget_line ) >= self . width : lines . append ( line ) widget . pos = self . pos [ 0 ], self . pos [ 1 ] + len ( lines ) line = widget_line continue line += widget_line lines . append ( line ) self . height = len ( lines ) return lines get_lines () Does magic Source code in pytermgui/widgets/color_picker.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def get_lines ( self ) -> list [ str ]: \"\"\"Does magic\"\"\" lines : list [ str ] = [] separator = self . _get_char ( \"separator\" ) assert isinstance ( separator , str ) line = \"\" for widget in self . _widgets : if len ( line ) > 0 : line += separator widget . pos = ( self . pos [ 0 ] + real_length ( line ), self . pos [ 1 ] + len ( lines )) widget_line = widget . get_lines ()[ 0 ] if real_length ( line + widget_line ) >= self . width : lines . append ( line ) widget . pos = self . pos [ 0 ], self . pos [ 1 ] + len ( lines ) line = widget_line continue line += widget_line lines . append ( line ) self . height = len ( lines ) return lines","title":"color_picker"},{"location":"reference/pytermgui/widgets/color_picker/#pytermgui.widgets.color_picker.ColorPicker","text":"Bases: Container A simple ColorPicker widget. This is used to visualize xterm-255 colors. RGB colors are not included here, as it is probably easier to use a web-based picker for those anyways. Source code in pytermgui/widgets/color_picker.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 class ColorPicker ( Container ): \"\"\"A simple ColorPicker widget. This is used to visualize xterm-255 colors. RGB colors are not included here, as it is probably easier to use a web-based picker for those anyways. \"\"\" size_policy = SizePolicy . STATIC def __init__ ( self , show_output : bool = True , ** attrs : Any ) -> None : \"\"\"Initializes a ColorPicker. Attrs: show_output: Decides whether the output Container should be added. If not set, the widget will only display the PixelMatrix of colors. \"\"\" super () . __init__ ( ** attrs ) self . show_output = show_output self . _matrix = PixelMatrix . from_matrix ( _get_xterm_matrix ()) self . width = 72 self . box = boxes . EMPTY self . _add_widget ( self . _matrix , run_get_lines = False ) self . chosen = Joiner () self . _output = Container ( self . chosen , \"\" , \"\" , \"\" ) if self . show_output : self . _add_widget ( self . _output ) @property def selectables_length ( self ) -> int : \"\"\"Returns either the button count or 1.\"\"\" return max ( super () . selectables_length , 1 ) def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Handles mouse events. On hover, the widget will display the currently hovered color and some testing text. On click, it will add a _FadeInButton for the currently hovered color. Args: event: The event to handle. \"\"\" if super () . handle_mouse ( event ): return True if not self . show_output or not self . _matrix . contains ( event . position ): return False if event . action is MouseAction . LEFT_CLICK : if self . _matrix . selected_pixel is None : return True _ , color = self . _matrix . selected_pixel if len ( color ) == 0 : return False button = _FadeInButton ( f \" { color : ^5 } \" , width = 5 ) button . styles . label = f \"@ { color } \" self . chosen . lazy_add ( button ) return True return False def get_lines ( self ) -> list [ str ]: \"\"\"Updates self._output and gets widget lines.\"\"\" if self . show_output and self . _matrix . selected_pixel is not None : _ , color = self . _matrix . selected_pixel if len ( color ) == 0 : return super () . get_lines () color_obj = str_to_color ( color ) rgb = color_obj . rgb hex_ = color_obj . hex lines : list [ Widget ] = [ Label ( f \"[@ { color } #auto] { color } [/ { color } ] { color } \" ), Label ( f \"[ { color } bold]Here[/bold italic] is \" + \"[/italic underline]some[/underline dim] example[/dim] text\" ), Label (), Label ( f \"RGB: [ { ';' . join ( map ( str , rgb )) } ]\" + f \"rgb( { rgb [ 0 ] : >3 } , { rgb [ 1 ] : >3 } , { rgb [ 2 ] : >3 } )\" ), Label ( f \"HEX: [ { hex_ } ] { hex_ } \" ), ] self . _output . set_widgets ( lines + [ Label (), self . chosen ]) return super () . get_lines () return super () . get_lines ()","title":"ColorPicker"},{"location":"reference/pytermgui/widgets/color_picker/#pytermgui.widgets.color_picker.ColorPicker.__init__","text":"Initializes a ColorPicker. Attrs show_output: Decides whether the output Container should be added. If not set, the widget will only display the PixelMatrix of colors. Source code in pytermgui/widgets/color_picker.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def __init__ ( self , show_output : bool = True , ** attrs : Any ) -> None : \"\"\"Initializes a ColorPicker. Attrs: show_output: Decides whether the output Container should be added. If not set, the widget will only display the PixelMatrix of colors. \"\"\" super () . __init__ ( ** attrs ) self . show_output = show_output self . _matrix = PixelMatrix . from_matrix ( _get_xterm_matrix ()) self . width = 72 self . box = boxes . EMPTY self . _add_widget ( self . _matrix , run_get_lines = False ) self . chosen = Joiner () self . _output = Container ( self . chosen , \"\" , \"\" , \"\" ) if self . show_output : self . _add_widget ( self . _output )","title":"__init__()"},{"location":"reference/pytermgui/widgets/color_picker/#pytermgui.widgets.color_picker.ColorPicker.get_lines","text":"Updates self._output and gets widget lines. Source code in pytermgui/widgets/color_picker.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 def get_lines ( self ) -> list [ str ]: \"\"\"Updates self._output and gets widget lines.\"\"\" if self . show_output and self . _matrix . selected_pixel is not None : _ , color = self . _matrix . selected_pixel if len ( color ) == 0 : return super () . get_lines () color_obj = str_to_color ( color ) rgb = color_obj . rgb hex_ = color_obj . hex lines : list [ Widget ] = [ Label ( f \"[@ { color } #auto] { color } [/ { color } ] { color } \" ), Label ( f \"[ { color } bold]Here[/bold italic] is \" + \"[/italic underline]some[/underline dim] example[/dim] text\" ), Label (), Label ( f \"RGB: [ { ';' . join ( map ( str , rgb )) } ]\" + f \"rgb( { rgb [ 0 ] : >3 } , { rgb [ 1 ] : >3 } , { rgb [ 2 ] : >3 } )\" ), Label ( f \"HEX: [ { hex_ } ] { hex_ } \" ), ] self . _output . set_widgets ( lines + [ Label (), self . chosen ]) return super () . get_lines () return super () . get_lines ()","title":"get_lines()"},{"location":"reference/pytermgui/widgets/color_picker/#pytermgui.widgets.color_picker.ColorPicker.handle_mouse","text":"Handles mouse events. On hover, the widget will display the currently hovered color and some testing text. On click, it will add a _FadeInButton for the currently hovered color. Parameters: Name Type Description Default event MouseEvent The event to handle. required Source code in pytermgui/widgets/color_picker.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Handles mouse events. On hover, the widget will display the currently hovered color and some testing text. On click, it will add a _FadeInButton for the currently hovered color. Args: event: The event to handle. \"\"\" if super () . handle_mouse ( event ): return True if not self . show_output or not self . _matrix . contains ( event . position ): return False if event . action is MouseAction . LEFT_CLICK : if self . _matrix . selected_pixel is None : return True _ , color = self . _matrix . selected_pixel if len ( color ) == 0 : return False button = _FadeInButton ( f \" { color : ^5 } \" , width = 5 ) button . styles . label = f \"@ { color } \" self . chosen . lazy_add ( button ) return True return False","title":"handle_mouse()"},{"location":"reference/pytermgui/widgets/color_picker/#pytermgui.widgets.color_picker.ColorPicker.selectables_length","text":"Returns either the button count or 1. Source code in pytermgui/widgets/color_picker.py 208 209 210 211 212 @property def selectables_length ( self ) -> int : \"\"\"Returns either the button count or 1.\"\"\" return max ( super () . selectables_length , 1 )","title":"selectables_length()"},{"location":"reference/pytermgui/widgets/color_picker/#pytermgui.widgets.color_picker.Joiner","text":"Bases: Container A Container that stacks widgets horizontally, without filling up the available space. This works slightly differently to Splitter, as that applies padding & custom widths to any Widget it finds. This works much more simply, and only joins their lines together as they come. Source code in pytermgui/widgets/color_picker.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 class Joiner ( Container ): \"\"\"A Container that stacks widgets horizontally, without filling up the available space. This works slightly differently to Splitter, as that applies padding & custom widths to any Widget it finds. This works much more simply, and only joins their lines together as they come. \"\"\" parent_align = HorizontalAlignment . LEFT chars = { \"separator\" : \" \" } def get_lines ( self ) -> list [ str ]: \"\"\"Does magic\"\"\" lines : list [ str ] = [] separator = self . _get_char ( \"separator\" ) assert isinstance ( separator , str ) line = \"\" for widget in self . _widgets : if len ( line ) > 0 : line += separator widget . pos = ( self . pos [ 0 ] + real_length ( line ), self . pos [ 1 ] + len ( lines )) widget_line = widget . get_lines ()[ 0 ] if real_length ( line + widget_line ) >= self . width : lines . append ( line ) widget . pos = self . pos [ 0 ], self . pos [ 1 ] + len ( lines ) line = widget_line continue line += widget_line lines . append ( line ) self . height = len ( lines ) return lines","title":"Joiner"},{"location":"reference/pytermgui/widgets/color_picker/#pytermgui.widgets.color_picker.Joiner.get_lines","text":"Does magic Source code in pytermgui/widgets/color_picker.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def get_lines ( self ) -> list [ str ]: \"\"\"Does magic\"\"\" lines : list [ str ] = [] separator = self . _get_char ( \"separator\" ) assert isinstance ( separator , str ) line = \"\" for widget in self . _widgets : if len ( line ) > 0 : line += separator widget . pos = ( self . pos [ 0 ] + real_length ( line ), self . pos [ 1 ] + len ( lines )) widget_line = widget . get_lines ()[ 0 ] if real_length ( line + widget_line ) >= self . width : lines . append ( line ) widget . pos = self . pos [ 0 ], self . pos [ 1 ] + len ( lines ) line = widget_line continue line += widget_line lines . append ( line ) self . height = len ( lines ) return lines","title":"get_lines()"},{"location":"reference/pytermgui/widgets/containers/","text":"The module containing all of the layout-related widgets. Container Bases: ScrollableWidget A widget that displays other widgets, stacked vertically. Source code in pytermgui/widgets/containers.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 class Container ( ScrollableWidget ): \"\"\"A widget that displays other widgets, stacked vertically.\"\"\" styles = w_styles . StyleManager ( border = \"surface\" , corner = \"surface\" , fill = \"background\" , ) chars : dict [ str , w_styles . CharType ] = { \"border\" : [ \"| \" , \"-\" , \" |\" , \"-\" ], \"corner\" : [ \"\" ] * 4 , } keys = { \"next\" : { keys . DOWN , keys . CTRL_N , \"j\" }, \"previous\" : { keys . UP , keys . CTRL_P , \"k\" }, \"scroll_down\" : { keys . SHIFT_DOWN , \"J\" }, \"scroll_up\" : { keys . SHIFT_UP , \"K\" }, } serialized = Widget . serialized + [ \"centered_axis\" ] vertical_align = VerticalAlignment . CENTER allow_fullscreen = True overflow = Overflow . get_default () # TODO: Add `WidgetConvertible`? type instead of Any def __init__ ( self , * widgets : Any , ** attrs : Any ) -> None : \"\"\"Initialize Container data\"\"\" super () . __init__ ( ** attrs ) # TODO: This is just a band-aid. if not any ( \"width\" in attr for attr in attrs ): self . width = 40 self . _widgets : list [ Widget ] = [] self . dirty_widgets : list [ Widget ] = [] self . centered_axis : CenteringPolicy | None = None self . _prev_screen : tuple [ int , int ] = ( 0 , 0 ) self . _has_printed = False for widget in widgets : self . _add_widget ( widget ) if \"box\" not in attrs : attrs [ \"box\" ] = \"SINGLE\" try : self . box = attrs [ \"box\" ] # Splitter doesn't use boxes ATM. except KeyError : pass self . _mouse_target : Widget | None = None @property def sidelength ( self ) -> int : \"\"\"Gets the length of left and right borders combined. Returns: An integer equal to the `pytermgui.helpers.real_length` of the concatenation of the left and right borders of this widget, both with their respective styles applied. \"\"\" return self . width - self . content_dimensions [ 0 ] @property def content_dimensions ( self ) -> tuple [ int , int ]: \"\"\"Gets the size (width, height) of the available content area.\"\"\" if \"border\" not in self . chars : return self . width , self . height chars = self . _get_char ( \"border\" ) assert isinstance ( chars , list ) left , top , right , bottom = chars return ( self . width - real_length ( self . styles . border ( left + right )), self . height - sum ( 1 if real_length ( char ) else 0 for char in [ top , bottom ]), ) @property def selectables ( self ) -> list [ tuple [ Widget , int ]]: \"\"\"Gets all selectable widgets and their inner indices. This is used in order to have a constant reference to all selectable indices within this widget. Returns: A list of tuples containing a widget and an integer each. For each widget that is withing this one, it is added to this list as many times as it has selectables. Each of the integers correspond to a selectable_index within the widget. For example, a Container with a Button, InputField and an inner Container containing 3 selectables might return something like this: ``` [ (Button(...), 0), (InputField(...), 0), (Container(...), 0), (Container(...), 1), (Container(...), 2), ] ``` \"\"\" _selectables : list [ tuple [ Widget , int ]] = [] for widget in self . _widgets : if not widget . is_selectable : continue for i , ( inner , _ ) in enumerate ( widget . selectables ): _selectables . append (( inner , i )) return _selectables @property def selectables_length ( self ) -> int : \"\"\"Gets the length of the selectables list. Returns: An integer equal to the length of `self.selectables`. \"\"\" return len ( self . selectables ) @property def selected ( self ) -> Widget | None : \"\"\"Returns the currently selected object Returns: The currently selected widget if selected_index is not None, otherwise None. \"\"\" # TODO: Add deeper selection if self . selected_index is None : return None if self . selected_index >= len ( self . selectables ): return None return self . selectables [ self . selected_index ][ 0 ] @property def box ( self ) -> boxes . Box : \"\"\"Returns current box setting Returns: The currently set box instance. \"\"\" return self . _box @box . setter def box ( self , new : str | boxes . Box ) -> None : \"\"\"Applies a new box. Args: new: Either a `pytermgui.boxes.Box` instance or a string analogous to one of the default box names. \"\"\" if isinstance ( new , str ): from_module = vars ( boxes ) . get ( new ) if from_module is None : raise ValueError ( f \"Unknown box type { new } .\" ) new = from_module assert isinstance ( new , boxes . Box ) self . _box = new new . set_chars_of ( self ) def get_change ( self ) -> WidgetChange | None : \"\"\"Determines whether widget lines changed since the last call to this function.\"\"\" change = super () . get_change () if change is None : return None for widget in self . _widgets : if widget . get_change () is not None : self . dirty_widgets . append ( widget ) return change def __iadd__ ( self , other : object ) -> Container : \"\"\"Adds a new widget, then returns self. Args: other: Any widget instance, or data structure that can be turned into a widget by `Widget.from_data`. Returns: A reference to self. \"\"\" self . _add_widget ( other ) return self def __add__ ( self , other : object ) -> Container : \"\"\"Adds a new widget, then returns self. This method is analogous to `Container.__iadd__`. Args: other: Any widget instance, or data structure that can be turned into a widget by `Widget.from_data`. Returns: A reference to self. \"\"\" self . __iadd__ ( other ) return self def __iter__ ( self ) -> Iterator [ Widget ]: \"\"\"Gets an iterator of self._widgets. Yields: The next widget. \"\"\" for widget in self . _widgets : yield widget def __len__ ( self ) -> int : \"\"\"Gets the length of the widgets list. Returns: An integer describing len(self._widgets). \"\"\" return len ( self . _widgets ) def __getitem__ ( self , sli : int | slice ) -> Widget | list [ Widget ]: \"\"\"Gets an item from self._widgets. Args: sli: Slice of the list. Returns: The slice in the list. \"\"\" return self . _widgets [ sli ] def __setitem__ ( self , index : int , value : Any ) -> None : \"\"\"Sets an item in self._widgets. Args: index: The index to be set. value: The new widget at this index. \"\"\" self . _widgets [ index ] = value def __contains__ ( self , other : object ) -> bool : \"\"\"Determines if self._widgets contains other widget. Args: other: Any widget-like. Returns: A boolean describing whether `other` is in `self.widgets` \"\"\" if other in self . _widgets : return True for widget in self . _widgets : if isinstance ( widget , Container ) and other in widget : return True return False def _add_widget ( self , other : object , run_get_lines : bool = True ) -> Widget : \"\"\"Adds other to this widget. Args: other: Any widget-like object. run_get_lines: Boolean controlling whether the self.get_lines is ran. Returns: The added widget. This is useful when data conversion took place in this function, e.g. a string was converted to a Label. \"\"\" if not isinstance ( other , Widget ): to_widget = Widget . from_data ( other ) if to_widget is None : raise ValueError ( f \"Could not convert { other } of type { type ( other ) } to a Widget!\" ) other = to_widget # This is safe to do, as it would've raised an exception above already assert isinstance ( other , Widget ) self . _widgets . append ( other ) if isinstance ( other , Container ): other . set_recursive_depth ( self . depth + 2 ) else : other . depth = self . depth + 1 other . get_lines () other . parent = self if run_get_lines : self . get_lines () return other def _get_aligners ( self , widget : Widget , borders : tuple [ str , str ] ) -> tuple [ Callable [[ str ], str ], int ]: \"\"\"Gets an aligning method and position offset. Args: widget: The widget to align. borders: The left and right borders to put the widget within. Returns: A tuple of a method that, when called with a line, will return that line centered using the passed in widget's parent_align and width, as well as the horizontal offset resulting from the widget being aligned. \"\"\" left , right = self . styles . border ( borders [ 0 ]), self . styles . border ( borders [ 1 ]) char = \" \" fill = self . styles . fill def _align_left ( text : str ) -> str : \"\"\"Align line to the left\"\"\" padding = self . width - real_length ( left + right ) - real_length ( text ) return left + text + fill ( padding * char ) + right def _align_center ( text : str ) -> str : \"\"\"Align line to the center\"\"\" total = self . width - real_length ( left + right ) - real_length ( text ) padding , offset = divmod ( total , 2 ) return ( left + fill (( padding + offset ) * char ) + text + fill ( padding * char ) + right ) def _align_right ( text : str ) -> str : \"\"\"Align line to the right\"\"\" padding = self . width - real_length ( left + right ) - real_length ( text ) return left + fill ( padding * char ) + text + right if widget . parent_align == HorizontalAlignment . CENTER : total = self . width - real_length ( left + right ) - widget . width padding , offset = divmod ( total , 2 ) return _align_center , real_length ( left ) + padding + offset if widget . parent_align == HorizontalAlignment . RIGHT : return _align_right , self . width - real_length ( left ) - widget . width # Default to left-aligned return _align_left , real_length ( left ) def _update_width ( self , widget : Widget ) -> None : \"\"\"Updates the width of widget or self. This method respects widget.size_policy. Args: widget: The widget to update/base updates on. Raises: ValueError: Widget has SizePolicy.RELATIVE, but relative_width is None. WidthExceededError: Widget and self both have static widths, and widget's is larger than what is available. \"\"\" available = self . width - self . sidelength if widget . size_policy == SizePolicy . FILL : widget . width = available return if widget . size_policy == SizePolicy . RELATIVE : if widget . relative_width is None : raise ValueError ( f 'Widget \" { widget } \" \\' s relative width cannot be None.' ) widget . width = int ( widget . relative_width * available ) return if widget . width > available : if widget . size_policy == self . size_policy == SizePolicy . STATIC : raise WidthExceededError ( f \"Widget { widget } 's static width of { widget . width } \" + f \" exceeds its parent's available width { available } .\" \"\" ) if widget . size_policy == SizePolicy . STATIC : self . width = widget . width + self . sidelength else : widget . width = available def _apply_vertalign ( self , lines : list [ str ], diff : int , padder : str ) -> tuple [ int , list [ str ]]: \"\"\"Insert padder line into lines diff times, depending on self.vertical_align. Args: lines: The list of lines to align. diff: The available height. padder: The line to use to pad. Returns: A tuple containing the vertical offset as well as the padded list of lines. Raises: NotImplementedError: The given vertical alignment is not implemented. \"\"\" if self . vertical_align == VerticalAlignment . BOTTOM : for _ in range ( diff ): lines . insert ( 0 , padder ) return diff , lines if self . vertical_align == VerticalAlignment . TOP : for _ in range ( diff ): lines . append ( padder ) return 0 , lines if self . vertical_align == VerticalAlignment . CENTER : top , extra = divmod ( diff , 2 ) bottom = top + extra for _ in range ( top ): lines . insert ( 0 , padder ) for _ in range ( bottom ): lines . append ( padder ) return top , lines raise NotImplementedError ( f \"Vertical alignment { self . vertical_align } is not implemented for { type ( self ) } .\" ) def lazy_add ( self , other : object ) -> None : \"\"\"Adds `other` without running get_lines. This is analogous to `self._add_widget(other, run_get_lines=False). Args: other: The object to add. \"\"\" self . _add_widget ( other , run_get_lines = False ) def get_lines ( self ) -> list [ str ]: \"\"\"Gets all lines by spacing out inner widgets. This method reflects & applies both width settings, as well as the `parent_align` field. Returns: A list of all lines that represent this Container. \"\"\" def _get_border ( left : str , char : str , right : str ) -> str : \"\"\"Gets a top or bottom border. Args: left: Left corner character. char: Border character filling between left & right. right: Right corner character. Returns: The border line. \"\"\" offset = real_length ( strip_markup ( left + right )) return ( self . styles . corner ( left ) + self . styles . border ( char * ( self . width - offset )) + self . styles . corner ( right ) ) lines : list [ str ] = [] borders = self . _get_char ( \"border\" ) corners = self . _get_char ( \"corner\" ) has_top_bottom = ( real_length ( borders [ 1 ]) > 0 , real_length ( borders [ 3 ]) > 0 ) align , offset = self . _get_aligners ( self , ( borders [ 0 ], borders [ 2 ])) overflow = self . overflow for widget in self . _widgets : align , offset = self . _get_aligners ( widget , ( borders [ 0 ], borders [ 2 ])) self . _update_width ( widget ) widget . pos = ( self . pos [ 0 ] + offset , self . pos [ 1 ] + len ( lines ) + ( 1 if has_top_bottom [ 0 ] else 0 ), ) widget_lines : list [ str ] = [] for line in widget . get_lines (): if len ( lines ) + len ( widget_lines ) >= self . height - sum ( has_top_bottom ): if overflow is Overflow . HIDE : break if overflow == Overflow . AUTO : overflow = Overflow . SCROLL widget_lines . append ( align ( line )) lines . extend ( widget_lines ) if overflow == Overflow . SCROLL : self . _max_scroll = len ( lines ) - self . height + sum ( has_top_bottom ) height = self . height - sum ( has_top_bottom ) self . _scroll_offset = max ( 0 , min ( self . _scroll_offset , len ( lines ) - height )) lines = lines [ self . _scroll_offset : self . _scroll_offset + height ] elif overflow == Overflow . RESIZE : self . height = len ( lines ) + sum ( has_top_bottom ) vertical_offset , lines = self . _apply_vertalign ( lines , self . height - len ( lines ) - sum ( has_top_bottom ), align ( \"\" ) ) for widget in self . _widgets : widget . pos = ( widget . pos [ 0 ], widget . pos [ 1 ] + vertical_offset ) if widget . is_selectable : # This buffer will be out of position, so we must clear it. widget . positioned_line_buffer = [] widget . get_lines () self . positioned_line_buffer . extend ( widget . positioned_line_buffer ) widget . positioned_line_buffer = [] if has_top_bottom [ 0 ]: lines . insert ( 0 , _get_border ( corners [ 0 ], borders [ 1 ], corners [ 1 ])) if has_top_bottom [ 1 ]: lines . append ( _get_border ( corners [ 3 ], borders [ 3 ], corners [ 2 ])) self . height = len ( lines ) return lines def set_widgets ( self , new : list [ Widget ]) -> None : \"\"\"Sets new list in place of self._widgets. Args: new: The new widget list. \"\"\" self . _widgets = [] for widget in new : self . _add_widget ( widget ) def serialize ( self ) -> dict [ str , Any ]: \"\"\"Serializes this Container, adding in serializations of all widgets. See `pytermgui.widgets.base.Widget.serialize` for more info. Returns: The dictionary containing all serialized data. \"\"\" out = super () . serialize () out [ \"_widgets\" ] = [] for widget in self . _widgets : out [ \"_widgets\" ] . append ( widget . serialize ()) return out def pop ( self , index : int = - 1 ) -> Widget : \"\"\"Pops widget from self._widgets. Analogous to self._widgets.pop(index). Args: index: The index to operate on. Returns: The widget that was popped off the list. \"\"\" return self . _widgets . pop ( index ) def remove ( self , other : Widget ) -> None : \"\"\"Remove widget from self._widgets Analogous to self._widgets.remove(other). Args: other: The widget to remove. \"\"\" return self . _widgets . remove ( other ) def set_recursive_depth ( self , value : int ) -> None : \"\"\"Set depth for this Container and all its children. All inner widgets will receive value+1 as their new depth. Args: value: The new depth to use as the base depth. \"\"\" self . depth = value for widget in self . _widgets : if isinstance ( widget , Container ): widget . set_recursive_depth ( value + 1 ) else : widget . depth = value def select ( self , index : int | None = None ) -> None : \"\"\"Selects inner subwidget. Args: index: The index to select. Raises: IndexError: The index provided was beyond len(self.selectables). \"\"\" # Unselect all sub-elements for other in self . _widgets : if other . selectables_length > 0 : other . select ( None ) if index is not None : index = max ( 0 , min ( index , len ( self . selectables ) - 1 )) widget , inner_index = self . selectables [ index ] widget . select ( inner_index ) self . selected_index = index def center ( self , where : CenteringPolicy | None = None , store : bool = True ) -> Container : \"\"\"Centers this object to the given axis. Args: where: A CenteringPolicy describing the place to center to store: When set, this centering will be reapplied during every print, as well as when calling this method with no arguments. Returns: This Container. \"\"\" # Refresh in case changes happened self . get_lines () if where is None : # See `enums.py` for explanation about this ignore. where = CenteringPolicy . get_default () # type: ignore centerx = centery = where is CenteringPolicy . ALL centerx |= where is CenteringPolicy . HORIZONTAL centery |= where is CenteringPolicy . VERTICAL pos = list ( self . pos ) if centerx : pos [ 0 ] = ( self . terminal . width - self . width + 2 ) // 2 if centery : pos [ 1 ] = ( self . terminal . height - self . height + 2 ) // 2 self . pos = ( pos [ 0 ], pos [ 1 ]) if store : self . centered_axis = where self . _prev_screen = self . terminal . size return self def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Handles mouse events. This, like all mouse handlers should, calls super()'s implementation first, to allow usage of `on_{event}`-type callbacks. After that, it tries to find a target widget within itself to handle the event. Each handler will return a boolean. This boolean is then used to figure out whether the targeted widget should be \"sticky\", i.e. a slider. Returning True will set that widget as the current mouse target, and all mouse events will be sent to it as long as it returns True. Args: event: The event to handle. Returns: Whether the parent of this widget should treat it as one to \"stick\" events to, e.g. to keep sending mouse events to it. One can \"unstick\" a widget by returning False in the handler. \"\"\" def _handle_scrolling () -> bool : \"\"\"Scrolls the container.\"\"\" if self . overflow != Overflow . SCROLL : return False if event . action is MouseAction . SCROLL_UP : return self . scroll ( - 1 ) if event . action is MouseAction . SCROLL_DOWN : return self . scroll ( 1 ) return False if super () . handle_mouse ( event ): return True if event . action is MouseAction . RELEASE and self . _mouse_target is not None : return self . _mouse_target . handle_mouse ( event ) if ( self . _mouse_target is not None and ( event . action . value . endswith ( \"drag\" ) or event . action . value . startswith ( \"scroll\" ) ) and self . _mouse_target . handle_mouse ( event ) ): return True release = MouseEvent ( MouseAction . RELEASE , event . position ) selectables_index = 0 event . position = ( event . position [ 0 ], event . position [ 1 ] + self . _scroll_offset ) handled = False for widget in self . _widgets : if ( widget . pos [ 1 ] - self . pos [ 1 ] - self . _scroll_offset > self . content_dimensions [ 1 ] ): break if widget . contains ( event . position ): handled = widget . handle_mouse ( event ) selectables_index += widget . selected_index or 0 # TODO: This really should be customizable somehow. if event . action is MouseAction . LEFT_CLICK : if handled and selectables_index < len ( self . selectables ): self . select ( selectables_index ) if self . _mouse_target is not None and self . _mouse_target is not widget : self . _mouse_target . handle_mouse ( release ) self . _mouse_target = widget break if widget . is_selectable : selectables_index += widget . selectables_length handled = handled or _handle_scrolling () return handled def execute_binding ( self , key : Any , ignore_any : bool = False ) -> bool : \"\"\"Executes a binding on self, and then on self._widgets. If a widget.execute_binding call returns True this function will too. Note that on success the function returns immediately; no further widgets are checked. Args: key: The binding key. ignore_any: If set, `keys.ANY_KEY` bindings will not be executed. Returns: True if any widget returned True, False otherwise. \"\"\" if super () . execute_binding ( key , ignore_any = ignore_any ): return True selectables_index = 0 for widget in self . _widgets : if widget . execute_binding ( key ): selectables_index += widget . selected_index or 0 self . select ( selectables_index ) return True if widget . is_selectable : selectables_index += widget . selectables_length return False def handle_key ( # pylint: disable=too-many-return-statements, too-many-branches self , key : str ) -> bool : \"\"\"Handles a keypress, returns its success. Args: key: A key str. Returns: A boolean showing whether the key was handled. \"\"\" def _is_nav ( key : str ) -> bool : \"\"\"Determine if a key is in the navigation sets\"\"\" return key in self . keys [ \"next\" ] | self . keys [ \"previous\" ] if self . selected is not None and self . selected . handle_key ( key ): return True scroll_actions = { ** { key : 1 for key in self . keys [ \"scroll_down\" ]}, ** { key : - 1 for key in self . keys [ \"scroll_up\" ]}, } if key in self . keys [ \"scroll_down\" ] | self . keys [ \"scroll_up\" ]: for widget in self . _widgets : if isinstance ( widget , Container ) and self . selected in widget : widget . handle_key ( key ) self . scroll ( scroll_actions [ key ]) return True # Only use navigation when there is more than one selectable if self . selectables_length >= 1 and _is_nav ( key ): if self . selected_index is None : self . select ( 0 ) return True handled = False assert isinstance ( self . selected_index , int ) if key in self . keys [ \"previous\" ]: # No more selectables left, user wants to exit Container # upwards. if self . selected_index == 0 : return False self . select ( self . selected_index - 1 ) handled = True elif key in self . keys [ \"next\" ]: # Stop selection at last element, return as unhandled new = self . selected_index + 1 if new == len ( self . selectables ): return False self . select ( new ) handled = True if handled : return True if key == keys . ENTER : if self . selected_index is None and self . selectables_length > 0 : self . select ( 0 ) if self . selected is not None : self . selected . handle_key ( key ) return True for widget in self . _widgets : if widget . execute_binding ( key ): return True return False def wipe ( self ) -> None : \"\"\"Wipes the characters occupied by the object\"\"\" with cursor_at ( self . pos ) as print_here : for line in self . get_lines (): print_here ( real_length ( line ) * \" \" ) def print ( self ) -> None : \"\"\"Prints this Container. If the screen size has changed since last `print` call, the object will be centered based on its `centered_axis`. \"\"\" if not self . terminal . size == self . _prev_screen : clear () self . center ( self . centered_axis ) self . _prev_screen = self . terminal . size if self . allow_fullscreen : self . pos = self . terminal . origin with cursor_at ( self . pos ) as print_here : for line in self . get_lines (): print_here ( line ) self . _has_printed = True def debug ( self ) -> str : \"\"\"Returns a string with identifiable information on this widget. Returns: A str in the form of a class construction. This string is in a form that __could have been__ used to create this Container. \"\"\" return ( f \" { type ( self ) . __name__ } (width= { self . width } , height= { self . height } \" + ( f \", id= { self . id } \" if self . id is not None else \"\" ) + \")\" ) __add__ ( other ) Adds a new widget, then returns self. This method is analogous to Container.__iadd__ . Parameters: Name Type Description Default other object Any widget instance, or data structure that can be turned into a widget by Widget.from_data . required Returns: Type Description Container A reference to self. Source code in pytermgui/widgets/containers.py 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 def __add__ ( self , other : object ) -> Container : \"\"\"Adds a new widget, then returns self. This method is analogous to `Container.__iadd__`. Args: other: Any widget instance, or data structure that can be turned into a widget by `Widget.from_data`. Returns: A reference to self. \"\"\" self . __iadd__ ( other ) return self __contains__ ( other ) Determines if self._widgets contains other widget. Parameters: Name Type Description Default other object Any widget-like. required Returns: Type Description bool A boolean describing whether other is in self.widgets Source code in pytermgui/widgets/containers.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def __contains__ ( self , other : object ) -> bool : \"\"\"Determines if self._widgets contains other widget. Args: other: Any widget-like. Returns: A boolean describing whether `other` is in `self.widgets` \"\"\" if other in self . _widgets : return True for widget in self . _widgets : if isinstance ( widget , Container ) and other in widget : return True return False __getitem__ ( sli ) Gets an item from self._widgets. Parameters: Name Type Description Default sli int | slice Slice of the list. required Returns: Type Description Widget | list [ Widget ] The slice in the list. Source code in pytermgui/widgets/containers.py 276 277 278 279 280 281 282 283 284 285 286 def __getitem__ ( self , sli : int | slice ) -> Widget | list [ Widget ]: \"\"\"Gets an item from self._widgets. Args: sli: Slice of the list. Returns: The slice in the list. \"\"\" return self . _widgets [ sli ] __iadd__ ( other ) Adds a new widget, then returns self. Parameters: Name Type Description Default other object Any widget instance, or data structure that can be turned into a widget by Widget.from_data . required Returns: Type Description Container A reference to self. Source code in pytermgui/widgets/containers.py 227 228 229 230 231 232 233 234 235 236 237 238 239 def __iadd__ ( self , other : object ) -> Container : \"\"\"Adds a new widget, then returns self. Args: other: Any widget instance, or data structure that can be turned into a widget by `Widget.from_data`. Returns: A reference to self. \"\"\" self . _add_widget ( other ) return self __init__ ( widgets , attrs ) Initialize Container data Source code in pytermgui/widgets/containers.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def __init__ ( self , * widgets : Any , ** attrs : Any ) -> None : \"\"\"Initialize Container data\"\"\" super () . __init__ ( ** attrs ) # TODO: This is just a band-aid. if not any ( \"width\" in attr for attr in attrs ): self . width = 40 self . _widgets : list [ Widget ] = [] self . dirty_widgets : list [ Widget ] = [] self . centered_axis : CenteringPolicy | None = None self . _prev_screen : tuple [ int , int ] = ( 0 , 0 ) self . _has_printed = False for widget in widgets : self . _add_widget ( widget ) if \"box\" not in attrs : attrs [ \"box\" ] = \"SINGLE\" try : self . box = attrs [ \"box\" ] # Splitter doesn't use boxes ATM. except KeyError : pass self . _mouse_target : Widget | None = None __iter__ () Gets an iterator of self._widgets. Yields: Type Description Iterator [ Widget ] The next widget. Source code in pytermgui/widgets/containers.py 257 258 259 260 261 262 263 264 265 def __iter__ ( self ) -> Iterator [ Widget ]: \"\"\"Gets an iterator of self._widgets. Yields: The next widget. \"\"\" for widget in self . _widgets : yield widget __len__ () Gets the length of the widgets list. Returns: Type Description int An integer describing len(self._widgets). Source code in pytermgui/widgets/containers.py 267 268 269 270 271 272 273 274 def __len__ ( self ) -> int : \"\"\"Gets the length of the widgets list. Returns: An integer describing len(self._widgets). \"\"\" return len ( self . _widgets ) __setitem__ ( index , value ) Sets an item in self._widgets. Parameters: Name Type Description Default index int The index to be set. required value Any The new widget at this index. required Source code in pytermgui/widgets/containers.py 288 289 290 291 292 293 294 295 296 def __setitem__ ( self , index : int , value : Any ) -> None : \"\"\"Sets an item in self._widgets. Args: index: The index to be set. value: The new widget at this index. \"\"\" self . _widgets [ index ] = value box () property writable Returns current box setting Returns: Type Description boxes . Box The currently set box instance. Source code in pytermgui/widgets/containers.py 183 184 185 186 187 188 189 190 191 @property def box ( self ) -> boxes . Box : \"\"\"Returns current box setting Returns: The currently set box instance. \"\"\" return self . _box center ( where = None , store = True ) Centers this object to the given axis. Parameters: Name Type Description Default where CenteringPolicy | None A CenteringPolicy describing the place to center to None store bool When set, this centering will be reapplied during every print, as well as when calling this method with no arguments. True Returns: Type Description Container This Container. Source code in pytermgui/widgets/containers.py 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 def center ( self , where : CenteringPolicy | None = None , store : bool = True ) -> Container : \"\"\"Centers this object to the given axis. Args: where: A CenteringPolicy describing the place to center to store: When set, this centering will be reapplied during every print, as well as when calling this method with no arguments. Returns: This Container. \"\"\" # Refresh in case changes happened self . get_lines () if where is None : # See `enums.py` for explanation about this ignore. where = CenteringPolicy . get_default () # type: ignore centerx = centery = where is CenteringPolicy . ALL centerx |= where is CenteringPolicy . HORIZONTAL centery |= where is CenteringPolicy . VERTICAL pos = list ( self . pos ) if centerx : pos [ 0 ] = ( self . terminal . width - self . width + 2 ) // 2 if centery : pos [ 1 ] = ( self . terminal . height - self . height + 2 ) // 2 self . pos = ( pos [ 0 ], pos [ 1 ]) if store : self . centered_axis = where self . _prev_screen = self . terminal . size return self content_dimensions () property Gets the size (width, height) of the available content area. Source code in pytermgui/widgets/containers.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @property def content_dimensions ( self ) -> tuple [ int , int ]: \"\"\"Gets the size (width, height) of the available content area.\"\"\" if \"border\" not in self . chars : return self . width , self . height chars = self . _get_char ( \"border\" ) assert isinstance ( chars , list ) left , top , right , bottom = chars return ( self . width - real_length ( self . styles . border ( left + right )), self . height - sum ( 1 if real_length ( char ) else 0 for char in [ top , bottom ]), ) debug () Returns a string with identifiable information on this widget. Returns: Type Description str A str in the form of a class construction. This string is in a form that str could have been used to create this Container. Source code in pytermgui/widgets/containers.py 962 963 964 965 966 967 968 969 970 971 972 973 974 def debug ( self ) -> str : \"\"\"Returns a string with identifiable information on this widget. Returns: A str in the form of a class construction. This string is in a form that __could have been__ used to create this Container. \"\"\" return ( f \" { type ( self ) . __name__ } (width= { self . width } , height= { self . height } \" + ( f \", id= { self . id } \" if self . id is not None else \"\" ) + \")\" ) execute_binding ( key , ignore_any = False ) Executes a binding on self, and then on self._widgets. If a widget.execute_binding call returns True this function will too. Note that on success the function returns immediately; no further widgets are checked. Parameters: Name Type Description Default key Any The binding key. required ignore_any bool If set, keys.ANY_KEY bindings will not be executed. False Returns: Type Description bool True if any widget returned True, False otherwise. Source code in pytermgui/widgets/containers.py 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 def execute_binding ( self , key : Any , ignore_any : bool = False ) -> bool : \"\"\"Executes a binding on self, and then on self._widgets. If a widget.execute_binding call returns True this function will too. Note that on success the function returns immediately; no further widgets are checked. Args: key: The binding key. ignore_any: If set, `keys.ANY_KEY` bindings will not be executed. Returns: True if any widget returned True, False otherwise. \"\"\" if super () . execute_binding ( key , ignore_any = ignore_any ): return True selectables_index = 0 for widget in self . _widgets : if widget . execute_binding ( key ): selectables_index += widget . selected_index or 0 self . select ( selectables_index ) return True if widget . is_selectable : selectables_index += widget . selectables_length return False get_change () Determines whether widget lines changed since the last call to this function. Source code in pytermgui/widgets/containers.py 213 214 215 216 217 218 219 220 221 222 223 224 225 def get_change ( self ) -> WidgetChange | None : \"\"\"Determines whether widget lines changed since the last call to this function.\"\"\" change = super () . get_change () if change is None : return None for widget in self . _widgets : if widget . get_change () is not None : self . dirty_widgets . append ( widget ) return change get_lines () Gets all lines by spacing out inner widgets. This method reflects & applies both width settings, as well as the parent_align field. Returns: Type Description list [ str ] A list of all lines that represent this Container. Source code in pytermgui/widgets/containers.py 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 def get_lines ( self ) -> list [ str ]: \"\"\"Gets all lines by spacing out inner widgets. This method reflects & applies both width settings, as well as the `parent_align` field. Returns: A list of all lines that represent this Container. \"\"\" def _get_border ( left : str , char : str , right : str ) -> str : \"\"\"Gets a top or bottom border. Args: left: Left corner character. char: Border character filling between left & right. right: Right corner character. Returns: The border line. \"\"\" offset = real_length ( strip_markup ( left + right )) return ( self . styles . corner ( left ) + self . styles . border ( char * ( self . width - offset )) + self . styles . corner ( right ) ) lines : list [ str ] = [] borders = self . _get_char ( \"border\" ) corners = self . _get_char ( \"corner\" ) has_top_bottom = ( real_length ( borders [ 1 ]) > 0 , real_length ( borders [ 3 ]) > 0 ) align , offset = self . _get_aligners ( self , ( borders [ 0 ], borders [ 2 ])) overflow = self . overflow for widget in self . _widgets : align , offset = self . _get_aligners ( widget , ( borders [ 0 ], borders [ 2 ])) self . _update_width ( widget ) widget . pos = ( self . pos [ 0 ] + offset , self . pos [ 1 ] + len ( lines ) + ( 1 if has_top_bottom [ 0 ] else 0 ), ) widget_lines : list [ str ] = [] for line in widget . get_lines (): if len ( lines ) + len ( widget_lines ) >= self . height - sum ( has_top_bottom ): if overflow is Overflow . HIDE : break if overflow == Overflow . AUTO : overflow = Overflow . SCROLL widget_lines . append ( align ( line )) lines . extend ( widget_lines ) if overflow == Overflow . SCROLL : self . _max_scroll = len ( lines ) - self . height + sum ( has_top_bottom ) height = self . height - sum ( has_top_bottom ) self . _scroll_offset = max ( 0 , min ( self . _scroll_offset , len ( lines ) - height )) lines = lines [ self . _scroll_offset : self . _scroll_offset + height ] elif overflow == Overflow . RESIZE : self . height = len ( lines ) + sum ( has_top_bottom ) vertical_offset , lines = self . _apply_vertalign ( lines , self . height - len ( lines ) - sum ( has_top_bottom ), align ( \"\" ) ) for widget in self . _widgets : widget . pos = ( widget . pos [ 0 ], widget . pos [ 1 ] + vertical_offset ) if widget . is_selectable : # This buffer will be out of position, so we must clear it. widget . positioned_line_buffer = [] widget . get_lines () self . positioned_line_buffer . extend ( widget . positioned_line_buffer ) widget . positioned_line_buffer = [] if has_top_bottom [ 0 ]: lines . insert ( 0 , _get_border ( corners [ 0 ], borders [ 1 ], corners [ 1 ])) if has_top_bottom [ 1 ]: lines . append ( _get_border ( corners [ 3 ], borders [ 3 ], corners [ 2 ])) self . height = len ( lines ) return lines handle_key ( key ) Handles a keypress, returns its success. Parameters: Name Type Description Default key str A key str. required Returns: Type Description bool A boolean showing whether the key was handled. Source code in pytermgui/widgets/containers.py 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 def handle_key ( # pylint: disable=too-many-return-statements, too-many-branches self , key : str ) -> bool : \"\"\"Handles a keypress, returns its success. Args: key: A key str. Returns: A boolean showing whether the key was handled. \"\"\" def _is_nav ( key : str ) -> bool : \"\"\"Determine if a key is in the navigation sets\"\"\" return key in self . keys [ \"next\" ] | self . keys [ \"previous\" ] if self . selected is not None and self . selected . handle_key ( key ): return True scroll_actions = { ** { key : 1 for key in self . keys [ \"scroll_down\" ]}, ** { key : - 1 for key in self . keys [ \"scroll_up\" ]}, } if key in self . keys [ \"scroll_down\" ] | self . keys [ \"scroll_up\" ]: for widget in self . _widgets : if isinstance ( widget , Container ) and self . selected in widget : widget . handle_key ( key ) self . scroll ( scroll_actions [ key ]) return True # Only use navigation when there is more than one selectable if self . selectables_length >= 1 and _is_nav ( key ): if self . selected_index is None : self . select ( 0 ) return True handled = False assert isinstance ( self . selected_index , int ) if key in self . keys [ \"previous\" ]: # No more selectables left, user wants to exit Container # upwards. if self . selected_index == 0 : return False self . select ( self . selected_index - 1 ) handled = True elif key in self . keys [ \"next\" ]: # Stop selection at last element, return as unhandled new = self . selected_index + 1 if new == len ( self . selectables ): return False self . select ( new ) handled = True if handled : return True if key == keys . ENTER : if self . selected_index is None and self . selectables_length > 0 : self . select ( 0 ) if self . selected is not None : self . selected . handle_key ( key ) return True for widget in self . _widgets : if widget . execute_binding ( key ): return True return False handle_mouse ( event ) Handles mouse events. This, like all mouse handlers should, calls super()'s implementation first, to allow usage of on_{event} -type callbacks. After that, it tries to find a target widget within itself to handle the event. Each handler will return a boolean. This boolean is then used to figure out whether the targeted widget should be \"sticky\", i.e. a slider. Returning True will set that widget as the current mouse target, and all mouse events will be sent to it as long as it returns True. Parameters: Name Type Description Default event MouseEvent The event to handle. required Returns: Type Description bool Whether the parent of this widget should treat it as one to \"stick\" events bool to, e.g. to keep sending mouse events to it. One can \"unstick\" a widget by bool returning False in the handler. Source code in pytermgui/widgets/containers.py 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Handles mouse events. This, like all mouse handlers should, calls super()'s implementation first, to allow usage of `on_{event}`-type callbacks. After that, it tries to find a target widget within itself to handle the event. Each handler will return a boolean. This boolean is then used to figure out whether the targeted widget should be \"sticky\", i.e. a slider. Returning True will set that widget as the current mouse target, and all mouse events will be sent to it as long as it returns True. Args: event: The event to handle. Returns: Whether the parent of this widget should treat it as one to \"stick\" events to, e.g. to keep sending mouse events to it. One can \"unstick\" a widget by returning False in the handler. \"\"\" def _handle_scrolling () -> bool : \"\"\"Scrolls the container.\"\"\" if self . overflow != Overflow . SCROLL : return False if event . action is MouseAction . SCROLL_UP : return self . scroll ( - 1 ) if event . action is MouseAction . SCROLL_DOWN : return self . scroll ( 1 ) return False if super () . handle_mouse ( event ): return True if event . action is MouseAction . RELEASE and self . _mouse_target is not None : return self . _mouse_target . handle_mouse ( event ) if ( self . _mouse_target is not None and ( event . action . value . endswith ( \"drag\" ) or event . action . value . startswith ( \"scroll\" ) ) and self . _mouse_target . handle_mouse ( event ) ): return True release = MouseEvent ( MouseAction . RELEASE , event . position ) selectables_index = 0 event . position = ( event . position [ 0 ], event . position [ 1 ] + self . _scroll_offset ) handled = False for widget in self . _widgets : if ( widget . pos [ 1 ] - self . pos [ 1 ] - self . _scroll_offset > self . content_dimensions [ 1 ] ): break if widget . contains ( event . position ): handled = widget . handle_mouse ( event ) selectables_index += widget . selected_index or 0 # TODO: This really should be customizable somehow. if event . action is MouseAction . LEFT_CLICK : if handled and selectables_index < len ( self . selectables ): self . select ( selectables_index ) if self . _mouse_target is not None and self . _mouse_target is not widget : self . _mouse_target . handle_mouse ( release ) self . _mouse_target = widget break if widget . is_selectable : selectables_index += widget . selectables_length handled = handled or _handle_scrolling () return handled lazy_add ( other ) Adds other without running get_lines. This is analogous to `self._add_widget(other, run_get_lines=False). Parameters: Name Type Description Default other object The object to add. required Source code in pytermgui/widgets/containers.py 497 498 499 500 501 502 503 504 505 506 def lazy_add ( self , other : object ) -> None : \"\"\"Adds `other` without running get_lines. This is analogous to `self._add_widget(other, run_get_lines=False). Args: other: The object to add. \"\"\" self . _add_widget ( other , run_get_lines = False ) pop ( index =- 1 ) Pops widget from self._widgets. Analogous to self._widgets.pop(index). Parameters: Name Type Description Default index int The index to operate on. -1 Returns: Type Description Widget The widget that was popped off the list. Source code in pytermgui/widgets/containers.py 634 635 636 637 638 639 640 641 642 643 644 645 646 def pop ( self , index : int = - 1 ) -> Widget : \"\"\"Pops widget from self._widgets. Analogous to self._widgets.pop(index). Args: index: The index to operate on. Returns: The widget that was popped off the list. \"\"\" return self . _widgets . pop ( index ) print () Prints this Container. If the screen size has changed since last print call, the object will be centered based on its centered_axis . Source code in pytermgui/widgets/containers.py 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 def print ( self ) -> None : \"\"\"Prints this Container. If the screen size has changed since last `print` call, the object will be centered based on its `centered_axis`. \"\"\" if not self . terminal . size == self . _prev_screen : clear () self . center ( self . centered_axis ) self . _prev_screen = self . terminal . size if self . allow_fullscreen : self . pos = self . terminal . origin with cursor_at ( self . pos ) as print_here : for line in self . get_lines (): print_here ( line ) self . _has_printed = True remove ( other ) Remove widget from self._widgets Analogous to self._widgets.remove(other). Parameters: Name Type Description Default other Widget The widget to remove. required Source code in pytermgui/widgets/containers.py 648 649 650 651 652 653 654 655 656 657 def remove ( self , other : Widget ) -> None : \"\"\"Remove widget from self._widgets Analogous to self._widgets.remove(other). Args: other: The widget to remove. \"\"\" return self . _widgets . remove ( other ) select ( index = None ) Selects inner subwidget. Parameters: Name Type Description Default index int | None The index to select. None Raises: Type Description IndexError The index provided was beyond len(self.selectables). Source code in pytermgui/widgets/containers.py 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 def select ( self , index : int | None = None ) -> None : \"\"\"Selects inner subwidget. Args: index: The index to select. Raises: IndexError: The index provided was beyond len(self.selectables). \"\"\" # Unselect all sub-elements for other in self . _widgets : if other . selectables_length > 0 : other . select ( None ) if index is not None : index = max ( 0 , min ( index , len ( self . selectables ) - 1 )) widget , inner_index = self . selectables [ index ] widget . select ( inner_index ) self . selected_index = index selectables () property Gets all selectable widgets and their inner indices. This is used in order to have a constant reference to all selectable indices within this widget. Returns: Type Description list [ tuple [ Widget , int ]] A list of tuples containing a widget and an integer each. For each widget that is list [ tuple [ Widget , int ]] withing this one, it is added to this list as many times as it has selectables. Each list [ tuple [ Widget , int ]] of the integers correspond to a selectable_index within the widget. list [ tuple [ Widget , int ]] For example, a Container with a Button, InputField and an inner Container containing list [ tuple [ Widget , int ]] 3 selectables might return something like this: list [ tuple [ Widget , int ]] ``` list [ tuple [ Widget , int ]] [ (Button(...), 0), (InputField(...), 0), (Container(...), 0), (Container(...), 1), (Container(...), 2), list [ tuple [ Widget , int ]] ] list [ tuple [ Widget , int ]] ``` Source code in pytermgui/widgets/containers.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 @property def selectables ( self ) -> list [ tuple [ Widget , int ]]: \"\"\"Gets all selectable widgets and their inner indices. This is used in order to have a constant reference to all selectable indices within this widget. Returns: A list of tuples containing a widget and an integer each. For each widget that is withing this one, it is added to this list as many times as it has selectables. Each of the integers correspond to a selectable_index within the widget. For example, a Container with a Button, InputField and an inner Container containing 3 selectables might return something like this: ``` [ (Button(...), 0), (InputField(...), 0), (Container(...), 0), (Container(...), 1), (Container(...), 2), ] ``` \"\"\" _selectables : list [ tuple [ Widget , int ]] = [] for widget in self . _widgets : if not widget . is_selectable : continue for i , ( inner , _ ) in enumerate ( widget . selectables ): _selectables . append (( inner , i )) return _selectables selectables_length () property Gets the length of the selectables list. Returns: Type Description int An integer equal to the length of self.selectables . Source code in pytermgui/widgets/containers.py 154 155 156 157 158 159 160 161 162 @property def selectables_length ( self ) -> int : \"\"\"Gets the length of the selectables list. Returns: An integer equal to the length of `self.selectables`. \"\"\" return len ( self . selectables ) selected () property Returns the currently selected object Returns: Type Description Widget | None The currently selected widget if selected_index is not None, Widget | None otherwise None. Source code in pytermgui/widgets/containers.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 @property def selected ( self ) -> Widget | None : \"\"\"Returns the currently selected object Returns: The currently selected widget if selected_index is not None, otherwise None. \"\"\" # TODO: Add deeper selection if self . selected_index is None : return None if self . selected_index >= len ( self . selectables ): return None return self . selectables [ self . selected_index ][ 0 ] serialize () Serializes this Container, adding in serializations of all widgets. See pytermgui.widgets.base.Widget.serialize for more info. Returns: Type Description dict [ str , Any ] The dictionary containing all serialized data. Source code in pytermgui/widgets/containers.py 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 def serialize ( self ) -> dict [ str , Any ]: \"\"\"Serializes this Container, adding in serializations of all widgets. See `pytermgui.widgets.base.Widget.serialize` for more info. Returns: The dictionary containing all serialized data. \"\"\" out = super () . serialize () out [ \"_widgets\" ] = [] for widget in self . _widgets : out [ \"_widgets\" ] . append ( widget . serialize ()) return out set_recursive_depth ( value ) Set depth for this Container and all its children. All inner widgets will receive value+1 as their new depth. Parameters: Name Type Description Default value int The new depth to use as the base depth. required Source code in pytermgui/widgets/containers.py 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 def set_recursive_depth ( self , value : int ) -> None : \"\"\"Set depth for this Container and all its children. All inner widgets will receive value+1 as their new depth. Args: value: The new depth to use as the base depth. \"\"\" self . depth = value for widget in self . _widgets : if isinstance ( widget , Container ): widget . set_recursive_depth ( value + 1 ) else : widget . depth = value set_widgets ( new ) Sets new list in place of self._widgets. Parameters: Name Type Description Default new list [ Widget ] The new widget list. required Source code in pytermgui/widgets/containers.py 606 607 608 609 610 611 612 613 614 615 def set_widgets ( self , new : list [ Widget ]) -> None : \"\"\"Sets new list in place of self._widgets. Args: new: The new widget list. \"\"\" self . _widgets = [] for widget in new : self . _add_widget ( widget ) sidelength () property Gets the length of left and right borders combined. Returns: Type Description int An integer equal to the pytermgui.helpers.real_length of the concatenation of the left and right borders of this widget, both with their respective styles applied. Source code in pytermgui/widgets/containers.py 88 89 90 91 92 93 94 95 96 97 98 @property def sidelength ( self ) -> int : \"\"\"Gets the length of left and right borders combined. Returns: An integer equal to the `pytermgui.helpers.real_length` of the concatenation of the left and right borders of this widget, both with their respective styles applied. \"\"\" return self . width - self . content_dimensions [ 0 ] wipe () Wipes the characters occupied by the object Source code in pytermgui/widgets/containers.py 933 934 935 936 937 938 def wipe ( self ) -> None : \"\"\"Wipes the characters occupied by the object\"\"\" with cursor_at ( self . pos ) as print_here : for line in self . get_lines (): print_here ( real_length ( line ) * \" \" ) Splitter Bases: Container A widget that displays other widgets, stacked horizontally. Source code in pytermgui/widgets/containers.py 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 class Splitter ( Container ): \"\"\"A widget that displays other widgets, stacked horizontally.\"\"\" styles = w_styles . StyleManager ( separator = \"surface\" , fill = \"background\" ) chars : dict [ str , list [ str ] | str ] = { \"separator\" : \" | \" } keys = { \"previous\" : { keys . LEFT , \"h\" , keys . CTRL_B }, \"next\" : { keys . RIGHT , \"l\" , keys . CTRL_F }, } parent_align = HorizontalAlignment . RIGHT def _align ( self , alignment : HorizontalAlignment , target_width : int , line : str ) -> tuple [ int , str ]: \"\"\"Align a line r/wordavalanches\"\"\" available = target_width - real_length ( line ) fill_style = self . _get_style ( \"fill\" ) char = fill_style ( \" \" ) line = fill_style ( line ) if alignment == HorizontalAlignment . CENTER : padding , offset = divmod ( available , 2 ) return padding , padding * char + line + ( padding + offset ) * char if alignment == HorizontalAlignment . RIGHT : return available , available * char + line return 0 , line + available * char @property def content_dimensions ( self ) -> tuple [ int , int ]: \"\"\"Returns the available area for widgets.\"\"\" return self . height , self . width def get_lines ( self ) -> list [ str ]: \"\"\"Join all widgets horizontally.\"\"\" # An error will be raised if `separator` is not the correct type (str). separator = self . _get_style ( \"separator\" )( self . _get_char ( \"separator\" )) # type: ignore separator_length = real_length ( separator ) target_width , error = divmod ( self . width - ( len ( self . _widgets ) - 1 ) * separator_length , len ( self . _widgets ) ) vertical_lines = [] total_offset = 0 for widget in self . _widgets : inner = [] if widget . size_policy is SizePolicy . STATIC : target_width += target_width - widget . width width = widget . width else : widget . width = target_width + error width = widget . width error = 0 aligned : str | None = None for line in widget . get_lines (): # See `enums.py` for information about this ignore padding , aligned = self . _align ( cast ( HorizontalAlignment , widget . parent_align ), width , line ) inner . append ( aligned ) widget . pos = ( self . pos [ 0 ] + padding + total_offset , self . pos [ 1 ] + ( 1 if type ( widget ) . __name__ == \"Container\" else 0 ), ) if aligned is not None : total_offset += real_length ( inner [ - 1 ]) + separator_length vertical_lines . append ( inner ) lines = [] for horizontal in zip_longest ( * vertical_lines , fillvalue = \" \" * target_width ): lines . append (( reset () + separator ) . join ( horizontal )) self . height = max ( widget . height for widget in self ) return lines content_dimensions () property Returns the available area for widgets. Source code in pytermgui/widgets/containers.py 1012 1013 1014 1015 1016 @property def content_dimensions ( self ) -> tuple [ int , int ]: \"\"\"Returns the available area for widgets.\"\"\" return self . height , self . width get_lines () Join all widgets horizontally. Source code in pytermgui/widgets/containers.py 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 def get_lines ( self ) -> list [ str ]: \"\"\"Join all widgets horizontally.\"\"\" # An error will be raised if `separator` is not the correct type (str). separator = self . _get_style ( \"separator\" )( self . _get_char ( \"separator\" )) # type: ignore separator_length = real_length ( separator ) target_width , error = divmod ( self . width - ( len ( self . _widgets ) - 1 ) * separator_length , len ( self . _widgets ) ) vertical_lines = [] total_offset = 0 for widget in self . _widgets : inner = [] if widget . size_policy is SizePolicy . STATIC : target_width += target_width - widget . width width = widget . width else : widget . width = target_width + error width = widget . width error = 0 aligned : str | None = None for line in widget . get_lines (): # See `enums.py` for information about this ignore padding , aligned = self . _align ( cast ( HorizontalAlignment , widget . parent_align ), width , line ) inner . append ( aligned ) widget . pos = ( self . pos [ 0 ] + padding + total_offset , self . pos [ 1 ] + ( 1 if type ( widget ) . __name__ == \"Container\" else 0 ), ) if aligned is not None : total_offset += real_length ( inner [ - 1 ]) + separator_length vertical_lines . append ( inner ) lines = [] for horizontal in zip_longest ( * vertical_lines , fillvalue = \" \" * target_width ): lines . append (( reset () + separator ) . join ( horizontal )) self . height = max ( widget . height for widget in self ) return lines","title":"containers"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container","text":"Bases: ScrollableWidget A widget that displays other widgets, stacked vertically. Source code in pytermgui/widgets/containers.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 class Container ( ScrollableWidget ): \"\"\"A widget that displays other widgets, stacked vertically.\"\"\" styles = w_styles . StyleManager ( border = \"surface\" , corner = \"surface\" , fill = \"background\" , ) chars : dict [ str , w_styles . CharType ] = { \"border\" : [ \"| \" , \"-\" , \" |\" , \"-\" ], \"corner\" : [ \"\" ] * 4 , } keys = { \"next\" : { keys . DOWN , keys . CTRL_N , \"j\" }, \"previous\" : { keys . UP , keys . CTRL_P , \"k\" }, \"scroll_down\" : { keys . SHIFT_DOWN , \"J\" }, \"scroll_up\" : { keys . SHIFT_UP , \"K\" }, } serialized = Widget . serialized + [ \"centered_axis\" ] vertical_align = VerticalAlignment . CENTER allow_fullscreen = True overflow = Overflow . get_default () # TODO: Add `WidgetConvertible`? type instead of Any def __init__ ( self , * widgets : Any , ** attrs : Any ) -> None : \"\"\"Initialize Container data\"\"\" super () . __init__ ( ** attrs ) # TODO: This is just a band-aid. if not any ( \"width\" in attr for attr in attrs ): self . width = 40 self . _widgets : list [ Widget ] = [] self . dirty_widgets : list [ Widget ] = [] self . centered_axis : CenteringPolicy | None = None self . _prev_screen : tuple [ int , int ] = ( 0 , 0 ) self . _has_printed = False for widget in widgets : self . _add_widget ( widget ) if \"box\" not in attrs : attrs [ \"box\" ] = \"SINGLE\" try : self . box = attrs [ \"box\" ] # Splitter doesn't use boxes ATM. except KeyError : pass self . _mouse_target : Widget | None = None @property def sidelength ( self ) -> int : \"\"\"Gets the length of left and right borders combined. Returns: An integer equal to the `pytermgui.helpers.real_length` of the concatenation of the left and right borders of this widget, both with their respective styles applied. \"\"\" return self . width - self . content_dimensions [ 0 ] @property def content_dimensions ( self ) -> tuple [ int , int ]: \"\"\"Gets the size (width, height) of the available content area.\"\"\" if \"border\" not in self . chars : return self . width , self . height chars = self . _get_char ( \"border\" ) assert isinstance ( chars , list ) left , top , right , bottom = chars return ( self . width - real_length ( self . styles . border ( left + right )), self . height - sum ( 1 if real_length ( char ) else 0 for char in [ top , bottom ]), ) @property def selectables ( self ) -> list [ tuple [ Widget , int ]]: \"\"\"Gets all selectable widgets and their inner indices. This is used in order to have a constant reference to all selectable indices within this widget. Returns: A list of tuples containing a widget and an integer each. For each widget that is withing this one, it is added to this list as many times as it has selectables. Each of the integers correspond to a selectable_index within the widget. For example, a Container with a Button, InputField and an inner Container containing 3 selectables might return something like this: ``` [ (Button(...), 0), (InputField(...), 0), (Container(...), 0), (Container(...), 1), (Container(...), 2), ] ``` \"\"\" _selectables : list [ tuple [ Widget , int ]] = [] for widget in self . _widgets : if not widget . is_selectable : continue for i , ( inner , _ ) in enumerate ( widget . selectables ): _selectables . append (( inner , i )) return _selectables @property def selectables_length ( self ) -> int : \"\"\"Gets the length of the selectables list. Returns: An integer equal to the length of `self.selectables`. \"\"\" return len ( self . selectables ) @property def selected ( self ) -> Widget | None : \"\"\"Returns the currently selected object Returns: The currently selected widget if selected_index is not None, otherwise None. \"\"\" # TODO: Add deeper selection if self . selected_index is None : return None if self . selected_index >= len ( self . selectables ): return None return self . selectables [ self . selected_index ][ 0 ] @property def box ( self ) -> boxes . Box : \"\"\"Returns current box setting Returns: The currently set box instance. \"\"\" return self . _box @box . setter def box ( self , new : str | boxes . Box ) -> None : \"\"\"Applies a new box. Args: new: Either a `pytermgui.boxes.Box` instance or a string analogous to one of the default box names. \"\"\" if isinstance ( new , str ): from_module = vars ( boxes ) . get ( new ) if from_module is None : raise ValueError ( f \"Unknown box type { new } .\" ) new = from_module assert isinstance ( new , boxes . Box ) self . _box = new new . set_chars_of ( self ) def get_change ( self ) -> WidgetChange | None : \"\"\"Determines whether widget lines changed since the last call to this function.\"\"\" change = super () . get_change () if change is None : return None for widget in self . _widgets : if widget . get_change () is not None : self . dirty_widgets . append ( widget ) return change def __iadd__ ( self , other : object ) -> Container : \"\"\"Adds a new widget, then returns self. Args: other: Any widget instance, or data structure that can be turned into a widget by `Widget.from_data`. Returns: A reference to self. \"\"\" self . _add_widget ( other ) return self def __add__ ( self , other : object ) -> Container : \"\"\"Adds a new widget, then returns self. This method is analogous to `Container.__iadd__`. Args: other: Any widget instance, or data structure that can be turned into a widget by `Widget.from_data`. Returns: A reference to self. \"\"\" self . __iadd__ ( other ) return self def __iter__ ( self ) -> Iterator [ Widget ]: \"\"\"Gets an iterator of self._widgets. Yields: The next widget. \"\"\" for widget in self . _widgets : yield widget def __len__ ( self ) -> int : \"\"\"Gets the length of the widgets list. Returns: An integer describing len(self._widgets). \"\"\" return len ( self . _widgets ) def __getitem__ ( self , sli : int | slice ) -> Widget | list [ Widget ]: \"\"\"Gets an item from self._widgets. Args: sli: Slice of the list. Returns: The slice in the list. \"\"\" return self . _widgets [ sli ] def __setitem__ ( self , index : int , value : Any ) -> None : \"\"\"Sets an item in self._widgets. Args: index: The index to be set. value: The new widget at this index. \"\"\" self . _widgets [ index ] = value def __contains__ ( self , other : object ) -> bool : \"\"\"Determines if self._widgets contains other widget. Args: other: Any widget-like. Returns: A boolean describing whether `other` is in `self.widgets` \"\"\" if other in self . _widgets : return True for widget in self . _widgets : if isinstance ( widget , Container ) and other in widget : return True return False def _add_widget ( self , other : object , run_get_lines : bool = True ) -> Widget : \"\"\"Adds other to this widget. Args: other: Any widget-like object. run_get_lines: Boolean controlling whether the self.get_lines is ran. Returns: The added widget. This is useful when data conversion took place in this function, e.g. a string was converted to a Label. \"\"\" if not isinstance ( other , Widget ): to_widget = Widget . from_data ( other ) if to_widget is None : raise ValueError ( f \"Could not convert { other } of type { type ( other ) } to a Widget!\" ) other = to_widget # This is safe to do, as it would've raised an exception above already assert isinstance ( other , Widget ) self . _widgets . append ( other ) if isinstance ( other , Container ): other . set_recursive_depth ( self . depth + 2 ) else : other . depth = self . depth + 1 other . get_lines () other . parent = self if run_get_lines : self . get_lines () return other def _get_aligners ( self , widget : Widget , borders : tuple [ str , str ] ) -> tuple [ Callable [[ str ], str ], int ]: \"\"\"Gets an aligning method and position offset. Args: widget: The widget to align. borders: The left and right borders to put the widget within. Returns: A tuple of a method that, when called with a line, will return that line centered using the passed in widget's parent_align and width, as well as the horizontal offset resulting from the widget being aligned. \"\"\" left , right = self . styles . border ( borders [ 0 ]), self . styles . border ( borders [ 1 ]) char = \" \" fill = self . styles . fill def _align_left ( text : str ) -> str : \"\"\"Align line to the left\"\"\" padding = self . width - real_length ( left + right ) - real_length ( text ) return left + text + fill ( padding * char ) + right def _align_center ( text : str ) -> str : \"\"\"Align line to the center\"\"\" total = self . width - real_length ( left + right ) - real_length ( text ) padding , offset = divmod ( total , 2 ) return ( left + fill (( padding + offset ) * char ) + text + fill ( padding * char ) + right ) def _align_right ( text : str ) -> str : \"\"\"Align line to the right\"\"\" padding = self . width - real_length ( left + right ) - real_length ( text ) return left + fill ( padding * char ) + text + right if widget . parent_align == HorizontalAlignment . CENTER : total = self . width - real_length ( left + right ) - widget . width padding , offset = divmod ( total , 2 ) return _align_center , real_length ( left ) + padding + offset if widget . parent_align == HorizontalAlignment . RIGHT : return _align_right , self . width - real_length ( left ) - widget . width # Default to left-aligned return _align_left , real_length ( left ) def _update_width ( self , widget : Widget ) -> None : \"\"\"Updates the width of widget or self. This method respects widget.size_policy. Args: widget: The widget to update/base updates on. Raises: ValueError: Widget has SizePolicy.RELATIVE, but relative_width is None. WidthExceededError: Widget and self both have static widths, and widget's is larger than what is available. \"\"\" available = self . width - self . sidelength if widget . size_policy == SizePolicy . FILL : widget . width = available return if widget . size_policy == SizePolicy . RELATIVE : if widget . relative_width is None : raise ValueError ( f 'Widget \" { widget } \" \\' s relative width cannot be None.' ) widget . width = int ( widget . relative_width * available ) return if widget . width > available : if widget . size_policy == self . size_policy == SizePolicy . STATIC : raise WidthExceededError ( f \"Widget { widget } 's static width of { widget . width } \" + f \" exceeds its parent's available width { available } .\" \"\" ) if widget . size_policy == SizePolicy . STATIC : self . width = widget . width + self . sidelength else : widget . width = available def _apply_vertalign ( self , lines : list [ str ], diff : int , padder : str ) -> tuple [ int , list [ str ]]: \"\"\"Insert padder line into lines diff times, depending on self.vertical_align. Args: lines: The list of lines to align. diff: The available height. padder: The line to use to pad. Returns: A tuple containing the vertical offset as well as the padded list of lines. Raises: NotImplementedError: The given vertical alignment is not implemented. \"\"\" if self . vertical_align == VerticalAlignment . BOTTOM : for _ in range ( diff ): lines . insert ( 0 , padder ) return diff , lines if self . vertical_align == VerticalAlignment . TOP : for _ in range ( diff ): lines . append ( padder ) return 0 , lines if self . vertical_align == VerticalAlignment . CENTER : top , extra = divmod ( diff , 2 ) bottom = top + extra for _ in range ( top ): lines . insert ( 0 , padder ) for _ in range ( bottom ): lines . append ( padder ) return top , lines raise NotImplementedError ( f \"Vertical alignment { self . vertical_align } is not implemented for { type ( self ) } .\" ) def lazy_add ( self , other : object ) -> None : \"\"\"Adds `other` without running get_lines. This is analogous to `self._add_widget(other, run_get_lines=False). Args: other: The object to add. \"\"\" self . _add_widget ( other , run_get_lines = False ) def get_lines ( self ) -> list [ str ]: \"\"\"Gets all lines by spacing out inner widgets. This method reflects & applies both width settings, as well as the `parent_align` field. Returns: A list of all lines that represent this Container. \"\"\" def _get_border ( left : str , char : str , right : str ) -> str : \"\"\"Gets a top or bottom border. Args: left: Left corner character. char: Border character filling between left & right. right: Right corner character. Returns: The border line. \"\"\" offset = real_length ( strip_markup ( left + right )) return ( self . styles . corner ( left ) + self . styles . border ( char * ( self . width - offset )) + self . styles . corner ( right ) ) lines : list [ str ] = [] borders = self . _get_char ( \"border\" ) corners = self . _get_char ( \"corner\" ) has_top_bottom = ( real_length ( borders [ 1 ]) > 0 , real_length ( borders [ 3 ]) > 0 ) align , offset = self . _get_aligners ( self , ( borders [ 0 ], borders [ 2 ])) overflow = self . overflow for widget in self . _widgets : align , offset = self . _get_aligners ( widget , ( borders [ 0 ], borders [ 2 ])) self . _update_width ( widget ) widget . pos = ( self . pos [ 0 ] + offset , self . pos [ 1 ] + len ( lines ) + ( 1 if has_top_bottom [ 0 ] else 0 ), ) widget_lines : list [ str ] = [] for line in widget . get_lines (): if len ( lines ) + len ( widget_lines ) >= self . height - sum ( has_top_bottom ): if overflow is Overflow . HIDE : break if overflow == Overflow . AUTO : overflow = Overflow . SCROLL widget_lines . append ( align ( line )) lines . extend ( widget_lines ) if overflow == Overflow . SCROLL : self . _max_scroll = len ( lines ) - self . height + sum ( has_top_bottom ) height = self . height - sum ( has_top_bottom ) self . _scroll_offset = max ( 0 , min ( self . _scroll_offset , len ( lines ) - height )) lines = lines [ self . _scroll_offset : self . _scroll_offset + height ] elif overflow == Overflow . RESIZE : self . height = len ( lines ) + sum ( has_top_bottom ) vertical_offset , lines = self . _apply_vertalign ( lines , self . height - len ( lines ) - sum ( has_top_bottom ), align ( \"\" ) ) for widget in self . _widgets : widget . pos = ( widget . pos [ 0 ], widget . pos [ 1 ] + vertical_offset ) if widget . is_selectable : # This buffer will be out of position, so we must clear it. widget . positioned_line_buffer = [] widget . get_lines () self . positioned_line_buffer . extend ( widget . positioned_line_buffer ) widget . positioned_line_buffer = [] if has_top_bottom [ 0 ]: lines . insert ( 0 , _get_border ( corners [ 0 ], borders [ 1 ], corners [ 1 ])) if has_top_bottom [ 1 ]: lines . append ( _get_border ( corners [ 3 ], borders [ 3 ], corners [ 2 ])) self . height = len ( lines ) return lines def set_widgets ( self , new : list [ Widget ]) -> None : \"\"\"Sets new list in place of self._widgets. Args: new: The new widget list. \"\"\" self . _widgets = [] for widget in new : self . _add_widget ( widget ) def serialize ( self ) -> dict [ str , Any ]: \"\"\"Serializes this Container, adding in serializations of all widgets. See `pytermgui.widgets.base.Widget.serialize` for more info. Returns: The dictionary containing all serialized data. \"\"\" out = super () . serialize () out [ \"_widgets\" ] = [] for widget in self . _widgets : out [ \"_widgets\" ] . append ( widget . serialize ()) return out def pop ( self , index : int = - 1 ) -> Widget : \"\"\"Pops widget from self._widgets. Analogous to self._widgets.pop(index). Args: index: The index to operate on. Returns: The widget that was popped off the list. \"\"\" return self . _widgets . pop ( index ) def remove ( self , other : Widget ) -> None : \"\"\"Remove widget from self._widgets Analogous to self._widgets.remove(other). Args: other: The widget to remove. \"\"\" return self . _widgets . remove ( other ) def set_recursive_depth ( self , value : int ) -> None : \"\"\"Set depth for this Container and all its children. All inner widgets will receive value+1 as their new depth. Args: value: The new depth to use as the base depth. \"\"\" self . depth = value for widget in self . _widgets : if isinstance ( widget , Container ): widget . set_recursive_depth ( value + 1 ) else : widget . depth = value def select ( self , index : int | None = None ) -> None : \"\"\"Selects inner subwidget. Args: index: The index to select. Raises: IndexError: The index provided was beyond len(self.selectables). \"\"\" # Unselect all sub-elements for other in self . _widgets : if other . selectables_length > 0 : other . select ( None ) if index is not None : index = max ( 0 , min ( index , len ( self . selectables ) - 1 )) widget , inner_index = self . selectables [ index ] widget . select ( inner_index ) self . selected_index = index def center ( self , where : CenteringPolicy | None = None , store : bool = True ) -> Container : \"\"\"Centers this object to the given axis. Args: where: A CenteringPolicy describing the place to center to store: When set, this centering will be reapplied during every print, as well as when calling this method with no arguments. Returns: This Container. \"\"\" # Refresh in case changes happened self . get_lines () if where is None : # See `enums.py` for explanation about this ignore. where = CenteringPolicy . get_default () # type: ignore centerx = centery = where is CenteringPolicy . ALL centerx |= where is CenteringPolicy . HORIZONTAL centery |= where is CenteringPolicy . VERTICAL pos = list ( self . pos ) if centerx : pos [ 0 ] = ( self . terminal . width - self . width + 2 ) // 2 if centery : pos [ 1 ] = ( self . terminal . height - self . height + 2 ) // 2 self . pos = ( pos [ 0 ], pos [ 1 ]) if store : self . centered_axis = where self . _prev_screen = self . terminal . size return self def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Handles mouse events. This, like all mouse handlers should, calls super()'s implementation first, to allow usage of `on_{event}`-type callbacks. After that, it tries to find a target widget within itself to handle the event. Each handler will return a boolean. This boolean is then used to figure out whether the targeted widget should be \"sticky\", i.e. a slider. Returning True will set that widget as the current mouse target, and all mouse events will be sent to it as long as it returns True. Args: event: The event to handle. Returns: Whether the parent of this widget should treat it as one to \"stick\" events to, e.g. to keep sending mouse events to it. One can \"unstick\" a widget by returning False in the handler. \"\"\" def _handle_scrolling () -> bool : \"\"\"Scrolls the container.\"\"\" if self . overflow != Overflow . SCROLL : return False if event . action is MouseAction . SCROLL_UP : return self . scroll ( - 1 ) if event . action is MouseAction . SCROLL_DOWN : return self . scroll ( 1 ) return False if super () . handle_mouse ( event ): return True if event . action is MouseAction . RELEASE and self . _mouse_target is not None : return self . _mouse_target . handle_mouse ( event ) if ( self . _mouse_target is not None and ( event . action . value . endswith ( \"drag\" ) or event . action . value . startswith ( \"scroll\" ) ) and self . _mouse_target . handle_mouse ( event ) ): return True release = MouseEvent ( MouseAction . RELEASE , event . position ) selectables_index = 0 event . position = ( event . position [ 0 ], event . position [ 1 ] + self . _scroll_offset ) handled = False for widget in self . _widgets : if ( widget . pos [ 1 ] - self . pos [ 1 ] - self . _scroll_offset > self . content_dimensions [ 1 ] ): break if widget . contains ( event . position ): handled = widget . handle_mouse ( event ) selectables_index += widget . selected_index or 0 # TODO: This really should be customizable somehow. if event . action is MouseAction . LEFT_CLICK : if handled and selectables_index < len ( self . selectables ): self . select ( selectables_index ) if self . _mouse_target is not None and self . _mouse_target is not widget : self . _mouse_target . handle_mouse ( release ) self . _mouse_target = widget break if widget . is_selectable : selectables_index += widget . selectables_length handled = handled or _handle_scrolling () return handled def execute_binding ( self , key : Any , ignore_any : bool = False ) -> bool : \"\"\"Executes a binding on self, and then on self._widgets. If a widget.execute_binding call returns True this function will too. Note that on success the function returns immediately; no further widgets are checked. Args: key: The binding key. ignore_any: If set, `keys.ANY_KEY` bindings will not be executed. Returns: True if any widget returned True, False otherwise. \"\"\" if super () . execute_binding ( key , ignore_any = ignore_any ): return True selectables_index = 0 for widget in self . _widgets : if widget . execute_binding ( key ): selectables_index += widget . selected_index or 0 self . select ( selectables_index ) return True if widget . is_selectable : selectables_index += widget . selectables_length return False def handle_key ( # pylint: disable=too-many-return-statements, too-many-branches self , key : str ) -> bool : \"\"\"Handles a keypress, returns its success. Args: key: A key str. Returns: A boolean showing whether the key was handled. \"\"\" def _is_nav ( key : str ) -> bool : \"\"\"Determine if a key is in the navigation sets\"\"\" return key in self . keys [ \"next\" ] | self . keys [ \"previous\" ] if self . selected is not None and self . selected . handle_key ( key ): return True scroll_actions = { ** { key : 1 for key in self . keys [ \"scroll_down\" ]}, ** { key : - 1 for key in self . keys [ \"scroll_up\" ]}, } if key in self . keys [ \"scroll_down\" ] | self . keys [ \"scroll_up\" ]: for widget in self . _widgets : if isinstance ( widget , Container ) and self . selected in widget : widget . handle_key ( key ) self . scroll ( scroll_actions [ key ]) return True # Only use navigation when there is more than one selectable if self . selectables_length >= 1 and _is_nav ( key ): if self . selected_index is None : self . select ( 0 ) return True handled = False assert isinstance ( self . selected_index , int ) if key in self . keys [ \"previous\" ]: # No more selectables left, user wants to exit Container # upwards. if self . selected_index == 0 : return False self . select ( self . selected_index - 1 ) handled = True elif key in self . keys [ \"next\" ]: # Stop selection at last element, return as unhandled new = self . selected_index + 1 if new == len ( self . selectables ): return False self . select ( new ) handled = True if handled : return True if key == keys . ENTER : if self . selected_index is None and self . selectables_length > 0 : self . select ( 0 ) if self . selected is not None : self . selected . handle_key ( key ) return True for widget in self . _widgets : if widget . execute_binding ( key ): return True return False def wipe ( self ) -> None : \"\"\"Wipes the characters occupied by the object\"\"\" with cursor_at ( self . pos ) as print_here : for line in self . get_lines (): print_here ( real_length ( line ) * \" \" ) def print ( self ) -> None : \"\"\"Prints this Container. If the screen size has changed since last `print` call, the object will be centered based on its `centered_axis`. \"\"\" if not self . terminal . size == self . _prev_screen : clear () self . center ( self . centered_axis ) self . _prev_screen = self . terminal . size if self . allow_fullscreen : self . pos = self . terminal . origin with cursor_at ( self . pos ) as print_here : for line in self . get_lines (): print_here ( line ) self . _has_printed = True def debug ( self ) -> str : \"\"\"Returns a string with identifiable information on this widget. Returns: A str in the form of a class construction. This string is in a form that __could have been__ used to create this Container. \"\"\" return ( f \" { type ( self ) . __name__ } (width= { self . width } , height= { self . height } \" + ( f \", id= { self . id } \" if self . id is not None else \"\" ) + \")\" )","title":"Container"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.__add__","text":"Adds a new widget, then returns self. This method is analogous to Container.__iadd__ . Parameters: Name Type Description Default other object Any widget instance, or data structure that can be turned into a widget by Widget.from_data . required Returns: Type Description Container A reference to self. Source code in pytermgui/widgets/containers.py 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 def __add__ ( self , other : object ) -> Container : \"\"\"Adds a new widget, then returns self. This method is analogous to `Container.__iadd__`. Args: other: Any widget instance, or data structure that can be turned into a widget by `Widget.from_data`. Returns: A reference to self. \"\"\" self . __iadd__ ( other ) return self","title":"__add__()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.__contains__","text":"Determines if self._widgets contains other widget. Parameters: Name Type Description Default other object Any widget-like. required Returns: Type Description bool A boolean describing whether other is in self.widgets Source code in pytermgui/widgets/containers.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def __contains__ ( self , other : object ) -> bool : \"\"\"Determines if self._widgets contains other widget. Args: other: Any widget-like. Returns: A boolean describing whether `other` is in `self.widgets` \"\"\" if other in self . _widgets : return True for widget in self . _widgets : if isinstance ( widget , Container ) and other in widget : return True return False","title":"__contains__()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.__getitem__","text":"Gets an item from self._widgets. Parameters: Name Type Description Default sli int | slice Slice of the list. required Returns: Type Description Widget | list [ Widget ] The slice in the list. Source code in pytermgui/widgets/containers.py 276 277 278 279 280 281 282 283 284 285 286 def __getitem__ ( self , sli : int | slice ) -> Widget | list [ Widget ]: \"\"\"Gets an item from self._widgets. Args: sli: Slice of the list. Returns: The slice in the list. \"\"\" return self . _widgets [ sli ]","title":"__getitem__()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.__iadd__","text":"Adds a new widget, then returns self. Parameters: Name Type Description Default other object Any widget instance, or data structure that can be turned into a widget by Widget.from_data . required Returns: Type Description Container A reference to self. Source code in pytermgui/widgets/containers.py 227 228 229 230 231 232 233 234 235 236 237 238 239 def __iadd__ ( self , other : object ) -> Container : \"\"\"Adds a new widget, then returns self. Args: other: Any widget instance, or data structure that can be turned into a widget by `Widget.from_data`. Returns: A reference to self. \"\"\" self . _add_widget ( other ) return self","title":"__iadd__()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.__init__","text":"Initialize Container data Source code in pytermgui/widgets/containers.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def __init__ ( self , * widgets : Any , ** attrs : Any ) -> None : \"\"\"Initialize Container data\"\"\" super () . __init__ ( ** attrs ) # TODO: This is just a band-aid. if not any ( \"width\" in attr for attr in attrs ): self . width = 40 self . _widgets : list [ Widget ] = [] self . dirty_widgets : list [ Widget ] = [] self . centered_axis : CenteringPolicy | None = None self . _prev_screen : tuple [ int , int ] = ( 0 , 0 ) self . _has_printed = False for widget in widgets : self . _add_widget ( widget ) if \"box\" not in attrs : attrs [ \"box\" ] = \"SINGLE\" try : self . box = attrs [ \"box\" ] # Splitter doesn't use boxes ATM. except KeyError : pass self . _mouse_target : Widget | None = None","title":"__init__()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.__iter__","text":"Gets an iterator of self._widgets. Yields: Type Description Iterator [ Widget ] The next widget. Source code in pytermgui/widgets/containers.py 257 258 259 260 261 262 263 264 265 def __iter__ ( self ) -> Iterator [ Widget ]: \"\"\"Gets an iterator of self._widgets. Yields: The next widget. \"\"\" for widget in self . _widgets : yield widget","title":"__iter__()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.__len__","text":"Gets the length of the widgets list. Returns: Type Description int An integer describing len(self._widgets). Source code in pytermgui/widgets/containers.py 267 268 269 270 271 272 273 274 def __len__ ( self ) -> int : \"\"\"Gets the length of the widgets list. Returns: An integer describing len(self._widgets). \"\"\" return len ( self . _widgets )","title":"__len__()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.__setitem__","text":"Sets an item in self._widgets. Parameters: Name Type Description Default index int The index to be set. required value Any The new widget at this index. required Source code in pytermgui/widgets/containers.py 288 289 290 291 292 293 294 295 296 def __setitem__ ( self , index : int , value : Any ) -> None : \"\"\"Sets an item in self._widgets. Args: index: The index to be set. value: The new widget at this index. \"\"\" self . _widgets [ index ] = value","title":"__setitem__()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.box","text":"Returns current box setting Returns: Type Description boxes . Box The currently set box instance. Source code in pytermgui/widgets/containers.py 183 184 185 186 187 188 189 190 191 @property def box ( self ) -> boxes . Box : \"\"\"Returns current box setting Returns: The currently set box instance. \"\"\" return self . _box","title":"box()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.center","text":"Centers this object to the given axis. Parameters: Name Type Description Default where CenteringPolicy | None A CenteringPolicy describing the place to center to None store bool When set, this centering will be reapplied during every print, as well as when calling this method with no arguments. True Returns: Type Description Container This Container. Source code in pytermgui/widgets/containers.py 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 def center ( self , where : CenteringPolicy | None = None , store : bool = True ) -> Container : \"\"\"Centers this object to the given axis. Args: where: A CenteringPolicy describing the place to center to store: When set, this centering will be reapplied during every print, as well as when calling this method with no arguments. Returns: This Container. \"\"\" # Refresh in case changes happened self . get_lines () if where is None : # See `enums.py` for explanation about this ignore. where = CenteringPolicy . get_default () # type: ignore centerx = centery = where is CenteringPolicy . ALL centerx |= where is CenteringPolicy . HORIZONTAL centery |= where is CenteringPolicy . VERTICAL pos = list ( self . pos ) if centerx : pos [ 0 ] = ( self . terminal . width - self . width + 2 ) // 2 if centery : pos [ 1 ] = ( self . terminal . height - self . height + 2 ) // 2 self . pos = ( pos [ 0 ], pos [ 1 ]) if store : self . centered_axis = where self . _prev_screen = self . terminal . size return self","title":"center()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.content_dimensions","text":"Gets the size (width, height) of the available content area. Source code in pytermgui/widgets/containers.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @property def content_dimensions ( self ) -> tuple [ int , int ]: \"\"\"Gets the size (width, height) of the available content area.\"\"\" if \"border\" not in self . chars : return self . width , self . height chars = self . _get_char ( \"border\" ) assert isinstance ( chars , list ) left , top , right , bottom = chars return ( self . width - real_length ( self . styles . border ( left + right )), self . height - sum ( 1 if real_length ( char ) else 0 for char in [ top , bottom ]), )","title":"content_dimensions()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.debug","text":"Returns a string with identifiable information on this widget. Returns: Type Description str A str in the form of a class construction. This string is in a form that str could have been used to create this Container. Source code in pytermgui/widgets/containers.py 962 963 964 965 966 967 968 969 970 971 972 973 974 def debug ( self ) -> str : \"\"\"Returns a string with identifiable information on this widget. Returns: A str in the form of a class construction. This string is in a form that __could have been__ used to create this Container. \"\"\" return ( f \" { type ( self ) . __name__ } (width= { self . width } , height= { self . height } \" + ( f \", id= { self . id } \" if self . id is not None else \"\" ) + \")\" )","title":"debug()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.execute_binding","text":"Executes a binding on self, and then on self._widgets. If a widget.execute_binding call returns True this function will too. Note that on success the function returns immediately; no further widgets are checked. Parameters: Name Type Description Default key Any The binding key. required ignore_any bool If set, keys.ANY_KEY bindings will not be executed. False Returns: Type Description bool True if any widget returned True, False otherwise. Source code in pytermgui/widgets/containers.py 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 def execute_binding ( self , key : Any , ignore_any : bool = False ) -> bool : \"\"\"Executes a binding on self, and then on self._widgets. If a widget.execute_binding call returns True this function will too. Note that on success the function returns immediately; no further widgets are checked. Args: key: The binding key. ignore_any: If set, `keys.ANY_KEY` bindings will not be executed. Returns: True if any widget returned True, False otherwise. \"\"\" if super () . execute_binding ( key , ignore_any = ignore_any ): return True selectables_index = 0 for widget in self . _widgets : if widget . execute_binding ( key ): selectables_index += widget . selected_index or 0 self . select ( selectables_index ) return True if widget . is_selectable : selectables_index += widget . selectables_length return False","title":"execute_binding()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.get_change","text":"Determines whether widget lines changed since the last call to this function. Source code in pytermgui/widgets/containers.py 213 214 215 216 217 218 219 220 221 222 223 224 225 def get_change ( self ) -> WidgetChange | None : \"\"\"Determines whether widget lines changed since the last call to this function.\"\"\" change = super () . get_change () if change is None : return None for widget in self . _widgets : if widget . get_change () is not None : self . dirty_widgets . append ( widget ) return change","title":"get_change()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.get_lines","text":"Gets all lines by spacing out inner widgets. This method reflects & applies both width settings, as well as the parent_align field. Returns: Type Description list [ str ] A list of all lines that represent this Container. Source code in pytermgui/widgets/containers.py 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 def get_lines ( self ) -> list [ str ]: \"\"\"Gets all lines by spacing out inner widgets. This method reflects & applies both width settings, as well as the `parent_align` field. Returns: A list of all lines that represent this Container. \"\"\" def _get_border ( left : str , char : str , right : str ) -> str : \"\"\"Gets a top or bottom border. Args: left: Left corner character. char: Border character filling between left & right. right: Right corner character. Returns: The border line. \"\"\" offset = real_length ( strip_markup ( left + right )) return ( self . styles . corner ( left ) + self . styles . border ( char * ( self . width - offset )) + self . styles . corner ( right ) ) lines : list [ str ] = [] borders = self . _get_char ( \"border\" ) corners = self . _get_char ( \"corner\" ) has_top_bottom = ( real_length ( borders [ 1 ]) > 0 , real_length ( borders [ 3 ]) > 0 ) align , offset = self . _get_aligners ( self , ( borders [ 0 ], borders [ 2 ])) overflow = self . overflow for widget in self . _widgets : align , offset = self . _get_aligners ( widget , ( borders [ 0 ], borders [ 2 ])) self . _update_width ( widget ) widget . pos = ( self . pos [ 0 ] + offset , self . pos [ 1 ] + len ( lines ) + ( 1 if has_top_bottom [ 0 ] else 0 ), ) widget_lines : list [ str ] = [] for line in widget . get_lines (): if len ( lines ) + len ( widget_lines ) >= self . height - sum ( has_top_bottom ): if overflow is Overflow . HIDE : break if overflow == Overflow . AUTO : overflow = Overflow . SCROLL widget_lines . append ( align ( line )) lines . extend ( widget_lines ) if overflow == Overflow . SCROLL : self . _max_scroll = len ( lines ) - self . height + sum ( has_top_bottom ) height = self . height - sum ( has_top_bottom ) self . _scroll_offset = max ( 0 , min ( self . _scroll_offset , len ( lines ) - height )) lines = lines [ self . _scroll_offset : self . _scroll_offset + height ] elif overflow == Overflow . RESIZE : self . height = len ( lines ) + sum ( has_top_bottom ) vertical_offset , lines = self . _apply_vertalign ( lines , self . height - len ( lines ) - sum ( has_top_bottom ), align ( \"\" ) ) for widget in self . _widgets : widget . pos = ( widget . pos [ 0 ], widget . pos [ 1 ] + vertical_offset ) if widget . is_selectable : # This buffer will be out of position, so we must clear it. widget . positioned_line_buffer = [] widget . get_lines () self . positioned_line_buffer . extend ( widget . positioned_line_buffer ) widget . positioned_line_buffer = [] if has_top_bottom [ 0 ]: lines . insert ( 0 , _get_border ( corners [ 0 ], borders [ 1 ], corners [ 1 ])) if has_top_bottom [ 1 ]: lines . append ( _get_border ( corners [ 3 ], borders [ 3 ], corners [ 2 ])) self . height = len ( lines ) return lines","title":"get_lines()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.handle_key","text":"Handles a keypress, returns its success. Parameters: Name Type Description Default key str A key str. required Returns: Type Description bool A boolean showing whether the key was handled. Source code in pytermgui/widgets/containers.py 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 def handle_key ( # pylint: disable=too-many-return-statements, too-many-branches self , key : str ) -> bool : \"\"\"Handles a keypress, returns its success. Args: key: A key str. Returns: A boolean showing whether the key was handled. \"\"\" def _is_nav ( key : str ) -> bool : \"\"\"Determine if a key is in the navigation sets\"\"\" return key in self . keys [ \"next\" ] | self . keys [ \"previous\" ] if self . selected is not None and self . selected . handle_key ( key ): return True scroll_actions = { ** { key : 1 for key in self . keys [ \"scroll_down\" ]}, ** { key : - 1 for key in self . keys [ \"scroll_up\" ]}, } if key in self . keys [ \"scroll_down\" ] | self . keys [ \"scroll_up\" ]: for widget in self . _widgets : if isinstance ( widget , Container ) and self . selected in widget : widget . handle_key ( key ) self . scroll ( scroll_actions [ key ]) return True # Only use navigation when there is more than one selectable if self . selectables_length >= 1 and _is_nav ( key ): if self . selected_index is None : self . select ( 0 ) return True handled = False assert isinstance ( self . selected_index , int ) if key in self . keys [ \"previous\" ]: # No more selectables left, user wants to exit Container # upwards. if self . selected_index == 0 : return False self . select ( self . selected_index - 1 ) handled = True elif key in self . keys [ \"next\" ]: # Stop selection at last element, return as unhandled new = self . selected_index + 1 if new == len ( self . selectables ): return False self . select ( new ) handled = True if handled : return True if key == keys . ENTER : if self . selected_index is None and self . selectables_length > 0 : self . select ( 0 ) if self . selected is not None : self . selected . handle_key ( key ) return True for widget in self . _widgets : if widget . execute_binding ( key ): return True return False","title":"handle_key()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.handle_mouse","text":"Handles mouse events. This, like all mouse handlers should, calls super()'s implementation first, to allow usage of on_{event} -type callbacks. After that, it tries to find a target widget within itself to handle the event. Each handler will return a boolean. This boolean is then used to figure out whether the targeted widget should be \"sticky\", i.e. a slider. Returning True will set that widget as the current mouse target, and all mouse events will be sent to it as long as it returns True. Parameters: Name Type Description Default event MouseEvent The event to handle. required Returns: Type Description bool Whether the parent of this widget should treat it as one to \"stick\" events bool to, e.g. to keep sending mouse events to it. One can \"unstick\" a widget by bool returning False in the handler. Source code in pytermgui/widgets/containers.py 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Handles mouse events. This, like all mouse handlers should, calls super()'s implementation first, to allow usage of `on_{event}`-type callbacks. After that, it tries to find a target widget within itself to handle the event. Each handler will return a boolean. This boolean is then used to figure out whether the targeted widget should be \"sticky\", i.e. a slider. Returning True will set that widget as the current mouse target, and all mouse events will be sent to it as long as it returns True. Args: event: The event to handle. Returns: Whether the parent of this widget should treat it as one to \"stick\" events to, e.g. to keep sending mouse events to it. One can \"unstick\" a widget by returning False in the handler. \"\"\" def _handle_scrolling () -> bool : \"\"\"Scrolls the container.\"\"\" if self . overflow != Overflow . SCROLL : return False if event . action is MouseAction . SCROLL_UP : return self . scroll ( - 1 ) if event . action is MouseAction . SCROLL_DOWN : return self . scroll ( 1 ) return False if super () . handle_mouse ( event ): return True if event . action is MouseAction . RELEASE and self . _mouse_target is not None : return self . _mouse_target . handle_mouse ( event ) if ( self . _mouse_target is not None and ( event . action . value . endswith ( \"drag\" ) or event . action . value . startswith ( \"scroll\" ) ) and self . _mouse_target . handle_mouse ( event ) ): return True release = MouseEvent ( MouseAction . RELEASE , event . position ) selectables_index = 0 event . position = ( event . position [ 0 ], event . position [ 1 ] + self . _scroll_offset ) handled = False for widget in self . _widgets : if ( widget . pos [ 1 ] - self . pos [ 1 ] - self . _scroll_offset > self . content_dimensions [ 1 ] ): break if widget . contains ( event . position ): handled = widget . handle_mouse ( event ) selectables_index += widget . selected_index or 0 # TODO: This really should be customizable somehow. if event . action is MouseAction . LEFT_CLICK : if handled and selectables_index < len ( self . selectables ): self . select ( selectables_index ) if self . _mouse_target is not None and self . _mouse_target is not widget : self . _mouse_target . handle_mouse ( release ) self . _mouse_target = widget break if widget . is_selectable : selectables_index += widget . selectables_length handled = handled or _handle_scrolling () return handled","title":"handle_mouse()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.lazy_add","text":"Adds other without running get_lines. This is analogous to `self._add_widget(other, run_get_lines=False). Parameters: Name Type Description Default other object The object to add. required Source code in pytermgui/widgets/containers.py 497 498 499 500 501 502 503 504 505 506 def lazy_add ( self , other : object ) -> None : \"\"\"Adds `other` without running get_lines. This is analogous to `self._add_widget(other, run_get_lines=False). Args: other: The object to add. \"\"\" self . _add_widget ( other , run_get_lines = False )","title":"lazy_add()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.pop","text":"Pops widget from self._widgets. Analogous to self._widgets.pop(index). Parameters: Name Type Description Default index int The index to operate on. -1 Returns: Type Description Widget The widget that was popped off the list. Source code in pytermgui/widgets/containers.py 634 635 636 637 638 639 640 641 642 643 644 645 646 def pop ( self , index : int = - 1 ) -> Widget : \"\"\"Pops widget from self._widgets. Analogous to self._widgets.pop(index). Args: index: The index to operate on. Returns: The widget that was popped off the list. \"\"\" return self . _widgets . pop ( index )","title":"pop()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.print","text":"Prints this Container. If the screen size has changed since last print call, the object will be centered based on its centered_axis . Source code in pytermgui/widgets/containers.py 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 def print ( self ) -> None : \"\"\"Prints this Container. If the screen size has changed since last `print` call, the object will be centered based on its `centered_axis`. \"\"\" if not self . terminal . size == self . _prev_screen : clear () self . center ( self . centered_axis ) self . _prev_screen = self . terminal . size if self . allow_fullscreen : self . pos = self . terminal . origin with cursor_at ( self . pos ) as print_here : for line in self . get_lines (): print_here ( line ) self . _has_printed = True","title":"print()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.remove","text":"Remove widget from self._widgets Analogous to self._widgets.remove(other). Parameters: Name Type Description Default other Widget The widget to remove. required Source code in pytermgui/widgets/containers.py 648 649 650 651 652 653 654 655 656 657 def remove ( self , other : Widget ) -> None : \"\"\"Remove widget from self._widgets Analogous to self._widgets.remove(other). Args: other: The widget to remove. \"\"\" return self . _widgets . remove ( other )","title":"remove()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.select","text":"Selects inner subwidget. Parameters: Name Type Description Default index int | None The index to select. None Raises: Type Description IndexError The index provided was beyond len(self.selectables). Source code in pytermgui/widgets/containers.py 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 def select ( self , index : int | None = None ) -> None : \"\"\"Selects inner subwidget. Args: index: The index to select. Raises: IndexError: The index provided was beyond len(self.selectables). \"\"\" # Unselect all sub-elements for other in self . _widgets : if other . selectables_length > 0 : other . select ( None ) if index is not None : index = max ( 0 , min ( index , len ( self . selectables ) - 1 )) widget , inner_index = self . selectables [ index ] widget . select ( inner_index ) self . selected_index = index","title":"select()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.selectables","text":"Gets all selectable widgets and their inner indices. This is used in order to have a constant reference to all selectable indices within this widget. Returns: Type Description list [ tuple [ Widget , int ]] A list of tuples containing a widget and an integer each. For each widget that is list [ tuple [ Widget , int ]] withing this one, it is added to this list as many times as it has selectables. Each list [ tuple [ Widget , int ]] of the integers correspond to a selectable_index within the widget. list [ tuple [ Widget , int ]] For example, a Container with a Button, InputField and an inner Container containing list [ tuple [ Widget , int ]] 3 selectables might return something like this: list [ tuple [ Widget , int ]] ``` list [ tuple [ Widget , int ]] [ (Button(...), 0), (InputField(...), 0), (Container(...), 0), (Container(...), 1), (Container(...), 2), list [ tuple [ Widget , int ]] ] list [ tuple [ Widget , int ]] ``` Source code in pytermgui/widgets/containers.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 @property def selectables ( self ) -> list [ tuple [ Widget , int ]]: \"\"\"Gets all selectable widgets and their inner indices. This is used in order to have a constant reference to all selectable indices within this widget. Returns: A list of tuples containing a widget and an integer each. For each widget that is withing this one, it is added to this list as many times as it has selectables. Each of the integers correspond to a selectable_index within the widget. For example, a Container with a Button, InputField and an inner Container containing 3 selectables might return something like this: ``` [ (Button(...), 0), (InputField(...), 0), (Container(...), 0), (Container(...), 1), (Container(...), 2), ] ``` \"\"\" _selectables : list [ tuple [ Widget , int ]] = [] for widget in self . _widgets : if not widget . is_selectable : continue for i , ( inner , _ ) in enumerate ( widget . selectables ): _selectables . append (( inner , i )) return _selectables","title":"selectables()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.selectables_length","text":"Gets the length of the selectables list. Returns: Type Description int An integer equal to the length of self.selectables . Source code in pytermgui/widgets/containers.py 154 155 156 157 158 159 160 161 162 @property def selectables_length ( self ) -> int : \"\"\"Gets the length of the selectables list. Returns: An integer equal to the length of `self.selectables`. \"\"\" return len ( self . selectables )","title":"selectables_length()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.selected","text":"Returns the currently selected object Returns: Type Description Widget | None The currently selected widget if selected_index is not None, Widget | None otherwise None. Source code in pytermgui/widgets/containers.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 @property def selected ( self ) -> Widget | None : \"\"\"Returns the currently selected object Returns: The currently selected widget if selected_index is not None, otherwise None. \"\"\" # TODO: Add deeper selection if self . selected_index is None : return None if self . selected_index >= len ( self . selectables ): return None return self . selectables [ self . selected_index ][ 0 ]","title":"selected()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.serialize","text":"Serializes this Container, adding in serializations of all widgets. See pytermgui.widgets.base.Widget.serialize for more info. Returns: Type Description dict [ str , Any ] The dictionary containing all serialized data. Source code in pytermgui/widgets/containers.py 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 def serialize ( self ) -> dict [ str , Any ]: \"\"\"Serializes this Container, adding in serializations of all widgets. See `pytermgui.widgets.base.Widget.serialize` for more info. Returns: The dictionary containing all serialized data. \"\"\" out = super () . serialize () out [ \"_widgets\" ] = [] for widget in self . _widgets : out [ \"_widgets\" ] . append ( widget . serialize ()) return out","title":"serialize()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.set_recursive_depth","text":"Set depth for this Container and all its children. All inner widgets will receive value+1 as their new depth. Parameters: Name Type Description Default value int The new depth to use as the base depth. required Source code in pytermgui/widgets/containers.py 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 def set_recursive_depth ( self , value : int ) -> None : \"\"\"Set depth for this Container and all its children. All inner widgets will receive value+1 as their new depth. Args: value: The new depth to use as the base depth. \"\"\" self . depth = value for widget in self . _widgets : if isinstance ( widget , Container ): widget . set_recursive_depth ( value + 1 ) else : widget . depth = value","title":"set_recursive_depth()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.set_widgets","text":"Sets new list in place of self._widgets. Parameters: Name Type Description Default new list [ Widget ] The new widget list. required Source code in pytermgui/widgets/containers.py 606 607 608 609 610 611 612 613 614 615 def set_widgets ( self , new : list [ Widget ]) -> None : \"\"\"Sets new list in place of self._widgets. Args: new: The new widget list. \"\"\" self . _widgets = [] for widget in new : self . _add_widget ( widget )","title":"set_widgets()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.sidelength","text":"Gets the length of left and right borders combined. Returns: Type Description int An integer equal to the pytermgui.helpers.real_length of the concatenation of the left and right borders of this widget, both with their respective styles applied. Source code in pytermgui/widgets/containers.py 88 89 90 91 92 93 94 95 96 97 98 @property def sidelength ( self ) -> int : \"\"\"Gets the length of left and right borders combined. Returns: An integer equal to the `pytermgui.helpers.real_length` of the concatenation of the left and right borders of this widget, both with their respective styles applied. \"\"\" return self . width - self . content_dimensions [ 0 ]","title":"sidelength()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.wipe","text":"Wipes the characters occupied by the object Source code in pytermgui/widgets/containers.py 933 934 935 936 937 938 def wipe ( self ) -> None : \"\"\"Wipes the characters occupied by the object\"\"\" with cursor_at ( self . pos ) as print_here : for line in self . get_lines (): print_here ( real_length ( line ) * \" \" )","title":"wipe()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Splitter","text":"Bases: Container A widget that displays other widgets, stacked horizontally. Source code in pytermgui/widgets/containers.py 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 class Splitter ( Container ): \"\"\"A widget that displays other widgets, stacked horizontally.\"\"\" styles = w_styles . StyleManager ( separator = \"surface\" , fill = \"background\" ) chars : dict [ str , list [ str ] | str ] = { \"separator\" : \" | \" } keys = { \"previous\" : { keys . LEFT , \"h\" , keys . CTRL_B }, \"next\" : { keys . RIGHT , \"l\" , keys . CTRL_F }, } parent_align = HorizontalAlignment . RIGHT def _align ( self , alignment : HorizontalAlignment , target_width : int , line : str ) -> tuple [ int , str ]: \"\"\"Align a line r/wordavalanches\"\"\" available = target_width - real_length ( line ) fill_style = self . _get_style ( \"fill\" ) char = fill_style ( \" \" ) line = fill_style ( line ) if alignment == HorizontalAlignment . CENTER : padding , offset = divmod ( available , 2 ) return padding , padding * char + line + ( padding + offset ) * char if alignment == HorizontalAlignment . RIGHT : return available , available * char + line return 0 , line + available * char @property def content_dimensions ( self ) -> tuple [ int , int ]: \"\"\"Returns the available area for widgets.\"\"\" return self . height , self . width def get_lines ( self ) -> list [ str ]: \"\"\"Join all widgets horizontally.\"\"\" # An error will be raised if `separator` is not the correct type (str). separator = self . _get_style ( \"separator\" )( self . _get_char ( \"separator\" )) # type: ignore separator_length = real_length ( separator ) target_width , error = divmod ( self . width - ( len ( self . _widgets ) - 1 ) * separator_length , len ( self . _widgets ) ) vertical_lines = [] total_offset = 0 for widget in self . _widgets : inner = [] if widget . size_policy is SizePolicy . STATIC : target_width += target_width - widget . width width = widget . width else : widget . width = target_width + error width = widget . width error = 0 aligned : str | None = None for line in widget . get_lines (): # See `enums.py` for information about this ignore padding , aligned = self . _align ( cast ( HorizontalAlignment , widget . parent_align ), width , line ) inner . append ( aligned ) widget . pos = ( self . pos [ 0 ] + padding + total_offset , self . pos [ 1 ] + ( 1 if type ( widget ) . __name__ == \"Container\" else 0 ), ) if aligned is not None : total_offset += real_length ( inner [ - 1 ]) + separator_length vertical_lines . append ( inner ) lines = [] for horizontal in zip_longest ( * vertical_lines , fillvalue = \" \" * target_width ): lines . append (( reset () + separator ) . join ( horizontal )) self . height = max ( widget . height for widget in self ) return lines","title":"Splitter"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Splitter.content_dimensions","text":"Returns the available area for widgets. Source code in pytermgui/widgets/containers.py 1012 1013 1014 1015 1016 @property def content_dimensions ( self ) -> tuple [ int , int ]: \"\"\"Returns the available area for widgets.\"\"\" return self . height , self . width","title":"content_dimensions()"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Splitter.get_lines","text":"Join all widgets horizontally. Source code in pytermgui/widgets/containers.py 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 def get_lines ( self ) -> list [ str ]: \"\"\"Join all widgets horizontally.\"\"\" # An error will be raised if `separator` is not the correct type (str). separator = self . _get_style ( \"separator\" )( self . _get_char ( \"separator\" )) # type: ignore separator_length = real_length ( separator ) target_width , error = divmod ( self . width - ( len ( self . _widgets ) - 1 ) * separator_length , len ( self . _widgets ) ) vertical_lines = [] total_offset = 0 for widget in self . _widgets : inner = [] if widget . size_policy is SizePolicy . STATIC : target_width += target_width - widget . width width = widget . width else : widget . width = target_width + error width = widget . width error = 0 aligned : str | None = None for line in widget . get_lines (): # See `enums.py` for information about this ignore padding , aligned = self . _align ( cast ( HorizontalAlignment , widget . parent_align ), width , line ) inner . append ( aligned ) widget . pos = ( self . pos [ 0 ] + padding + total_offset , self . pos [ 1 ] + ( 1 if type ( widget ) . __name__ == \"Container\" else 0 ), ) if aligned is not None : total_offset += real_length ( inner [ - 1 ]) + separator_length vertical_lines . append ( inner ) lines = [] for horizontal in zip_longest ( * vertical_lines , fillvalue = \" \" * target_width ): lines . append (( reset () + separator ) . join ( horizontal )) self . height = max ( widget . height for widget in self ) return lines","title":"get_lines()"},{"location":"reference/pytermgui/widgets/fancy_repr/","text":"A widget to wrap objects supporting the fancy_repr protocol. FancyReprWidget Bases: Widget A widget that wraps objects supporting the fancy_repr protocol. Source code in pytermgui/widgets/fancy_repr.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class FancyReprWidget ( Widget ): \"\"\"A widget that wraps objects supporting the `fancy_repr` protocol.\"\"\" def __init__ ( self , target : SupportsFancyRepr , starts_at : int = 0 , ** attrs : Any ) -> None : self . target = target self . starts_at = starts_at super () . __init__ ( ** attrs ) def get_lines ( self ) -> list [ str ]: \"\"\"Builds fancy repr of target and returns it.\"\"\" start = self . starts_at lines = [ tim . parse ( line ) for line in build_fancy_repr ( self . target ) . splitlines ()[ start :] ] self . width = max ( len ( line ) for line in lines ) self . height = len ( lines ) return lines get_lines () Builds fancy repr of target and returns it. Source code in pytermgui/widgets/fancy_repr.py 25 26 27 28 29 30 31 32 33 34 35 36 37 def get_lines ( self ) -> list [ str ]: \"\"\"Builds fancy repr of target and returns it.\"\"\" start = self . starts_at lines = [ tim . parse ( line ) for line in build_fancy_repr ( self . target ) . splitlines ()[ start :] ] self . width = max ( len ( line ) for line in lines ) self . height = len ( lines ) return lines","title":"fancy_repr"},{"location":"reference/pytermgui/widgets/fancy_repr/#pytermgui.widgets.fancy_repr.FancyReprWidget","text":"Bases: Widget A widget that wraps objects supporting the fancy_repr protocol. Source code in pytermgui/widgets/fancy_repr.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class FancyReprWidget ( Widget ): \"\"\"A widget that wraps objects supporting the `fancy_repr` protocol.\"\"\" def __init__ ( self , target : SupportsFancyRepr , starts_at : int = 0 , ** attrs : Any ) -> None : self . target = target self . starts_at = starts_at super () . __init__ ( ** attrs ) def get_lines ( self ) -> list [ str ]: \"\"\"Builds fancy repr of target and returns it.\"\"\" start = self . starts_at lines = [ tim . parse ( line ) for line in build_fancy_repr ( self . target ) . splitlines ()[ start :] ] self . width = max ( len ( line ) for line in lines ) self . height = len ( lines ) return lines","title":"FancyReprWidget"},{"location":"reference/pytermgui/widgets/fancy_repr/#pytermgui.widgets.fancy_repr.FancyReprWidget.get_lines","text":"Builds fancy repr of target and returns it. Source code in pytermgui/widgets/fancy_repr.py 25 26 27 28 29 30 31 32 33 34 35 36 37 def get_lines ( self ) -> list [ str ]: \"\"\"Builds fancy repr of target and returns it.\"\"\" start = self . starts_at lines = [ tim . parse ( line ) for line in build_fancy_repr ( self . target ) . splitlines ()[ start :] ] self . width = max ( len ( line ) for line in lines ) self . height = len ( lines ) return lines","title":"get_lines()"},{"location":"reference/pytermgui/widgets/inline/","text":"This module lets you run widgets as an inline terminal prompt. inline ( widget , * , exit_on = None , width = None ) Runs a widget as an inline terminal prompt. This can be useful for adding GUI-like functionality within CLI scripts, as it gives you access to the widget system for building prompts, built in keyboard & mouse handling and everything else that makes PyTermGUI's WindowManager work, without the commitment to a full-screen app. Parameters: Name Type Description Default widget T Some widget that will be run. required width int | None The width to set for the widget. If nothing is given, the widget's width is unchanged. None Returns: Type Description T The same widget. This allows defining and running a prompt in the same line: prompt = inline ( _build_prompt ()) Source code in pytermgui/widgets/inline.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def inline ( widget : T , * , exit_on : list [ str ] | None = None , width : int | None = None ) -> T : \"\"\"Runs a widget as an inline terminal prompt. This can be useful for adding GUI-like functionality within CLI scripts, as it gives you access to the widget system for building prompts, built in keyboard & mouse handling and everything else that makes PyTermGUI's WindowManager work, without the commitment to a full-screen app. Args: widget: Some widget that will be run. width: The width to set for the widget. If nothing is given, the widget's width is unchanged. Returns: The same widget. This allows defining and running a prompt in the same line: ```python prompt = inline(_build_prompt()) ``` \"\"\" # Make sure we use the global terminal terminal = get_terminal () unset_echo () hide_cursor () if width is not None : widget . width = width if exit_on is None : exit_on = [ keys . CTRL_C , keys . ENTER ] widget . pos = report_cursor () def _print_widget () -> None : save_cursor () for line in widget . get_lines (): print ( line ) for pos , line in widget . positioned_line_buffer : print_to ( pos , line ) widget . positioned_line_buffer = [] restore_cursor () def _clear_widget () -> None : save_cursor () for _ in range ( widget . height ): clear ( \"line\" ) terminal . write ( \" \\n \" ) restore_cursor () terminal . flush () _print_widget () with mouse_handler ([ \"press_hold\" , \"hover\" ], \"decimal_xterm\" ) as translate : while True : key = getch ( interrupts = False ) if key in exit_on : break if not widget . handle_key ( key ): events = translate ( key ) # Don't try iterating when there are no events if events is None : continue for event in events : if event is None : continue widget . handle_mouse ( event ) _clear_widget () _print_widget () _clear_widget () set_echo () show_cursor () return widget","title":"inline"},{"location":"reference/pytermgui/widgets/inline/#pytermgui.widgets.inline.inline","text":"Runs a widget as an inline terminal prompt. This can be useful for adding GUI-like functionality within CLI scripts, as it gives you access to the widget system for building prompts, built in keyboard & mouse handling and everything else that makes PyTermGUI's WindowManager work, without the commitment to a full-screen app. Parameters: Name Type Description Default widget T Some widget that will be run. required width int | None The width to set for the widget. If nothing is given, the widget's width is unchanged. None Returns: Type Description T The same widget. This allows defining and running a prompt in the same line: prompt = inline ( _build_prompt ()) Source code in pytermgui/widgets/inline.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def inline ( widget : T , * , exit_on : list [ str ] | None = None , width : int | None = None ) -> T : \"\"\"Runs a widget as an inline terminal prompt. This can be useful for adding GUI-like functionality within CLI scripts, as it gives you access to the widget system for building prompts, built in keyboard & mouse handling and everything else that makes PyTermGUI's WindowManager work, without the commitment to a full-screen app. Args: widget: Some widget that will be run. width: The width to set for the widget. If nothing is given, the widget's width is unchanged. Returns: The same widget. This allows defining and running a prompt in the same line: ```python prompt = inline(_build_prompt()) ``` \"\"\" # Make sure we use the global terminal terminal = get_terminal () unset_echo () hide_cursor () if width is not None : widget . width = width if exit_on is None : exit_on = [ keys . CTRL_C , keys . ENTER ] widget . pos = report_cursor () def _print_widget () -> None : save_cursor () for line in widget . get_lines (): print ( line ) for pos , line in widget . positioned_line_buffer : print_to ( pos , line ) widget . positioned_line_buffer = [] restore_cursor () def _clear_widget () -> None : save_cursor () for _ in range ( widget . height ): clear ( \"line\" ) terminal . write ( \" \\n \" ) restore_cursor () terminal . flush () _print_widget () with mouse_handler ([ \"press_hold\" , \"hover\" ], \"decimal_xterm\" ) as translate : while True : key = getch ( interrupts = False ) if key in exit_on : break if not widget . handle_key ( key ): events = translate ( key ) # Don't try iterating when there are no events if events is None : continue for event in events : if event is None : continue widget . handle_mouse ( event ) _clear_widget () _print_widget () _clear_widget () set_echo () show_cursor () return widget","title":"inline()"},{"location":"reference/pytermgui/widgets/input_field/","text":"This module contains the InputField class. Cursor dataclass Bases: Iterable A simple dataclass representing the InputField's cursor. Source code in pytermgui/widgets/input_field.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @dataclass class Cursor ( Iterable ): \"\"\"A simple dataclass representing the InputField's cursor.\"\"\" row : int col : int def __iadd__ ( self , difference : tuple [ int , int ]) -> Cursor : \"\"\"Move the cursor by the difference.\"\"\" row , col = difference self . row += row self . col += col return self def __iter__ ( self ) -> Iterator [ int ]: return iter (( self . row , self . col )) def __len__ ( self ) -> int : return 2 __iadd__ ( difference ) Move the cursor by the difference. Source code in pytermgui/widgets/input_field.py 25 26 27 28 29 30 31 32 33 def __iadd__ ( self , difference : tuple [ int , int ]) -> Cursor : \"\"\"Move the cursor by the difference.\"\"\" row , col = difference self . row += row self . col += col return self InputField Bases: Widget An element to display user input Source code in pytermgui/widgets/input_field.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 class InputField ( Widget ): # pylint: disable=too-many-instance-attributes \"\"\"An element to display user input\"\"\" styles = w_styles . StyleManager ( value = \"\" , prompt = \"surface+2\" , cursor = \"@primary dim #auto\" , ) keys = { \"move_left\" : { keys . LEFT }, \"move_right\" : { keys . RIGHT }, \"move_up\" : { keys . UP }, \"move_down\" : { keys . DOWN }, \"select_left\" : { keys . SHIFT_LEFT }, \"select_right\" : { keys . SHIFT_RIGHT }, \"select_up\" : { keys . SHIFT_UP }, \"select_down\" : { keys . SHIFT_DOWN }, } parent_align = HorizontalAlignment . LEFT def __init__ ( self , value : str = \"\" , * , prompt : str = \"\" , tablength : int = 4 , multiline : bool = False , cursor : Cursor | None = None , ** attrs : Any , ) -> None : \"\"\"Initialize object\"\"\" super () . __init__ ( ** attrs ) if \"width\" not in attrs : self . width = len ( value ) self . prompt = prompt self . height = 1 self . tablength = tablength self . multiline = multiline self . cursor = cursor or Cursor ( 0 , len ( value )) self . _lines = value . splitlines () or [ \"\" ] self . _selection_length = 1 self . _styled_cache : list [ str ] | None = self . _style_and_break_lines () self . _cached_state : int = self . width self . _drag_start : tuple [ int , int ] | None = None @property def selectables_length ( self ) -> int : \"\"\"Get length of selectables in object\"\"\" return 1 @property def value ( self ) -> str : \"\"\"Returns the internal value of this field.\"\"\" return \" \\n \" . join ( self . _lines ) @property def selection ( self ) -> str : \"\"\"Returns the currently selected span of text.\"\"\" start , end = sorted ([ self . cursor . col , self . cursor . col + self . _selection_length ]) return self . _lines [ self . cursor . row ][ start : end ] def _cache_is_valid ( self ) -> bool : \"\"\"Determines if the styled line cache is still usable.\"\"\" return self . width == self . _cached_state def _style_and_break_lines ( self ) -> list [ str ]: \"\"\"Styles and breaks self._lines.\"\"\" document = ( self . styles . prompt ( self . prompt ) + self . styles . value ( self . value ) ) . splitlines () lines : list [ str ] = [] width = self . width extend = lines . extend for line in document : extend ( break_line ( line . replace ( \" \\n \" , \" \\\\ n\" ), width , fill = \" \" )) extend ( \"\" ) return lines def update_selection ( self , count : int , correct_zero_length : bool = True ) -> None : \"\"\"Updates the selection state. Args: count: How many characters the cursor should change by. Negative for selecting leftward, positive for right. correct_zero_length: If set, when the selection length is 0 both the cursor and the selection length are manipulated to keep the original selection start while moving the selection in more of the way the user might expect. \"\"\" self . _selection_length += count if correct_zero_length and abs ( self . _selection_length ) == 0 : self . _selection_length += 2 if count > 0 else - 2 self . move_cursor (( 0 , ( - 1 if count > 0 else 1 ))) def delete_back ( self , count : int = 1 ) -> str : \"\"\"Deletes `count` characters from the cursor, backwards. Args: count: How many characters should be deleted. Returns: The deleted string. \"\"\" row , col = self . cursor if len ( self . _lines ) <= row : return \"\" line = self . _lines [ row ] start , end = sorted ([ col , col - count ]) start = max ( 0 , start ) self . _lines [ row ] = line [: start ] + line [ end :] self . _styled_cache = None if self . _lines [ row ] == \"\" : self . move_cursor (( - 1 , len ( self . _lines [ row - 1 ]))) return self . _lines . pop ( row ) if count > 0 : self . move_cursor (( 0 , - count )) return line [ col - count : col ] def insert_text ( self , text : str ) -> None : \"\"\"Inserts text at the cursor location.\"\"\" row , col = self . cursor if len ( self . _lines ) <= row : self . _lines . insert ( row , \"\" ) line = self . _lines [ row ] self . _lines [ row ] = line [: col ] + text + line [ col :] self . move_cursor (( 0 , len ( text ))) self . _styled_cache = None def handle_action ( self , action : str ) -> bool : \"\"\"Handles some action. This will be expanded in the future to allow using all behaviours with just their actions. \"\"\" cursors = { \"move_left\" : ( 0 , - 1 ), \"move_right\" : ( 0 , 1 ), \"move_up\" : ( - 1 , 0 ), \"move_down\" : ( 1 , 0 ), } if action . startswith ( \"move_\" ): row , col = cursors [ action ] if self . cursor . row + row > len ( self . _lines ): self . _lines . append ( \"\" ) col += self . _selection_length if self . _selection_length > 0 : col -= 1 self . _selection_length = 1 self . move_cursor (( row , col )) return True if action . startswith ( \"select_\" ): if action == \"select_right\" : self . update_selection ( 1 ) elif action == \"select_left\" : self . update_selection ( - 1 ) return True return False # TODO: This could probably be simplified by a wider adoption of the action pattern. def handle_key ( # pylint: disable=too-many-return-statements, too-many-branches self , key : str ) -> bool : \"\"\"Adds text to the field, or moves the cursor.\"\"\" if self . execute_binding ( key , ignore_any = True ): return True for name , options in self . keys . items (): if ( name . rsplit ( \"_\" , maxsplit = 1 )[ - 1 ] in ( \"up\" , \"down\" ) and not self . multiline ): continue if key in options : return self . handle_action ( name ) if key == keys . TAB : if not self . multiline : return False for _ in range ( self . tablength ): self . handle_key ( \" \" ) return True if key in string . printable and key not in \" \\x0c\\x0b \" : if key == keys . ENTER : if not self . multiline : return False line = self . _lines [ self . cursor . row ] left , right = line [: self . cursor . col ], line [ self . cursor . col :] self . _lines [ self . cursor . row ] = left self . _lines . insert ( self . cursor . row + 1 , right ) self . move_cursor (( 1 , - self . cursor . col )) self . _styled_cache = None else : self . insert_text ( key ) if keys . ANY_KEY in self . _bindings : method , _ = self . _bindings [ keys . ANY_KEY ] method ( self , key ) return True if key == keys . BACKSPACE : if self . _selection_length == 1 : self . delete_back ( 1 ) else : self . delete_back ( - self . _selection_length ) # self.handle_action(\"move_left\") # if self._selection_length == 1: self . _selection_length = 1 self . _styled_cache = None return True return False def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Allows point-and-click selection.\"\"\" x_offset = event . position [ 0 ] - self . pos [ 0 ] y_offset = event . position [ 1 ] - self . pos [ 1 ] if y_offset == 0 : x_offset -= len ( self . prompt ) if x_offset < 0 : return False # Set cursor to mouse location if event . action is MouseAction . LEFT_CLICK : if not y_offset < len ( self . _lines ): return False line = self . _lines [ y_offset ] if y_offset == 0 : line = self . prompt + line self . move_cursor (( y_offset , min ( len ( line ), x_offset )), absolute = True ) self . _drag_start = ( x_offset , y_offset ) self . _selection_length = 1 return True # Select text using dragging the mouse if event . action is MouseAction . LEFT_DRAG and self . _drag_start is not None : change = x_offset - self . _drag_start [ 0 ] self . update_selection ( change - self . _selection_length + 1 , correct_zero_length = False ) return True return super () . handle_mouse ( event ) def move_cursor ( self , new : tuple [ int , int ], * , absolute : bool = False ) -> None : \"\"\"Moves the cursor, then possible re-positions it to a valid location. Args: new: The new set of (y, x) positions to use. absolute: If set, `new` will be interpreted as absolute coordinates, instead of being added on top of the current ones. \"\"\" if len ( self . _lines ) == 0 : return if absolute : new_y , new_x = new self . cursor . row = new_y self . cursor . col = new_x else : self . cursor += new self . cursor . row = max ( 0 , min ( self . cursor . row , len ( self . _lines ) - 1 )) row , col = self . cursor line = self . _lines [ row ] # Going left, possibly upwards if col < 0 : if row <= 0 : self . cursor . col = 0 else : self . cursor . row -= 1 line = self . _lines [ self . cursor . row ] self . cursor . col = len ( line ) # Going right, possibly downwards elif col > len ( line ) and line != \"\" : if len ( self . _lines ) > row + 1 : self . cursor . row += 1 self . cursor . col = 0 line = self . _lines [ self . cursor . row ] self . cursor . col = max ( 0 , min ( self . cursor . col , len ( line ))) def get_lines ( self ) -> list [ str ]: \"\"\"Builds the input field's lines.\"\"\" if not self . _cache_is_valid () or self . _styled_cache is None : self . _styled_cache = self . _style_and_break_lines () lines = self . _styled_cache row , col = self . cursor if len ( self . _lines ) == 0 : line = \" \" else : line = self . _lines [ row ] start = col cursor_char = \" \" if len ( line ) > col : start = col end = col + self . _selection_length start , end = sorted ([ start , end ]) try : cursor_char = line [ start : end ] except IndexError as error : raise ValueError ( f \"Invalid index in { line !r} : { col } \" ) from error style_cursor = ( self . styles . value if self . selected_index is None else self . styles . cursor ) # TODO: This is horribly hackish, but is the only way to \"get around\" the # limits of the current scrolling techniques. Should be refactored # once a better solution is available if self . parent is not None and self . selected_index is not None : offset = 0 parent = self . parent while hasattr ( parent , \"parent\" ): offset += getattr ( parent , \"_scroll_offset\" ) parent = parent . parent # type: ignore offset_row = - offset + row offset_col = start + ( len ( self . prompt ) if row == 0 else 0 ) if offset_col > self . width - 1 : offset_col -= self . width offset_row += 1 row += 1 if row >= len ( lines ): lines . append ( self . styles . value ( \"\" )) position = ( self . pos [ 0 ] + offset_col , self . pos [ 1 ] + offset_row , ) self . positioned_line_buffer . append ( ( position , style_cursor ( cursor_char )) # type: ignore ) lines = lines or [ \"\" ] self . height = len ( lines ) return lines __init__ ( value = '' , * , prompt = '' , tablength = 4 , multiline = False , cursor = None , attrs ) Initialize object Source code in pytermgui/widgets/input_field.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def __init__ ( self , value : str = \"\" , * , prompt : str = \"\" , tablength : int = 4 , multiline : bool = False , cursor : Cursor | None = None , ** attrs : Any , ) -> None : \"\"\"Initialize object\"\"\" super () . __init__ ( ** attrs ) if \"width\" not in attrs : self . width = len ( value ) self . prompt = prompt self . height = 1 self . tablength = tablength self . multiline = multiline self . cursor = cursor or Cursor ( 0 , len ( value )) self . _lines = value . splitlines () or [ \"\" ] self . _selection_length = 1 self . _styled_cache : list [ str ] | None = self . _style_and_break_lines () self . _cached_state : int = self . width self . _drag_start : tuple [ int , int ] | None = None delete_back ( count = 1 ) Deletes count characters from the cursor, backwards. Parameters: Name Type Description Default count int How many characters should be deleted. 1 Returns: Type Description str The deleted string. Source code in pytermgui/widgets/input_field.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def delete_back ( self , count : int = 1 ) -> str : \"\"\"Deletes `count` characters from the cursor, backwards. Args: count: How many characters should be deleted. Returns: The deleted string. \"\"\" row , col = self . cursor if len ( self . _lines ) <= row : return \"\" line = self . _lines [ row ] start , end = sorted ([ col , col - count ]) start = max ( 0 , start ) self . _lines [ row ] = line [: start ] + line [ end :] self . _styled_cache = None if self . _lines [ row ] == \"\" : self . move_cursor (( - 1 , len ( self . _lines [ row - 1 ]))) return self . _lines . pop ( row ) if count > 0 : self . move_cursor (( 0 , - count )) return line [ col - count : col ] get_lines () Builds the input field's lines. Source code in pytermgui/widgets/input_field.py 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 def get_lines ( self ) -> list [ str ]: \"\"\"Builds the input field's lines.\"\"\" if not self . _cache_is_valid () or self . _styled_cache is None : self . _styled_cache = self . _style_and_break_lines () lines = self . _styled_cache row , col = self . cursor if len ( self . _lines ) == 0 : line = \" \" else : line = self . _lines [ row ] start = col cursor_char = \" \" if len ( line ) > col : start = col end = col + self . _selection_length start , end = sorted ([ start , end ]) try : cursor_char = line [ start : end ] except IndexError as error : raise ValueError ( f \"Invalid index in { line !r} : { col } \" ) from error style_cursor = ( self . styles . value if self . selected_index is None else self . styles . cursor ) # TODO: This is horribly hackish, but is the only way to \"get around\" the # limits of the current scrolling techniques. Should be refactored # once a better solution is available if self . parent is not None and self . selected_index is not None : offset = 0 parent = self . parent while hasattr ( parent , \"parent\" ): offset += getattr ( parent , \"_scroll_offset\" ) parent = parent . parent # type: ignore offset_row = - offset + row offset_col = start + ( len ( self . prompt ) if row == 0 else 0 ) if offset_col > self . width - 1 : offset_col -= self . width offset_row += 1 row += 1 if row >= len ( lines ): lines . append ( self . styles . value ( \"\" )) position = ( self . pos [ 0 ] + offset_col , self . pos [ 1 ] + offset_row , ) self . positioned_line_buffer . append ( ( position , style_cursor ( cursor_char )) # type: ignore ) lines = lines or [ \"\" ] self . height = len ( lines ) return lines handle_action ( action ) Handles some action. This will be expanded in the future to allow using all behaviours with just their actions. Source code in pytermgui/widgets/input_field.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def handle_action ( self , action : str ) -> bool : \"\"\"Handles some action. This will be expanded in the future to allow using all behaviours with just their actions. \"\"\" cursors = { \"move_left\" : ( 0 , - 1 ), \"move_right\" : ( 0 , 1 ), \"move_up\" : ( - 1 , 0 ), \"move_down\" : ( 1 , 0 ), } if action . startswith ( \"move_\" ): row , col = cursors [ action ] if self . cursor . row + row > len ( self . _lines ): self . _lines . append ( \"\" ) col += self . _selection_length if self . _selection_length > 0 : col -= 1 self . _selection_length = 1 self . move_cursor (( row , col )) return True if action . startswith ( \"select_\" ): if action == \"select_right\" : self . update_selection ( 1 ) elif action == \"select_left\" : self . update_selection ( - 1 ) return True return False handle_key ( key ) Adds text to the field, or moves the cursor. Source code in pytermgui/widgets/input_field.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def handle_key ( # pylint: disable=too-many-return-statements, too-many-branches self , key : str ) -> bool : \"\"\"Adds text to the field, or moves the cursor.\"\"\" if self . execute_binding ( key , ignore_any = True ): return True for name , options in self . keys . items (): if ( name . rsplit ( \"_\" , maxsplit = 1 )[ - 1 ] in ( \"up\" , \"down\" ) and not self . multiline ): continue if key in options : return self . handle_action ( name ) if key == keys . TAB : if not self . multiline : return False for _ in range ( self . tablength ): self . handle_key ( \" \" ) return True if key in string . printable and key not in \" \\x0c\\x0b \" : if key == keys . ENTER : if not self . multiline : return False line = self . _lines [ self . cursor . row ] left , right = line [: self . cursor . col ], line [ self . cursor . col :] self . _lines [ self . cursor . row ] = left self . _lines . insert ( self . cursor . row + 1 , right ) self . move_cursor (( 1 , - self . cursor . col )) self . _styled_cache = None else : self . insert_text ( key ) if keys . ANY_KEY in self . _bindings : method , _ = self . _bindings [ keys . ANY_KEY ] method ( self , key ) return True if key == keys . BACKSPACE : if self . _selection_length == 1 : self . delete_back ( 1 ) else : self . delete_back ( - self . _selection_length ) # self.handle_action(\"move_left\") # if self._selection_length == 1: self . _selection_length = 1 self . _styled_cache = None return True return False handle_mouse ( event ) Allows point-and-click selection. Source code in pytermgui/widgets/input_field.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Allows point-and-click selection.\"\"\" x_offset = event . position [ 0 ] - self . pos [ 0 ] y_offset = event . position [ 1 ] - self . pos [ 1 ] if y_offset == 0 : x_offset -= len ( self . prompt ) if x_offset < 0 : return False # Set cursor to mouse location if event . action is MouseAction . LEFT_CLICK : if not y_offset < len ( self . _lines ): return False line = self . _lines [ y_offset ] if y_offset == 0 : line = self . prompt + line self . move_cursor (( y_offset , min ( len ( line ), x_offset )), absolute = True ) self . _drag_start = ( x_offset , y_offset ) self . _selection_length = 1 return True # Select text using dragging the mouse if event . action is MouseAction . LEFT_DRAG and self . _drag_start is not None : change = x_offset - self . _drag_start [ 0 ] self . update_selection ( change - self . _selection_length + 1 , correct_zero_length = False ) return True return super () . handle_mouse ( event ) insert_text ( text ) Inserts text at the cursor location. Source code in pytermgui/widgets/input_field.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def insert_text ( self , text : str ) -> None : \"\"\"Inserts text at the cursor location.\"\"\" row , col = self . cursor if len ( self . _lines ) <= row : self . _lines . insert ( row , \"\" ) line = self . _lines [ row ] self . _lines [ row ] = line [: col ] + text + line [ col :] self . move_cursor (( 0 , len ( text ))) self . _styled_cache = None move_cursor ( new , * , absolute = False ) Moves the cursor, then possible re-positions it to a valid location. Parameters: Name Type Description Default new tuple [ int , int ] The new set of (y, x) positions to use. required absolute bool If set, new will be interpreted as absolute coordinates, instead of being added on top of the current ones. False Source code in pytermgui/widgets/input_field.py 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 def move_cursor ( self , new : tuple [ int , int ], * , absolute : bool = False ) -> None : \"\"\"Moves the cursor, then possible re-positions it to a valid location. Args: new: The new set of (y, x) positions to use. absolute: If set, `new` will be interpreted as absolute coordinates, instead of being added on top of the current ones. \"\"\" if len ( self . _lines ) == 0 : return if absolute : new_y , new_x = new self . cursor . row = new_y self . cursor . col = new_x else : self . cursor += new self . cursor . row = max ( 0 , min ( self . cursor . row , len ( self . _lines ) - 1 )) row , col = self . cursor line = self . _lines [ row ] # Going left, possibly upwards if col < 0 : if row <= 0 : self . cursor . col = 0 else : self . cursor . row -= 1 line = self . _lines [ self . cursor . row ] self . cursor . col = len ( line ) # Going right, possibly downwards elif col > len ( line ) and line != \"\" : if len ( self . _lines ) > row + 1 : self . cursor . row += 1 self . cursor . col = 0 line = self . _lines [ self . cursor . row ] self . cursor . col = max ( 0 , min ( self . cursor . col , len ( line ))) selectables_length () property Get length of selectables in object Source code in pytermgui/widgets/input_field.py 96 97 98 99 100 @property def selectables_length ( self ) -> int : \"\"\"Get length of selectables in object\"\"\" return 1 selection () property Returns the currently selected span of text. Source code in pytermgui/widgets/input_field.py 108 109 110 111 112 113 @property def selection ( self ) -> str : \"\"\"Returns the currently selected span of text.\"\"\" start , end = sorted ([ self . cursor . col , self . cursor . col + self . _selection_length ]) return self . _lines [ self . cursor . row ][ start : end ] update_selection ( count , correct_zero_length = True ) Updates the selection state. Parameters: Name Type Description Default count int How many characters the cursor should change by. Negative for selecting leftward, positive for right. required correct_zero_length bool If set, when the selection length is 0 both the cursor and the selection length are manipulated to keep the original selection start while moving the selection in more of the way the user might expect. True Source code in pytermgui/widgets/input_field.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def update_selection ( self , count : int , correct_zero_length : bool = True ) -> None : \"\"\"Updates the selection state. Args: count: How many characters the cursor should change by. Negative for selecting leftward, positive for right. correct_zero_length: If set, when the selection length is 0 both the cursor and the selection length are manipulated to keep the original selection start while moving the selection in more of the way the user might expect. \"\"\" self . _selection_length += count if correct_zero_length and abs ( self . _selection_length ) == 0 : self . _selection_length += 2 if count > 0 else - 2 self . move_cursor (( 0 , ( - 1 if count > 0 else 1 ))) value () property Returns the internal value of this field. Source code in pytermgui/widgets/input_field.py 102 103 104 105 106 @property def value ( self ) -> str : \"\"\"Returns the internal value of this field.\"\"\" return \" \\n \" . join ( self . _lines )","title":"input_field"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.Cursor","text":"Bases: Iterable A simple dataclass representing the InputField's cursor. Source code in pytermgui/widgets/input_field.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @dataclass class Cursor ( Iterable ): \"\"\"A simple dataclass representing the InputField's cursor.\"\"\" row : int col : int def __iadd__ ( self , difference : tuple [ int , int ]) -> Cursor : \"\"\"Move the cursor by the difference.\"\"\" row , col = difference self . row += row self . col += col return self def __iter__ ( self ) -> Iterator [ int ]: return iter (( self . row , self . col )) def __len__ ( self ) -> int : return 2","title":"Cursor"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.Cursor.__iadd__","text":"Move the cursor by the difference. Source code in pytermgui/widgets/input_field.py 25 26 27 28 29 30 31 32 33 def __iadd__ ( self , difference : tuple [ int , int ]) -> Cursor : \"\"\"Move the cursor by the difference.\"\"\" row , col = difference self . row += row self . col += col return self","title":"__iadd__()"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField","text":"Bases: Widget An element to display user input Source code in pytermgui/widgets/input_field.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 class InputField ( Widget ): # pylint: disable=too-many-instance-attributes \"\"\"An element to display user input\"\"\" styles = w_styles . StyleManager ( value = \"\" , prompt = \"surface+2\" , cursor = \"@primary dim #auto\" , ) keys = { \"move_left\" : { keys . LEFT }, \"move_right\" : { keys . RIGHT }, \"move_up\" : { keys . UP }, \"move_down\" : { keys . DOWN }, \"select_left\" : { keys . SHIFT_LEFT }, \"select_right\" : { keys . SHIFT_RIGHT }, \"select_up\" : { keys . SHIFT_UP }, \"select_down\" : { keys . SHIFT_DOWN }, } parent_align = HorizontalAlignment . LEFT def __init__ ( self , value : str = \"\" , * , prompt : str = \"\" , tablength : int = 4 , multiline : bool = False , cursor : Cursor | None = None , ** attrs : Any , ) -> None : \"\"\"Initialize object\"\"\" super () . __init__ ( ** attrs ) if \"width\" not in attrs : self . width = len ( value ) self . prompt = prompt self . height = 1 self . tablength = tablength self . multiline = multiline self . cursor = cursor or Cursor ( 0 , len ( value )) self . _lines = value . splitlines () or [ \"\" ] self . _selection_length = 1 self . _styled_cache : list [ str ] | None = self . _style_and_break_lines () self . _cached_state : int = self . width self . _drag_start : tuple [ int , int ] | None = None @property def selectables_length ( self ) -> int : \"\"\"Get length of selectables in object\"\"\" return 1 @property def value ( self ) -> str : \"\"\"Returns the internal value of this field.\"\"\" return \" \\n \" . join ( self . _lines ) @property def selection ( self ) -> str : \"\"\"Returns the currently selected span of text.\"\"\" start , end = sorted ([ self . cursor . col , self . cursor . col + self . _selection_length ]) return self . _lines [ self . cursor . row ][ start : end ] def _cache_is_valid ( self ) -> bool : \"\"\"Determines if the styled line cache is still usable.\"\"\" return self . width == self . _cached_state def _style_and_break_lines ( self ) -> list [ str ]: \"\"\"Styles and breaks self._lines.\"\"\" document = ( self . styles . prompt ( self . prompt ) + self . styles . value ( self . value ) ) . splitlines () lines : list [ str ] = [] width = self . width extend = lines . extend for line in document : extend ( break_line ( line . replace ( \" \\n \" , \" \\\\ n\" ), width , fill = \" \" )) extend ( \"\" ) return lines def update_selection ( self , count : int , correct_zero_length : bool = True ) -> None : \"\"\"Updates the selection state. Args: count: How many characters the cursor should change by. Negative for selecting leftward, positive for right. correct_zero_length: If set, when the selection length is 0 both the cursor and the selection length are manipulated to keep the original selection start while moving the selection in more of the way the user might expect. \"\"\" self . _selection_length += count if correct_zero_length and abs ( self . _selection_length ) == 0 : self . _selection_length += 2 if count > 0 else - 2 self . move_cursor (( 0 , ( - 1 if count > 0 else 1 ))) def delete_back ( self , count : int = 1 ) -> str : \"\"\"Deletes `count` characters from the cursor, backwards. Args: count: How many characters should be deleted. Returns: The deleted string. \"\"\" row , col = self . cursor if len ( self . _lines ) <= row : return \"\" line = self . _lines [ row ] start , end = sorted ([ col , col - count ]) start = max ( 0 , start ) self . _lines [ row ] = line [: start ] + line [ end :] self . _styled_cache = None if self . _lines [ row ] == \"\" : self . move_cursor (( - 1 , len ( self . _lines [ row - 1 ]))) return self . _lines . pop ( row ) if count > 0 : self . move_cursor (( 0 , - count )) return line [ col - count : col ] def insert_text ( self , text : str ) -> None : \"\"\"Inserts text at the cursor location.\"\"\" row , col = self . cursor if len ( self . _lines ) <= row : self . _lines . insert ( row , \"\" ) line = self . _lines [ row ] self . _lines [ row ] = line [: col ] + text + line [ col :] self . move_cursor (( 0 , len ( text ))) self . _styled_cache = None def handle_action ( self , action : str ) -> bool : \"\"\"Handles some action. This will be expanded in the future to allow using all behaviours with just their actions. \"\"\" cursors = { \"move_left\" : ( 0 , - 1 ), \"move_right\" : ( 0 , 1 ), \"move_up\" : ( - 1 , 0 ), \"move_down\" : ( 1 , 0 ), } if action . startswith ( \"move_\" ): row , col = cursors [ action ] if self . cursor . row + row > len ( self . _lines ): self . _lines . append ( \"\" ) col += self . _selection_length if self . _selection_length > 0 : col -= 1 self . _selection_length = 1 self . move_cursor (( row , col )) return True if action . startswith ( \"select_\" ): if action == \"select_right\" : self . update_selection ( 1 ) elif action == \"select_left\" : self . update_selection ( - 1 ) return True return False # TODO: This could probably be simplified by a wider adoption of the action pattern. def handle_key ( # pylint: disable=too-many-return-statements, too-many-branches self , key : str ) -> bool : \"\"\"Adds text to the field, or moves the cursor.\"\"\" if self . execute_binding ( key , ignore_any = True ): return True for name , options in self . keys . items (): if ( name . rsplit ( \"_\" , maxsplit = 1 )[ - 1 ] in ( \"up\" , \"down\" ) and not self . multiline ): continue if key in options : return self . handle_action ( name ) if key == keys . TAB : if not self . multiline : return False for _ in range ( self . tablength ): self . handle_key ( \" \" ) return True if key in string . printable and key not in \" \\x0c\\x0b \" : if key == keys . ENTER : if not self . multiline : return False line = self . _lines [ self . cursor . row ] left , right = line [: self . cursor . col ], line [ self . cursor . col :] self . _lines [ self . cursor . row ] = left self . _lines . insert ( self . cursor . row + 1 , right ) self . move_cursor (( 1 , - self . cursor . col )) self . _styled_cache = None else : self . insert_text ( key ) if keys . ANY_KEY in self . _bindings : method , _ = self . _bindings [ keys . ANY_KEY ] method ( self , key ) return True if key == keys . BACKSPACE : if self . _selection_length == 1 : self . delete_back ( 1 ) else : self . delete_back ( - self . _selection_length ) # self.handle_action(\"move_left\") # if self._selection_length == 1: self . _selection_length = 1 self . _styled_cache = None return True return False def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Allows point-and-click selection.\"\"\" x_offset = event . position [ 0 ] - self . pos [ 0 ] y_offset = event . position [ 1 ] - self . pos [ 1 ] if y_offset == 0 : x_offset -= len ( self . prompt ) if x_offset < 0 : return False # Set cursor to mouse location if event . action is MouseAction . LEFT_CLICK : if not y_offset < len ( self . _lines ): return False line = self . _lines [ y_offset ] if y_offset == 0 : line = self . prompt + line self . move_cursor (( y_offset , min ( len ( line ), x_offset )), absolute = True ) self . _drag_start = ( x_offset , y_offset ) self . _selection_length = 1 return True # Select text using dragging the mouse if event . action is MouseAction . LEFT_DRAG and self . _drag_start is not None : change = x_offset - self . _drag_start [ 0 ] self . update_selection ( change - self . _selection_length + 1 , correct_zero_length = False ) return True return super () . handle_mouse ( event ) def move_cursor ( self , new : tuple [ int , int ], * , absolute : bool = False ) -> None : \"\"\"Moves the cursor, then possible re-positions it to a valid location. Args: new: The new set of (y, x) positions to use. absolute: If set, `new` will be interpreted as absolute coordinates, instead of being added on top of the current ones. \"\"\" if len ( self . _lines ) == 0 : return if absolute : new_y , new_x = new self . cursor . row = new_y self . cursor . col = new_x else : self . cursor += new self . cursor . row = max ( 0 , min ( self . cursor . row , len ( self . _lines ) - 1 )) row , col = self . cursor line = self . _lines [ row ] # Going left, possibly upwards if col < 0 : if row <= 0 : self . cursor . col = 0 else : self . cursor . row -= 1 line = self . _lines [ self . cursor . row ] self . cursor . col = len ( line ) # Going right, possibly downwards elif col > len ( line ) and line != \"\" : if len ( self . _lines ) > row + 1 : self . cursor . row += 1 self . cursor . col = 0 line = self . _lines [ self . cursor . row ] self . cursor . col = max ( 0 , min ( self . cursor . col , len ( line ))) def get_lines ( self ) -> list [ str ]: \"\"\"Builds the input field's lines.\"\"\" if not self . _cache_is_valid () or self . _styled_cache is None : self . _styled_cache = self . _style_and_break_lines () lines = self . _styled_cache row , col = self . cursor if len ( self . _lines ) == 0 : line = \" \" else : line = self . _lines [ row ] start = col cursor_char = \" \" if len ( line ) > col : start = col end = col + self . _selection_length start , end = sorted ([ start , end ]) try : cursor_char = line [ start : end ] except IndexError as error : raise ValueError ( f \"Invalid index in { line !r} : { col } \" ) from error style_cursor = ( self . styles . value if self . selected_index is None else self . styles . cursor ) # TODO: This is horribly hackish, but is the only way to \"get around\" the # limits of the current scrolling techniques. Should be refactored # once a better solution is available if self . parent is not None and self . selected_index is not None : offset = 0 parent = self . parent while hasattr ( parent , \"parent\" ): offset += getattr ( parent , \"_scroll_offset\" ) parent = parent . parent # type: ignore offset_row = - offset + row offset_col = start + ( len ( self . prompt ) if row == 0 else 0 ) if offset_col > self . width - 1 : offset_col -= self . width offset_row += 1 row += 1 if row >= len ( lines ): lines . append ( self . styles . value ( \"\" )) position = ( self . pos [ 0 ] + offset_col , self . pos [ 1 ] + offset_row , ) self . positioned_line_buffer . append ( ( position , style_cursor ( cursor_char )) # type: ignore ) lines = lines or [ \"\" ] self . height = len ( lines ) return lines","title":"InputField"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.__init__","text":"Initialize object Source code in pytermgui/widgets/input_field.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def __init__ ( self , value : str = \"\" , * , prompt : str = \"\" , tablength : int = 4 , multiline : bool = False , cursor : Cursor | None = None , ** attrs : Any , ) -> None : \"\"\"Initialize object\"\"\" super () . __init__ ( ** attrs ) if \"width\" not in attrs : self . width = len ( value ) self . prompt = prompt self . height = 1 self . tablength = tablength self . multiline = multiline self . cursor = cursor or Cursor ( 0 , len ( value )) self . _lines = value . splitlines () or [ \"\" ] self . _selection_length = 1 self . _styled_cache : list [ str ] | None = self . _style_and_break_lines () self . _cached_state : int = self . width self . _drag_start : tuple [ int , int ] | None = None","title":"__init__()"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.delete_back","text":"Deletes count characters from the cursor, backwards. Parameters: Name Type Description Default count int How many characters should be deleted. 1 Returns: Type Description str The deleted string. Source code in pytermgui/widgets/input_field.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def delete_back ( self , count : int = 1 ) -> str : \"\"\"Deletes `count` characters from the cursor, backwards. Args: count: How many characters should be deleted. Returns: The deleted string. \"\"\" row , col = self . cursor if len ( self . _lines ) <= row : return \"\" line = self . _lines [ row ] start , end = sorted ([ col , col - count ]) start = max ( 0 , start ) self . _lines [ row ] = line [: start ] + line [ end :] self . _styled_cache = None if self . _lines [ row ] == \"\" : self . move_cursor (( - 1 , len ( self . _lines [ row - 1 ]))) return self . _lines . pop ( row ) if count > 0 : self . move_cursor (( 0 , - count )) return line [ col - count : col ]","title":"delete_back()"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.get_lines","text":"Builds the input field's lines. Source code in pytermgui/widgets/input_field.py 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 def get_lines ( self ) -> list [ str ]: \"\"\"Builds the input field's lines.\"\"\" if not self . _cache_is_valid () or self . _styled_cache is None : self . _styled_cache = self . _style_and_break_lines () lines = self . _styled_cache row , col = self . cursor if len ( self . _lines ) == 0 : line = \" \" else : line = self . _lines [ row ] start = col cursor_char = \" \" if len ( line ) > col : start = col end = col + self . _selection_length start , end = sorted ([ start , end ]) try : cursor_char = line [ start : end ] except IndexError as error : raise ValueError ( f \"Invalid index in { line !r} : { col } \" ) from error style_cursor = ( self . styles . value if self . selected_index is None else self . styles . cursor ) # TODO: This is horribly hackish, but is the only way to \"get around\" the # limits of the current scrolling techniques. Should be refactored # once a better solution is available if self . parent is not None and self . selected_index is not None : offset = 0 parent = self . parent while hasattr ( parent , \"parent\" ): offset += getattr ( parent , \"_scroll_offset\" ) parent = parent . parent # type: ignore offset_row = - offset + row offset_col = start + ( len ( self . prompt ) if row == 0 else 0 ) if offset_col > self . width - 1 : offset_col -= self . width offset_row += 1 row += 1 if row >= len ( lines ): lines . append ( self . styles . value ( \"\" )) position = ( self . pos [ 0 ] + offset_col , self . pos [ 1 ] + offset_row , ) self . positioned_line_buffer . append ( ( position , style_cursor ( cursor_char )) # type: ignore ) lines = lines or [ \"\" ] self . height = len ( lines ) return lines","title":"get_lines()"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.handle_action","text":"Handles some action. This will be expanded in the future to allow using all behaviours with just their actions. Source code in pytermgui/widgets/input_field.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def handle_action ( self , action : str ) -> bool : \"\"\"Handles some action. This will be expanded in the future to allow using all behaviours with just their actions. \"\"\" cursors = { \"move_left\" : ( 0 , - 1 ), \"move_right\" : ( 0 , 1 ), \"move_up\" : ( - 1 , 0 ), \"move_down\" : ( 1 , 0 ), } if action . startswith ( \"move_\" ): row , col = cursors [ action ] if self . cursor . row + row > len ( self . _lines ): self . _lines . append ( \"\" ) col += self . _selection_length if self . _selection_length > 0 : col -= 1 self . _selection_length = 1 self . move_cursor (( row , col )) return True if action . startswith ( \"select_\" ): if action == \"select_right\" : self . update_selection ( 1 ) elif action == \"select_left\" : self . update_selection ( - 1 ) return True return False","title":"handle_action()"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.handle_key","text":"Adds text to the field, or moves the cursor. Source code in pytermgui/widgets/input_field.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def handle_key ( # pylint: disable=too-many-return-statements, too-many-branches self , key : str ) -> bool : \"\"\"Adds text to the field, or moves the cursor.\"\"\" if self . execute_binding ( key , ignore_any = True ): return True for name , options in self . keys . items (): if ( name . rsplit ( \"_\" , maxsplit = 1 )[ - 1 ] in ( \"up\" , \"down\" ) and not self . multiline ): continue if key in options : return self . handle_action ( name ) if key == keys . TAB : if not self . multiline : return False for _ in range ( self . tablength ): self . handle_key ( \" \" ) return True if key in string . printable and key not in \" \\x0c\\x0b \" : if key == keys . ENTER : if not self . multiline : return False line = self . _lines [ self . cursor . row ] left , right = line [: self . cursor . col ], line [ self . cursor . col :] self . _lines [ self . cursor . row ] = left self . _lines . insert ( self . cursor . row + 1 , right ) self . move_cursor (( 1 , - self . cursor . col )) self . _styled_cache = None else : self . insert_text ( key ) if keys . ANY_KEY in self . _bindings : method , _ = self . _bindings [ keys . ANY_KEY ] method ( self , key ) return True if key == keys . BACKSPACE : if self . _selection_length == 1 : self . delete_back ( 1 ) else : self . delete_back ( - self . _selection_length ) # self.handle_action(\"move_left\") # if self._selection_length == 1: self . _selection_length = 1 self . _styled_cache = None return True return False","title":"handle_key()"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.handle_mouse","text":"Allows point-and-click selection. Source code in pytermgui/widgets/input_field.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Allows point-and-click selection.\"\"\" x_offset = event . position [ 0 ] - self . pos [ 0 ] y_offset = event . position [ 1 ] - self . pos [ 1 ] if y_offset == 0 : x_offset -= len ( self . prompt ) if x_offset < 0 : return False # Set cursor to mouse location if event . action is MouseAction . LEFT_CLICK : if not y_offset < len ( self . _lines ): return False line = self . _lines [ y_offset ] if y_offset == 0 : line = self . prompt + line self . move_cursor (( y_offset , min ( len ( line ), x_offset )), absolute = True ) self . _drag_start = ( x_offset , y_offset ) self . _selection_length = 1 return True # Select text using dragging the mouse if event . action is MouseAction . LEFT_DRAG and self . _drag_start is not None : change = x_offset - self . _drag_start [ 0 ] self . update_selection ( change - self . _selection_length + 1 , correct_zero_length = False ) return True return super () . handle_mouse ( event )","title":"handle_mouse()"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.insert_text","text":"Inserts text at the cursor location. Source code in pytermgui/widgets/input_field.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def insert_text ( self , text : str ) -> None : \"\"\"Inserts text at the cursor location.\"\"\" row , col = self . cursor if len ( self . _lines ) <= row : self . _lines . insert ( row , \"\" ) line = self . _lines [ row ] self . _lines [ row ] = line [: col ] + text + line [ col :] self . move_cursor (( 0 , len ( text ))) self . _styled_cache = None","title":"insert_text()"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.move_cursor","text":"Moves the cursor, then possible re-positions it to a valid location. Parameters: Name Type Description Default new tuple [ int , int ] The new set of (y, x) positions to use. required absolute bool If set, new will be interpreted as absolute coordinates, instead of being added on top of the current ones. False Source code in pytermgui/widgets/input_field.py 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 def move_cursor ( self , new : tuple [ int , int ], * , absolute : bool = False ) -> None : \"\"\"Moves the cursor, then possible re-positions it to a valid location. Args: new: The new set of (y, x) positions to use. absolute: If set, `new` will be interpreted as absolute coordinates, instead of being added on top of the current ones. \"\"\" if len ( self . _lines ) == 0 : return if absolute : new_y , new_x = new self . cursor . row = new_y self . cursor . col = new_x else : self . cursor += new self . cursor . row = max ( 0 , min ( self . cursor . row , len ( self . _lines ) - 1 )) row , col = self . cursor line = self . _lines [ row ] # Going left, possibly upwards if col < 0 : if row <= 0 : self . cursor . col = 0 else : self . cursor . row -= 1 line = self . _lines [ self . cursor . row ] self . cursor . col = len ( line ) # Going right, possibly downwards elif col > len ( line ) and line != \"\" : if len ( self . _lines ) > row + 1 : self . cursor . row += 1 self . cursor . col = 0 line = self . _lines [ self . cursor . row ] self . cursor . col = max ( 0 , min ( self . cursor . col , len ( line )))","title":"move_cursor()"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.selectables_length","text":"Get length of selectables in object Source code in pytermgui/widgets/input_field.py 96 97 98 99 100 @property def selectables_length ( self ) -> int : \"\"\"Get length of selectables in object\"\"\" return 1","title":"selectables_length()"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.selection","text":"Returns the currently selected span of text. Source code in pytermgui/widgets/input_field.py 108 109 110 111 112 113 @property def selection ( self ) -> str : \"\"\"Returns the currently selected span of text.\"\"\" start , end = sorted ([ self . cursor . col , self . cursor . col + self . _selection_length ]) return self . _lines [ self . cursor . row ][ start : end ]","title":"selection()"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.update_selection","text":"Updates the selection state. Parameters: Name Type Description Default count int How many characters the cursor should change by. Negative for selecting leftward, positive for right. required correct_zero_length bool If set, when the selection length is 0 both the cursor and the selection length are manipulated to keep the original selection start while moving the selection in more of the way the user might expect. True Source code in pytermgui/widgets/input_field.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def update_selection ( self , count : int , correct_zero_length : bool = True ) -> None : \"\"\"Updates the selection state. Args: count: How many characters the cursor should change by. Negative for selecting leftward, positive for right. correct_zero_length: If set, when the selection length is 0 both the cursor and the selection length are manipulated to keep the original selection start while moving the selection in more of the way the user might expect. \"\"\" self . _selection_length += count if correct_zero_length and abs ( self . _selection_length ) == 0 : self . _selection_length += 2 if count > 0 else - 2 self . move_cursor (( 0 , ( - 1 if count > 0 else 1 )))","title":"update_selection()"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.value","text":"Returns the internal value of this field. Source code in pytermgui/widgets/input_field.py 102 103 104 105 106 @property def value ( self ) -> str : \"\"\"Returns the internal value of this field.\"\"\" return \" \\n \" . join ( self . _lines )","title":"value()"},{"location":"reference/pytermgui/widgets/keyboard_button/","text":"This module provides a keyboard-accessible button. KeyboardButton Bases: Button A button with keyboard mnemonics in mind. Shoutout to the HackerNews thread where this was originally suggested https://news.ycombinator.com/item?id=30517299#30533444 Source code in pytermgui/widgets/keyboard_button.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class KeyboardButton ( Button ): \"\"\"A button with keyboard mnemonics in mind. Shoutout to the HackerNews thread where this was originally suggested: https://news.ycombinator.com/item?id=30517299#30533444 \"\"\" chars = { ** Button . chars , ** { \"bracket\" : [ \"(\" , \")\" ]}} is_bindable = True def __init__ ( self , label : str , onclick : Callable [[ Button ], Any ], index : int = 0 , bound : str | None = None , ) -> None : \"\"\"Initializes a KeyboardButton. For example, `KeyboardButton(\"Help\")` will look like: \"[ (H)elp ]\", and `KeyboardButton(\"Test\", index=1)` will give \"[ T(e)st ]\" Args: label: The label of the button. onclick: The callback to be executed when the button is activated. index: The index of the label to use as the binding character. bound: The keybind that activates this button. Defaults to `keys.CTRL_{char}` is used as the default binding. \"\"\" if bound is None : bound = getattr ( keys , \"CTRL_\" + label [ index ] . upper ()) brackets = \" {} \" . join ( self . _get_char ( \"bracket\" )) original = label label = label [: index ] + brackets . format ( label [ index ]) if index > - 1 : label += original [ index + 1 :] super () . __init__ ( label , onclick ) self . bind ( bound , lambda btn , _ : onclick ( btn )) __init__ ( label , onclick , index = 0 , bound = None ) Initializes a KeyboardButton. For example, KeyboardButton(\"Help\") will look like: \"[ (H)elp ]\", and KeyboardButton(\"Test\", index=1) will give \"[ T(e)st ]\" Parameters: Name Type Description Default label str The label of the button. required onclick Callable [[ Button ], Any ] The callback to be executed when the button is activated. required index int The index of the label to use as the binding character. 0 bound str | None The keybind that activates this button. Defaults to keys.CTRL_{char} is used as the default binding. None Source code in pytermgui/widgets/keyboard_button.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def __init__ ( self , label : str , onclick : Callable [[ Button ], Any ], index : int = 0 , bound : str | None = None , ) -> None : \"\"\"Initializes a KeyboardButton. For example, `KeyboardButton(\"Help\")` will look like: \"[ (H)elp ]\", and `KeyboardButton(\"Test\", index=1)` will give \"[ T(e)st ]\" Args: label: The label of the button. onclick: The callback to be executed when the button is activated. index: The index of the label to use as the binding character. bound: The keybind that activates this button. Defaults to `keys.CTRL_{char}` is used as the default binding. \"\"\" if bound is None : bound = getattr ( keys , \"CTRL_\" + label [ index ] . upper ()) brackets = \" {} \" . join ( self . _get_char ( \"bracket\" )) original = label label = label [: index ] + brackets . format ( label [ index ]) if index > - 1 : label += original [ index + 1 :] super () . __init__ ( label , onclick ) self . bind ( bound , lambda btn , _ : onclick ( btn ))","title":"keyboard_button"},{"location":"reference/pytermgui/widgets/keyboard_button/#pytermgui.widgets.keyboard_button.KeyboardButton","text":"Bases: Button A button with keyboard mnemonics in mind. Shoutout to the HackerNews thread where this was originally suggested https://news.ycombinator.com/item?id=30517299#30533444 Source code in pytermgui/widgets/keyboard_button.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class KeyboardButton ( Button ): \"\"\"A button with keyboard mnemonics in mind. Shoutout to the HackerNews thread where this was originally suggested: https://news.ycombinator.com/item?id=30517299#30533444 \"\"\" chars = { ** Button . chars , ** { \"bracket\" : [ \"(\" , \")\" ]}} is_bindable = True def __init__ ( self , label : str , onclick : Callable [[ Button ], Any ], index : int = 0 , bound : str | None = None , ) -> None : \"\"\"Initializes a KeyboardButton. For example, `KeyboardButton(\"Help\")` will look like: \"[ (H)elp ]\", and `KeyboardButton(\"Test\", index=1)` will give \"[ T(e)st ]\" Args: label: The label of the button. onclick: The callback to be executed when the button is activated. index: The index of the label to use as the binding character. bound: The keybind that activates this button. Defaults to `keys.CTRL_{char}` is used as the default binding. \"\"\" if bound is None : bound = getattr ( keys , \"CTRL_\" + label [ index ] . upper ()) brackets = \" {} \" . join ( self . _get_char ( \"bracket\" )) original = label label = label [: index ] + brackets . format ( label [ index ]) if index > - 1 : label += original [ index + 1 :] super () . __init__ ( label , onclick ) self . bind ( bound , lambda btn , _ : onclick ( btn ))","title":"KeyboardButton"},{"location":"reference/pytermgui/widgets/keyboard_button/#pytermgui.widgets.keyboard_button.KeyboardButton.__init__","text":"Initializes a KeyboardButton. For example, KeyboardButton(\"Help\") will look like: \"[ (H)elp ]\", and KeyboardButton(\"Test\", index=1) will give \"[ T(e)st ]\" Parameters: Name Type Description Default label str The label of the button. required onclick Callable [[ Button ], Any ] The callback to be executed when the button is activated. required index int The index of the label to use as the binding character. 0 bound str | None The keybind that activates this button. Defaults to keys.CTRL_{char} is used as the default binding. None Source code in pytermgui/widgets/keyboard_button.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def __init__ ( self , label : str , onclick : Callable [[ Button ], Any ], index : int = 0 , bound : str | None = None , ) -> None : \"\"\"Initializes a KeyboardButton. For example, `KeyboardButton(\"Help\")` will look like: \"[ (H)elp ]\", and `KeyboardButton(\"Test\", index=1)` will give \"[ T(e)st ]\" Args: label: The label of the button. onclick: The callback to be executed when the button is activated. index: The index of the label to use as the binding character. bound: The keybind that activates this button. Defaults to `keys.CTRL_{char}` is used as the default binding. \"\"\" if bound is None : bound = getattr ( keys , \"CTRL_\" + label [ index ] . upper ()) brackets = \" {} \" . join ( self . _get_char ( \"bracket\" )) original = label label = label [: index ] + brackets . format ( label [ index ]) if index > - 1 : label += original [ index + 1 :] super () . __init__ ( label , onclick ) self . bind ( bound , lambda btn , _ : onclick ( btn ))","title":"__init__()"},{"location":"reference/pytermgui/widgets/pixel_matrix/","text":"The module containing all the widgets that can be used to display pixel-based data. DensePixelMatrix Bases: PixelMatrix A more dense (2x) PixelMatrix. Due to each pixel only occupying 1/2 characters in height, accurately determining selected_pixel is impossible, thus the functionality does not exist here. Source code in pytermgui/widgets/pixel_matrix.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 class DensePixelMatrix ( PixelMatrix ): \"\"\"A more dense (2x) PixelMatrix. Due to each pixel only occupying 1/2 characters in height, accurately determining selected_pixel is impossible, thus the functionality does not exist here. \"\"\" def __init__ ( self , width : int , height : int , default : str = \"\" , ** attrs ) -> None : \"\"\"Initializes DensePixelMatrix. Args: width: The width of the matrix. height: The height of the matrix. default: The default color to use to initialize the matrix with. \"\"\" super () . __init__ ( width , height , default , ** attrs ) self . width = width // 2 def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"As mentioned in the class documentation, mouse handling is disabled here.\"\"\" return False def build ( self ) -> list [ str ]: \"\"\"Builds the image pixels, using half-block characters. Returns: The lines that this object will return, until a subsequent `build` call. These lines are stored in the `self._lines` variable. \"\"\" lines = [] lines_to_zip : list [ list [ str ]] = [] for row in self . _matrix : lines_to_zip . append ( row ) if len ( lines_to_zip ) != 2 : continue line = \"\" top_row , bottom_row = lines_to_zip [ 0 ], lines_to_zip [ 1 ] for bottom , top in zip ( bottom_row , top_row ): if len ( top ) + len ( bottom ) == 0 : line += \" \" continue if bottom == \"\" : line += tim . parse ( f \"[ { top } ]\u2580\" ) continue markup_str = \"@\" + top + \" \" if len ( top ) > 0 else \"\" markup_str += bottom line += tim . parse ( f \"[ { markup_str } ]\u2584\" ) lines . append ( line ) lines_to_zip = [] self . _lines = lines self . _update_dimensions ( lines ) return lines __init__ ( width , height , default = '' , attrs ) Initializes DensePixelMatrix. Parameters: Name Type Description Default width int The width of the matrix. required height int The height of the matrix. required default str The default color to use to initialize the matrix with. '' Source code in pytermgui/widgets/pixel_matrix.py 162 163 164 165 166 167 168 169 170 171 172 173 def __init__ ( self , width : int , height : int , default : str = \"\" , ** attrs ) -> None : \"\"\"Initializes DensePixelMatrix. Args: width: The width of the matrix. height: The height of the matrix. default: The default color to use to initialize the matrix with. \"\"\" super () . __init__ ( width , height , default , ** attrs ) self . width = width // 2 build () Builds the image pixels, using half-block characters. Returns: Type Description list [ str ] The lines that this object will return, until a subsequent build call. list [ str ] These lines are stored in the self._lines variable. Source code in pytermgui/widgets/pixel_matrix.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 def build ( self ) -> list [ str ]: \"\"\"Builds the image pixels, using half-block characters. Returns: The lines that this object will return, until a subsequent `build` call. These lines are stored in the `self._lines` variable. \"\"\" lines = [] lines_to_zip : list [ list [ str ]] = [] for row in self . _matrix : lines_to_zip . append ( row ) if len ( lines_to_zip ) != 2 : continue line = \"\" top_row , bottom_row = lines_to_zip [ 0 ], lines_to_zip [ 1 ] for bottom , top in zip ( bottom_row , top_row ): if len ( top ) + len ( bottom ) == 0 : line += \" \" continue if bottom == \"\" : line += tim . parse ( f \"[ { top } ]\u2580\" ) continue markup_str = \"@\" + top + \" \" if len ( top ) > 0 else \"\" markup_str += bottom line += tim . parse ( f \"[ { markup_str } ]\u2584\" ) lines . append ( line ) lines_to_zip = [] self . _lines = lines self . _update_dimensions ( lines ) return lines handle_mouse ( event ) As mentioned in the class documentation, mouse handling is disabled here. Source code in pytermgui/widgets/pixel_matrix.py 175 176 177 178 def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"As mentioned in the class documentation, mouse handling is disabled here.\"\"\" return False PixelMatrix Bases: Widget A matrix of pixels. The way this object should be used is by accessing & modifying the underlying matrix. This can be done using the set & getitem syntacies: from pytermgui import PixelMatrix matrix = PixelMatrix ( 10 , 10 , default = \"white\" ) for y in matrix . rows : for x in matrix . columns : matrix [ y , x ] = \"black\" The above snippet draws a black diagonal going from the top left to bottom right. Each item of the rows should be a single PyTermGUI-parsable color string. For more information about this, see pytermgui.ansi_interface.Color . Source code in pytermgui/widgets/pixel_matrix.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 class PixelMatrix ( Widget ): \"\"\"A matrix of pixels. The way this object should be used is by accessing & modifying the underlying matrix. This can be done using the set & getitem syntacies: ```python3 from pytermgui import PixelMatrix matrix = PixelMatrix(10, 10, default=\"white\") for y in matrix.rows: for x in matrix.columns: matrix[y, x] = \"black\" ``` The above snippet draws a black diagonal going from the top left to bottom right. Each item of the rows should be a single PyTermGUI-parsable color string. For more information about this, see `pytermgui.ansi_interface.Color`. \"\"\" selected_pixel : tuple [ tuple [ int , int ], str ] | None \"\"\"A tuple of the position & value (color) of the currently hovered pixel.\"\"\" def __init__ ( self , width : int , height : int , default : str = \"background\" , ** attrs ) -> None : \"\"\"Initializes a PixelMatrix. Args: width: The amount of columns the matrix will have. height: The amount of rows the matrix will have. default: The default color to use to initialize the matrix with. \"\"\" super () . __init__ ( ** attrs ) self . rows = height self . columns = width self . _matrix = [] for _ in range ( self . rows ): self . _matrix . append ([ default ] * self . columns ) self . selected_pixel = None self . build () @classmethod def from_matrix ( cls , matrix : list [ list [ str ]]) -> PixelMatrix : \"\"\"Creates a PixelMatrix from the given matrix. The given matrix should be a list of rows, each containing a number of cells. It is optimal for all rows to share the same amount of cells. Args: matrix: The matrix to use. This is a list of lists of strings with each element representing a PyTermGUI-parseable color. Returns: A new type(self). \"\"\" obj = cls ( max ( len ( row ) for row in matrix ), len ( matrix )) setattr ( obj , \"_matrix\" , matrix ) obj . build () return obj def _update_dimensions ( self , lines : list [ str ]): \"\"\"Updates the dimensions of this matrix. Args: lines: A list of lines that the calculations will be based upon. \"\"\" self . static_width = max ( real_length ( line ) for line in lines ) self . height = len ( lines ) def on_hover ( self , event : MouseEvent ) -> bool : \"\"\"Sets `selected_pixel` to the current pixel.\"\"\" xoffset = event . position [ 0 ] - self . pos [ 0 ] yoffset = event . position [ 1 ] - self . pos [ 1 ] color = self . _matrix [ yoffset ][ xoffset // 2 ] self . selected_pixel = (( xoffset // 2 , yoffset ), color ) return True def get_lines ( self ) -> list [ str ]: \"\"\"Returns lines built by the `build` method.\"\"\" return self . _lines def build ( self ) -> list [ str ]: \"\"\"Builds the image pixels. Returns: The lines that this object will return, until a subsequent `build` call. These lines are stored in the `self._lines` variable. \"\"\" lines : list [ str ] = [] for row in self . _matrix : line = \"\" for pixel in row : if len ( pixel ) > 0 and pixel != \"background\" : line += f \"[@ { pixel } ] \" else : line += \"[/ background] \" lines . append ( tim . parse ( line )) self . _lines = lines self . _update_dimensions ( lines ) return lines def __getitem__ ( self , indices : tuple [ int , int ]) -> str : \"\"\"Gets a matrix item.\"\"\" posy , posx = indices return self . _matrix [ posy ][ posx ] def __setitem__ ( self , indices : tuple [ int , int ], value : str ) -> None : \"\"\"Sets a matrix item.\"\"\" posy , posx = indices self . _matrix [ posy ][ posx ] = value __getitem__ ( indices ) Gets a matrix item. Source code in pytermgui/widgets/pixel_matrix.py 141 142 143 144 145 def __getitem__ ( self , indices : tuple [ int , int ]) -> str : \"\"\"Gets a matrix item.\"\"\" posy , posx = indices return self . _matrix [ posy ][ posx ] __init__ ( width , height , default = 'background' , attrs ) Initializes a PixelMatrix. Parameters: Name Type Description Default width int The amount of columns the matrix will have. required height int The amount of rows the matrix will have. required default str The default color to use to initialize the matrix with. 'background' Source code in pytermgui/widgets/pixel_matrix.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , width : int , height : int , default : str = \"background\" , ** attrs ) -> None : \"\"\"Initializes a PixelMatrix. Args: width: The amount of columns the matrix will have. height: The amount of rows the matrix will have. default: The default color to use to initialize the matrix with. \"\"\" super () . __init__ ( ** attrs ) self . rows = height self . columns = width self . _matrix = [] for _ in range ( self . rows ): self . _matrix . append ([ default ] * self . columns ) self . selected_pixel = None self . build () __setitem__ ( indices , value ) Sets a matrix item. Source code in pytermgui/widgets/pixel_matrix.py 147 148 149 150 151 def __setitem__ ( self , indices : tuple [ int , int ], value : str ) -> None : \"\"\"Sets a matrix item.\"\"\" posy , posx = indices self . _matrix [ posy ][ posx ] = value build () Builds the image pixels. Returns: Type Description list [ str ] The lines that this object will return, until a subsequent build call. list [ str ] These lines are stored in the self._lines variable. Source code in pytermgui/widgets/pixel_matrix.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def build ( self ) -> list [ str ]: \"\"\"Builds the image pixels. Returns: The lines that this object will return, until a subsequent `build` call. These lines are stored in the `self._lines` variable. \"\"\" lines : list [ str ] = [] for row in self . _matrix : line = \"\" for pixel in row : if len ( pixel ) > 0 and pixel != \"background\" : line += f \"[@ { pixel } ] \" else : line += \"[/ background] \" lines . append ( tim . parse ( line )) self . _lines = lines self . _update_dimensions ( lines ) return lines from_matrix ( matrix ) classmethod Creates a PixelMatrix from the given matrix. The given matrix should be a list of rows, each containing a number of cells. It is optimal for all rows to share the same amount of cells. Parameters: Name Type Description Default matrix list [ list [ str ]] The matrix to use. This is a list of lists of strings with each element representing a PyTermGUI-parseable color. required Returns: Type Description PixelMatrix A new type(self). Source code in pytermgui/widgets/pixel_matrix.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 @classmethod def from_matrix ( cls , matrix : list [ list [ str ]]) -> PixelMatrix : \"\"\"Creates a PixelMatrix from the given matrix. The given matrix should be a list of rows, each containing a number of cells. It is optimal for all rows to share the same amount of cells. Args: matrix: The matrix to use. This is a list of lists of strings with each element representing a PyTermGUI-parseable color. Returns: A new type(self). \"\"\" obj = cls ( max ( len ( row ) for row in matrix ), len ( matrix )) setattr ( obj , \"_matrix\" , matrix ) obj . build () return obj get_lines () Returns lines built by the build method. Source code in pytermgui/widgets/pixel_matrix.py 112 113 114 115 def get_lines ( self ) -> list [ str ]: \"\"\"Returns lines built by the `build` method.\"\"\" return self . _lines on_hover ( event ) Sets selected_pixel to the current pixel. Source code in pytermgui/widgets/pixel_matrix.py 101 102 103 104 105 106 107 108 109 110 def on_hover ( self , event : MouseEvent ) -> bool : \"\"\"Sets `selected_pixel` to the current pixel.\"\"\" xoffset = event . position [ 0 ] - self . pos [ 0 ] yoffset = event . position [ 1 ] - self . pos [ 1 ] color = self . _matrix [ yoffset ][ xoffset // 2 ] self . selected_pixel = (( xoffset // 2 , yoffset ), color ) return True","title":"pixel_matrix"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.DensePixelMatrix","text":"Bases: PixelMatrix A more dense (2x) PixelMatrix. Due to each pixel only occupying 1/2 characters in height, accurately determining selected_pixel is impossible, thus the functionality does not exist here. Source code in pytermgui/widgets/pixel_matrix.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 class DensePixelMatrix ( PixelMatrix ): \"\"\"A more dense (2x) PixelMatrix. Due to each pixel only occupying 1/2 characters in height, accurately determining selected_pixel is impossible, thus the functionality does not exist here. \"\"\" def __init__ ( self , width : int , height : int , default : str = \"\" , ** attrs ) -> None : \"\"\"Initializes DensePixelMatrix. Args: width: The width of the matrix. height: The height of the matrix. default: The default color to use to initialize the matrix with. \"\"\" super () . __init__ ( width , height , default , ** attrs ) self . width = width // 2 def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"As mentioned in the class documentation, mouse handling is disabled here.\"\"\" return False def build ( self ) -> list [ str ]: \"\"\"Builds the image pixels, using half-block characters. Returns: The lines that this object will return, until a subsequent `build` call. These lines are stored in the `self._lines` variable. \"\"\" lines = [] lines_to_zip : list [ list [ str ]] = [] for row in self . _matrix : lines_to_zip . append ( row ) if len ( lines_to_zip ) != 2 : continue line = \"\" top_row , bottom_row = lines_to_zip [ 0 ], lines_to_zip [ 1 ] for bottom , top in zip ( bottom_row , top_row ): if len ( top ) + len ( bottom ) == 0 : line += \" \" continue if bottom == \"\" : line += tim . parse ( f \"[ { top } ]\u2580\" ) continue markup_str = \"@\" + top + \" \" if len ( top ) > 0 else \"\" markup_str += bottom line += tim . parse ( f \"[ { markup_str } ]\u2584\" ) lines . append ( line ) lines_to_zip = [] self . _lines = lines self . _update_dimensions ( lines ) return lines","title":"DensePixelMatrix"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.DensePixelMatrix.__init__","text":"Initializes DensePixelMatrix. Parameters: Name Type Description Default width int The width of the matrix. required height int The height of the matrix. required default str The default color to use to initialize the matrix with. '' Source code in pytermgui/widgets/pixel_matrix.py 162 163 164 165 166 167 168 169 170 171 172 173 def __init__ ( self , width : int , height : int , default : str = \"\" , ** attrs ) -> None : \"\"\"Initializes DensePixelMatrix. Args: width: The width of the matrix. height: The height of the matrix. default: The default color to use to initialize the matrix with. \"\"\" super () . __init__ ( width , height , default , ** attrs ) self . width = width // 2","title":"__init__()"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.DensePixelMatrix.build","text":"Builds the image pixels, using half-block characters. Returns: Type Description list [ str ] The lines that this object will return, until a subsequent build call. list [ str ] These lines are stored in the self._lines variable. Source code in pytermgui/widgets/pixel_matrix.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 def build ( self ) -> list [ str ]: \"\"\"Builds the image pixels, using half-block characters. Returns: The lines that this object will return, until a subsequent `build` call. These lines are stored in the `self._lines` variable. \"\"\" lines = [] lines_to_zip : list [ list [ str ]] = [] for row in self . _matrix : lines_to_zip . append ( row ) if len ( lines_to_zip ) != 2 : continue line = \"\" top_row , bottom_row = lines_to_zip [ 0 ], lines_to_zip [ 1 ] for bottom , top in zip ( bottom_row , top_row ): if len ( top ) + len ( bottom ) == 0 : line += \" \" continue if bottom == \"\" : line += tim . parse ( f \"[ { top } ]\u2580\" ) continue markup_str = \"@\" + top + \" \" if len ( top ) > 0 else \"\" markup_str += bottom line += tim . parse ( f \"[ { markup_str } ]\u2584\" ) lines . append ( line ) lines_to_zip = [] self . _lines = lines self . _update_dimensions ( lines ) return lines","title":"build()"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.DensePixelMatrix.handle_mouse","text":"As mentioned in the class documentation, mouse handling is disabled here. Source code in pytermgui/widgets/pixel_matrix.py 175 176 177 178 def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"As mentioned in the class documentation, mouse handling is disabled here.\"\"\" return False","title":"handle_mouse()"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.PixelMatrix","text":"Bases: Widget A matrix of pixels. The way this object should be used is by accessing & modifying the underlying matrix. This can be done using the set & getitem syntacies: from pytermgui import PixelMatrix matrix = PixelMatrix ( 10 , 10 , default = \"white\" ) for y in matrix . rows : for x in matrix . columns : matrix [ y , x ] = \"black\" The above snippet draws a black diagonal going from the top left to bottom right. Each item of the rows should be a single PyTermGUI-parsable color string. For more information about this, see pytermgui.ansi_interface.Color . Source code in pytermgui/widgets/pixel_matrix.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 class PixelMatrix ( Widget ): \"\"\"A matrix of pixels. The way this object should be used is by accessing & modifying the underlying matrix. This can be done using the set & getitem syntacies: ```python3 from pytermgui import PixelMatrix matrix = PixelMatrix(10, 10, default=\"white\") for y in matrix.rows: for x in matrix.columns: matrix[y, x] = \"black\" ``` The above snippet draws a black diagonal going from the top left to bottom right. Each item of the rows should be a single PyTermGUI-parsable color string. For more information about this, see `pytermgui.ansi_interface.Color`. \"\"\" selected_pixel : tuple [ tuple [ int , int ], str ] | None \"\"\"A tuple of the position & value (color) of the currently hovered pixel.\"\"\" def __init__ ( self , width : int , height : int , default : str = \"background\" , ** attrs ) -> None : \"\"\"Initializes a PixelMatrix. Args: width: The amount of columns the matrix will have. height: The amount of rows the matrix will have. default: The default color to use to initialize the matrix with. \"\"\" super () . __init__ ( ** attrs ) self . rows = height self . columns = width self . _matrix = [] for _ in range ( self . rows ): self . _matrix . append ([ default ] * self . columns ) self . selected_pixel = None self . build () @classmethod def from_matrix ( cls , matrix : list [ list [ str ]]) -> PixelMatrix : \"\"\"Creates a PixelMatrix from the given matrix. The given matrix should be a list of rows, each containing a number of cells. It is optimal for all rows to share the same amount of cells. Args: matrix: The matrix to use. This is a list of lists of strings with each element representing a PyTermGUI-parseable color. Returns: A new type(self). \"\"\" obj = cls ( max ( len ( row ) for row in matrix ), len ( matrix )) setattr ( obj , \"_matrix\" , matrix ) obj . build () return obj def _update_dimensions ( self , lines : list [ str ]): \"\"\"Updates the dimensions of this matrix. Args: lines: A list of lines that the calculations will be based upon. \"\"\" self . static_width = max ( real_length ( line ) for line in lines ) self . height = len ( lines ) def on_hover ( self , event : MouseEvent ) -> bool : \"\"\"Sets `selected_pixel` to the current pixel.\"\"\" xoffset = event . position [ 0 ] - self . pos [ 0 ] yoffset = event . position [ 1 ] - self . pos [ 1 ] color = self . _matrix [ yoffset ][ xoffset // 2 ] self . selected_pixel = (( xoffset // 2 , yoffset ), color ) return True def get_lines ( self ) -> list [ str ]: \"\"\"Returns lines built by the `build` method.\"\"\" return self . _lines def build ( self ) -> list [ str ]: \"\"\"Builds the image pixels. Returns: The lines that this object will return, until a subsequent `build` call. These lines are stored in the `self._lines` variable. \"\"\" lines : list [ str ] = [] for row in self . _matrix : line = \"\" for pixel in row : if len ( pixel ) > 0 and pixel != \"background\" : line += f \"[@ { pixel } ] \" else : line += \"[/ background] \" lines . append ( tim . parse ( line )) self . _lines = lines self . _update_dimensions ( lines ) return lines def __getitem__ ( self , indices : tuple [ int , int ]) -> str : \"\"\"Gets a matrix item.\"\"\" posy , posx = indices return self . _matrix [ posy ][ posx ] def __setitem__ ( self , indices : tuple [ int , int ], value : str ) -> None : \"\"\"Sets a matrix item.\"\"\" posy , posx = indices self . _matrix [ posy ][ posx ] = value","title":"PixelMatrix"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.PixelMatrix.__getitem__","text":"Gets a matrix item. Source code in pytermgui/widgets/pixel_matrix.py 141 142 143 144 145 def __getitem__ ( self , indices : tuple [ int , int ]) -> str : \"\"\"Gets a matrix item.\"\"\" posy , posx = indices return self . _matrix [ posy ][ posx ]","title":"__getitem__()"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.PixelMatrix.__init__","text":"Initializes a PixelMatrix. Parameters: Name Type Description Default width int The amount of columns the matrix will have. required height int The amount of rows the matrix will have. required default str The default color to use to initialize the matrix with. 'background' Source code in pytermgui/widgets/pixel_matrix.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , width : int , height : int , default : str = \"background\" , ** attrs ) -> None : \"\"\"Initializes a PixelMatrix. Args: width: The amount of columns the matrix will have. height: The amount of rows the matrix will have. default: The default color to use to initialize the matrix with. \"\"\" super () . __init__ ( ** attrs ) self . rows = height self . columns = width self . _matrix = [] for _ in range ( self . rows ): self . _matrix . append ([ default ] * self . columns ) self . selected_pixel = None self . build ()","title":"__init__()"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.PixelMatrix.__setitem__","text":"Sets a matrix item. Source code in pytermgui/widgets/pixel_matrix.py 147 148 149 150 151 def __setitem__ ( self , indices : tuple [ int , int ], value : str ) -> None : \"\"\"Sets a matrix item.\"\"\" posy , posx = indices self . _matrix [ posy ][ posx ] = value","title":"__setitem__()"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.PixelMatrix.build","text":"Builds the image pixels. Returns: Type Description list [ str ] The lines that this object will return, until a subsequent build call. list [ str ] These lines are stored in the self._lines variable. Source code in pytermgui/widgets/pixel_matrix.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def build ( self ) -> list [ str ]: \"\"\"Builds the image pixels. Returns: The lines that this object will return, until a subsequent `build` call. These lines are stored in the `self._lines` variable. \"\"\" lines : list [ str ] = [] for row in self . _matrix : line = \"\" for pixel in row : if len ( pixel ) > 0 and pixel != \"background\" : line += f \"[@ { pixel } ] \" else : line += \"[/ background] \" lines . append ( tim . parse ( line )) self . _lines = lines self . _update_dimensions ( lines ) return lines","title":"build()"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.PixelMatrix.from_matrix","text":"Creates a PixelMatrix from the given matrix. The given matrix should be a list of rows, each containing a number of cells. It is optimal for all rows to share the same amount of cells. Parameters: Name Type Description Default matrix list [ list [ str ]] The matrix to use. This is a list of lists of strings with each element representing a PyTermGUI-parseable color. required Returns: Type Description PixelMatrix A new type(self). Source code in pytermgui/widgets/pixel_matrix.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 @classmethod def from_matrix ( cls , matrix : list [ list [ str ]]) -> PixelMatrix : \"\"\"Creates a PixelMatrix from the given matrix. The given matrix should be a list of rows, each containing a number of cells. It is optimal for all rows to share the same amount of cells. Args: matrix: The matrix to use. This is a list of lists of strings with each element representing a PyTermGUI-parseable color. Returns: A new type(self). \"\"\" obj = cls ( max ( len ( row ) for row in matrix ), len ( matrix )) setattr ( obj , \"_matrix\" , matrix ) obj . build () return obj","title":"from_matrix()"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.PixelMatrix.get_lines","text":"Returns lines built by the build method. Source code in pytermgui/widgets/pixel_matrix.py 112 113 114 115 def get_lines ( self ) -> list [ str ]: \"\"\"Returns lines built by the `build` method.\"\"\" return self . _lines","title":"get_lines()"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.PixelMatrix.on_hover","text":"Sets selected_pixel to the current pixel. Source code in pytermgui/widgets/pixel_matrix.py 101 102 103 104 105 106 107 108 109 110 def on_hover ( self , event : MouseEvent ) -> bool : \"\"\"Sets `selected_pixel` to the current pixel.\"\"\" xoffset = event . position [ 0 ] - self . pos [ 0 ] yoffset = event . position [ 1 ] - self . pos [ 1 ] color = self . _matrix [ yoffset ][ xoffset // 2 ] self . selected_pixel = (( xoffset // 2 , yoffset ), color ) return True","title":"on_hover()"},{"location":"reference/pytermgui/widgets/slider/","text":"This module contains the Slider class. Slider Bases: Widget A Widget to display & configure scalable data. By default, this Widget will act like a slider you might find in a settings page, allowing percentage-based selection of magnitude. Using WindowManager it can even be dragged around by the user using the mouse. Source code in pytermgui/widgets/slider.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 class Slider ( Widget ): # pylint: disable=too-many-instance-attributes \"\"\"A Widget to display & configure scalable data. By default, this Widget will act like a slider you might find in a settings page, allowing percentage-based selection of magnitude. Using `WindowManager` it can even be dragged around by the user using the mouse. \"\"\" locked : bool \"\"\"Disallow mouse input, hide cursor and lock current state\"\"\" chars = { \"cursor\" : \"\" , \"rail\" : \"\u2501\" , \"delimiter\" : [ \"[\" , \"]\" ]} styles = w_styles . StyleManager ( delimiter = \"surface\" , filled = \"surface+1\" , cursor = \"primary\" , filled_selected = \"primary\" , unfilled = \"surface-1\" , unfilled_selected = \"surface\" , ) keys = { \"increase\" : { keys . RIGHT , keys . CTRL_F , \"l\" , \"+\" }, \"decrease\" : { keys . LEFT , keys . CTRL_B , \"h\" , \"-\" }, } def __init__ ( self , onchange : Callable [[ float ], Any ] | None = None , locked : bool = False , ** attrs : Any , ) -> None : \"\"\"Initializes a Slider. Args: onchange: The callable called every time the value is updated. locked: Whether this Slider should accept value changes. \"\"\" self . _value = 0.0 super () . __init__ ( ** attrs ) self . _selectables_length = 1 self . is_locked = locked self . onchange = onchange @property def value ( self ) -> float : \"\"\"Returns the value of this Slider. Returns: A floating point number between 0.0 and 1.0. \"\"\" return self . _value @value . setter def value ( self , new : float ) -> None : \"\"\"Updates the value.\"\"\" if self . is_locked : return self . _value = max ( 0.0 , min ( new , 1.0 )) if self . onchange is not None : self . onchange ( self . _value ) def handle_key ( self , key : str ) -> bool : \"\"\"Moves the slider cursor.\"\"\" if self . execute_binding ( key ): return True if key in self . keys [ \"increase\" ]: self . value += 0.1 return True if key in self . keys [ \"decrease\" ]: self . value -= 0.1 return True return False def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Moves the slider cursor.\"\"\" delimiter = self . _get_char ( \"delimiter\" )[ 0 ] if event . action in [ MouseAction . LEFT_CLICK , MouseAction . LEFT_DRAG ]: offset = event . position [ 0 ] - self . pos [ 0 ] + 1 - real_length ( delimiter ) self . value = max ( 0 , min ( offset / self . width , 1.0 )) return True return False def get_lines ( self ) -> list [ str ]: \"\"\"Gets slider lines.\"\"\" rail = self . _get_char ( \"rail\" ) cursor = self . _get_char ( \"cursor\" ) or rail delimiters = self . _get_char ( \"delimiter\" ) assert isinstance ( delimiters , list ) assert isinstance ( cursor , str ) assert isinstance ( rail , str ) cursor = self . _get_style ( \"cursor\" )( cursor ) unfilled = self . styles . unfilled ( rail ) if self . selected_index is None : filled = self . styles . filled ( rail ) else : filled = self . styles . filled_selected ( rail ) for i , char in enumerate ( delimiters ): delimiters [ i ] = self . styles . filled_selected ( char ) for i , delimiter in enumerate ( delimiters ): delimiters [ i ] = self . styles . delimiter ( delimiter ) width = self . width - real_length ( \"\" . join ( delimiters )) count = width * self . value - 1 chars = [ delimiters [ 0 ]] for i in range ( width ): if i == count and not self . is_locked and self . selected_index is not None : chars . append ( cursor ) continue if i <= count : chars . append ( filled ) continue chars . append ( unfilled ) chars . append ( delimiters [ 1 ]) line = \"\" . join ( chars ) self . width = real_length ( line ) return [ line ] locked : bool class-attribute Disallow mouse input, hide cursor and lock current state __init__ ( onchange = None , locked = False , attrs ) Initializes a Slider. Parameters: Name Type Description Default onchange Callable [[ float ], Any ] | None The callable called every time the value is updated. None locked bool Whether this Slider should accept value changes. False Source code in pytermgui/widgets/slider.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def __init__ ( self , onchange : Callable [[ float ], Any ] | None = None , locked : bool = False , ** attrs : Any , ) -> None : \"\"\"Initializes a Slider. Args: onchange: The callable called every time the value is updated. locked: Whether this Slider should accept value changes. \"\"\" self . _value = 0.0 super () . __init__ ( ** attrs ) self . _selectables_length = 1 self . is_locked = locked self . onchange = onchange get_lines () Gets slider lines. Source code in pytermgui/widgets/slider.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def get_lines ( self ) -> list [ str ]: \"\"\"Gets slider lines.\"\"\" rail = self . _get_char ( \"rail\" ) cursor = self . _get_char ( \"cursor\" ) or rail delimiters = self . _get_char ( \"delimiter\" ) assert isinstance ( delimiters , list ) assert isinstance ( cursor , str ) assert isinstance ( rail , str ) cursor = self . _get_style ( \"cursor\" )( cursor ) unfilled = self . styles . unfilled ( rail ) if self . selected_index is None : filled = self . styles . filled ( rail ) else : filled = self . styles . filled_selected ( rail ) for i , char in enumerate ( delimiters ): delimiters [ i ] = self . styles . filled_selected ( char ) for i , delimiter in enumerate ( delimiters ): delimiters [ i ] = self . styles . delimiter ( delimiter ) width = self . width - real_length ( \"\" . join ( delimiters )) count = width * self . value - 1 chars = [ delimiters [ 0 ]] for i in range ( width ): if i == count and not self . is_locked and self . selected_index is not None : chars . append ( cursor ) continue if i <= count : chars . append ( filled ) continue chars . append ( unfilled ) chars . append ( delimiters [ 1 ]) line = \"\" . join ( chars ) self . width = real_length ( line ) return [ line ] handle_key ( key ) Moves the slider cursor. Source code in pytermgui/widgets/slider.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def handle_key ( self , key : str ) -> bool : \"\"\"Moves the slider cursor.\"\"\" if self . execute_binding ( key ): return True if key in self . keys [ \"increase\" ]: self . value += 0.1 return True if key in self . keys [ \"decrease\" ]: self . value -= 0.1 return True return False handle_mouse ( event ) Moves the slider cursor. Source code in pytermgui/widgets/slider.py 106 107 108 109 110 111 112 113 114 115 116 def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Moves the slider cursor.\"\"\" delimiter = self . _get_char ( \"delimiter\" )[ 0 ] if event . action in [ MouseAction . LEFT_CLICK , MouseAction . LEFT_DRAG ]: offset = event . position [ 0 ] - self . pos [ 0 ] + 1 - real_length ( delimiter ) self . value = max ( 0 , min ( offset / self . width , 1.0 )) return True return False value () property writable Returns the value of this Slider. Returns: Type Description float A floating point number between 0.0 and 1.0. Source code in pytermgui/widgets/slider.py 68 69 70 71 72 73 74 75 76 @property def value ( self ) -> float : \"\"\"Returns the value of this Slider. Returns: A floating point number between 0.0 and 1.0. \"\"\" return self . _value","title":"slider"},{"location":"reference/pytermgui/widgets/slider/#pytermgui.widgets.slider.Slider","text":"Bases: Widget A Widget to display & configure scalable data. By default, this Widget will act like a slider you might find in a settings page, allowing percentage-based selection of magnitude. Using WindowManager it can even be dragged around by the user using the mouse. Source code in pytermgui/widgets/slider.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 class Slider ( Widget ): # pylint: disable=too-many-instance-attributes \"\"\"A Widget to display & configure scalable data. By default, this Widget will act like a slider you might find in a settings page, allowing percentage-based selection of magnitude. Using `WindowManager` it can even be dragged around by the user using the mouse. \"\"\" locked : bool \"\"\"Disallow mouse input, hide cursor and lock current state\"\"\" chars = { \"cursor\" : \"\" , \"rail\" : \"\u2501\" , \"delimiter\" : [ \"[\" , \"]\" ]} styles = w_styles . StyleManager ( delimiter = \"surface\" , filled = \"surface+1\" , cursor = \"primary\" , filled_selected = \"primary\" , unfilled = \"surface-1\" , unfilled_selected = \"surface\" , ) keys = { \"increase\" : { keys . RIGHT , keys . CTRL_F , \"l\" , \"+\" }, \"decrease\" : { keys . LEFT , keys . CTRL_B , \"h\" , \"-\" }, } def __init__ ( self , onchange : Callable [[ float ], Any ] | None = None , locked : bool = False , ** attrs : Any , ) -> None : \"\"\"Initializes a Slider. Args: onchange: The callable called every time the value is updated. locked: Whether this Slider should accept value changes. \"\"\" self . _value = 0.0 super () . __init__ ( ** attrs ) self . _selectables_length = 1 self . is_locked = locked self . onchange = onchange @property def value ( self ) -> float : \"\"\"Returns the value of this Slider. Returns: A floating point number between 0.0 and 1.0. \"\"\" return self . _value @value . setter def value ( self , new : float ) -> None : \"\"\"Updates the value.\"\"\" if self . is_locked : return self . _value = max ( 0.0 , min ( new , 1.0 )) if self . onchange is not None : self . onchange ( self . _value ) def handle_key ( self , key : str ) -> bool : \"\"\"Moves the slider cursor.\"\"\" if self . execute_binding ( key ): return True if key in self . keys [ \"increase\" ]: self . value += 0.1 return True if key in self . keys [ \"decrease\" ]: self . value -= 0.1 return True return False def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Moves the slider cursor.\"\"\" delimiter = self . _get_char ( \"delimiter\" )[ 0 ] if event . action in [ MouseAction . LEFT_CLICK , MouseAction . LEFT_DRAG ]: offset = event . position [ 0 ] - self . pos [ 0 ] + 1 - real_length ( delimiter ) self . value = max ( 0 , min ( offset / self . width , 1.0 )) return True return False def get_lines ( self ) -> list [ str ]: \"\"\"Gets slider lines.\"\"\" rail = self . _get_char ( \"rail\" ) cursor = self . _get_char ( \"cursor\" ) or rail delimiters = self . _get_char ( \"delimiter\" ) assert isinstance ( delimiters , list ) assert isinstance ( cursor , str ) assert isinstance ( rail , str ) cursor = self . _get_style ( \"cursor\" )( cursor ) unfilled = self . styles . unfilled ( rail ) if self . selected_index is None : filled = self . styles . filled ( rail ) else : filled = self . styles . filled_selected ( rail ) for i , char in enumerate ( delimiters ): delimiters [ i ] = self . styles . filled_selected ( char ) for i , delimiter in enumerate ( delimiters ): delimiters [ i ] = self . styles . delimiter ( delimiter ) width = self . width - real_length ( \"\" . join ( delimiters )) count = width * self . value - 1 chars = [ delimiters [ 0 ]] for i in range ( width ): if i == count and not self . is_locked and self . selected_index is not None : chars . append ( cursor ) continue if i <= count : chars . append ( filled ) continue chars . append ( unfilled ) chars . append ( delimiters [ 1 ]) line = \"\" . join ( chars ) self . width = real_length ( line ) return [ line ]","title":"Slider"},{"location":"reference/pytermgui/widgets/slider/#pytermgui.widgets.slider.Slider.locked","text":"Disallow mouse input, hide cursor and lock current state","title":"locked"},{"location":"reference/pytermgui/widgets/slider/#pytermgui.widgets.slider.Slider.__init__","text":"Initializes a Slider. Parameters: Name Type Description Default onchange Callable [[ float ], Any ] | None The callable called every time the value is updated. None locked bool Whether this Slider should accept value changes. False Source code in pytermgui/widgets/slider.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def __init__ ( self , onchange : Callable [[ float ], Any ] | None = None , locked : bool = False , ** attrs : Any , ) -> None : \"\"\"Initializes a Slider. Args: onchange: The callable called every time the value is updated. locked: Whether this Slider should accept value changes. \"\"\" self . _value = 0.0 super () . __init__ ( ** attrs ) self . _selectables_length = 1 self . is_locked = locked self . onchange = onchange","title":"__init__()"},{"location":"reference/pytermgui/widgets/slider/#pytermgui.widgets.slider.Slider.get_lines","text":"Gets slider lines. Source code in pytermgui/widgets/slider.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def get_lines ( self ) -> list [ str ]: \"\"\"Gets slider lines.\"\"\" rail = self . _get_char ( \"rail\" ) cursor = self . _get_char ( \"cursor\" ) or rail delimiters = self . _get_char ( \"delimiter\" ) assert isinstance ( delimiters , list ) assert isinstance ( cursor , str ) assert isinstance ( rail , str ) cursor = self . _get_style ( \"cursor\" )( cursor ) unfilled = self . styles . unfilled ( rail ) if self . selected_index is None : filled = self . styles . filled ( rail ) else : filled = self . styles . filled_selected ( rail ) for i , char in enumerate ( delimiters ): delimiters [ i ] = self . styles . filled_selected ( char ) for i , delimiter in enumerate ( delimiters ): delimiters [ i ] = self . styles . delimiter ( delimiter ) width = self . width - real_length ( \"\" . join ( delimiters )) count = width * self . value - 1 chars = [ delimiters [ 0 ]] for i in range ( width ): if i == count and not self . is_locked and self . selected_index is not None : chars . append ( cursor ) continue if i <= count : chars . append ( filled ) continue chars . append ( unfilled ) chars . append ( delimiters [ 1 ]) line = \"\" . join ( chars ) self . width = real_length ( line ) return [ line ]","title":"get_lines()"},{"location":"reference/pytermgui/widgets/slider/#pytermgui.widgets.slider.Slider.handle_key","text":"Moves the slider cursor. Source code in pytermgui/widgets/slider.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def handle_key ( self , key : str ) -> bool : \"\"\"Moves the slider cursor.\"\"\" if self . execute_binding ( key ): return True if key in self . keys [ \"increase\" ]: self . value += 0.1 return True if key in self . keys [ \"decrease\" ]: self . value -= 0.1 return True return False","title":"handle_key()"},{"location":"reference/pytermgui/widgets/slider/#pytermgui.widgets.slider.Slider.handle_mouse","text":"Moves the slider cursor. Source code in pytermgui/widgets/slider.py 106 107 108 109 110 111 112 113 114 115 116 def handle_mouse ( self , event : MouseEvent ) -> bool : \"\"\"Moves the slider cursor.\"\"\" delimiter = self . _get_char ( \"delimiter\" )[ 0 ] if event . action in [ MouseAction . LEFT_CLICK , MouseAction . LEFT_DRAG ]: offset = event . position [ 0 ] - self . pos [ 0 ] + 1 - real_length ( delimiter ) self . value = max ( 0 , min ( offset / self . width , 1.0 )) return True return False","title":"handle_mouse()"},{"location":"reference/pytermgui/widgets/slider/#pytermgui.widgets.slider.Slider.value","text":"Returns the value of this Slider. Returns: Type Description float A floating point number between 0.0 and 1.0. Source code in pytermgui/widgets/slider.py 68 69 70 71 72 73 74 75 76 @property def value ( self ) -> float : \"\"\"Returns the value of this Slider. Returns: A floating point number between 0.0 and 1.0. \"\"\" return self . _value","title":"value()"},{"location":"reference/pytermgui/widgets/styles/","text":"Conveniences for styling widgets All styles have a depth and item argument. depth is an int that represents that \"deep\" the Widget is within the hierarchy, and item is the string that the style is applied to. HighlighterStyle dataclass A style that highlights the items given to it. See pytermgui.highlighters for more information. Source code in pytermgui/widgets/styles.py 121 122 123 124 125 126 127 128 129 130 131 132 133 @dataclass class HighlighterStyle : \"\"\"A style that highlights the items given to it. See `pytermgui.highlighters` for more information. \"\"\" highlighter : Highlighter def __call__ ( self , _ : int , item : str ) -> str : \"\"\"Highlights the given string.\"\"\" return tim . parse ( self . highlighter ( item )) __call__ ( _ , item ) Highlights the given string. Source code in pytermgui/widgets/styles.py 130 131 132 133 def __call__ ( self , _ : int , item : str ) -> str : \"\"\"Highlights the given string.\"\"\" return tim . parse ( self . highlighter ( item )) MarkupFormatter dataclass A style that formats depth & item into the given markup on call. Useful in Widget styles, such as: import pytermgui as ptg root = ptg . Container () # Set border style to be reactive to the widget's depth root . set_style ( \"border\" , ptg . MarkupFactory ( \"[35 @ {depth} ] {item} ]\" ) Source code in pytermgui/widgets/styles.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 @dataclass class MarkupFormatter : \"\"\"A style that formats depth & item into the given markup on call. Useful in Widget styles, such as: ```python3 import pytermgui as ptg root = ptg.Container() # Set border style to be reactive to the widget's depth root.set_style(\"border\", ptg.MarkupFactory(\"[35 @{depth}]{item}]\") ``` \"\"\" markup : str ensure_strip : bool = False _markup_cache : dict [ str , str ] = field ( init = False , default_factory = dict ) def __call__ ( self , depth : int , item : str ) -> str : \"\"\"StyleType: Format depth & item into given markup template\"\"\" if self . ensure_strip : item = strip_ansi ( item ) if item in self . _markup_cache : item = self . _markup_cache [ item ] else : original = item item = get_markup ( item ) self . _markup_cache [ original ] = item return tim . parse ( self . markup . format ( depth = depth , item = item )) def __str__ ( self ) -> str : \"\"\"Returns __repr__, but with markup escaped.\"\"\" return self . __repr__ () . replace ( \"[\" , r \"\\[\" ) __call__ ( depth , item ) StyleType: Format depth & item into given markup template Source code in pytermgui/widgets/styles.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def __call__ ( self , depth : int , item : str ) -> str : \"\"\"StyleType: Format depth & item into given markup template\"\"\" if self . ensure_strip : item = strip_ansi ( item ) if item in self . _markup_cache : item = self . _markup_cache [ item ] else : original = item item = get_markup ( item ) self . _markup_cache [ original ] = item return tim . parse ( self . markup . format ( depth = depth , item = item )) __str__ () Returns repr , but with markup escaped. Source code in pytermgui/widgets/styles.py 115 116 117 118 def __str__ ( self ) -> str : \"\"\"Returns __repr__, but with markup escaped.\"\"\" return self . __repr__ () . replace ( \"[\" , r \"\\[\" ) StyleCall dataclass A callable object that simplifies calling style methods. Instances of this class are created within the Widget._get_style method, and this class should not be used outside of that context. Source code in pytermgui/widgets/styles.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 @dataclass class StyleCall : \"\"\"A callable object that simplifies calling style methods. Instances of this class are created within the `Widget._get_style` method, and this class should not be used outside of that context.\"\"\" obj : Widget | Type [ Widget ] | None method : StyleType def __call__ ( self , item : str ) -> str : \"\"\"DepthlessStyleType: Apply style method to item, using depth\"\"\" if self . obj is None : raise ValueError ( f \"Can not call { self . method !r} , as no object is assigned to this StyleCall.\" ) try : # mypy fails on one machine with this, but not on the other. return self . method ( self . obj . depth , item ) # type: ignore # this is purposefully broad, as anything can happen during these calls. except Exception as error : raise RuntimeError ( f \"Could not apply style { self . method } to { item !r} : { error } \" # type: ignore ) from error def __eq__ ( self , other : object ) -> bool : if not isinstance ( other , type ( self )): return False return other . method == self . method __call__ ( item ) DepthlessStyleType: Apply style method to item, using depth Source code in pytermgui/widgets/styles.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def __call__ ( self , item : str ) -> str : \"\"\"DepthlessStyleType: Apply style method to item, using depth\"\"\" if self . obj is None : raise ValueError ( f \"Can not call { self . method !r} , as no object is assigned to this StyleCall.\" ) try : # mypy fails on one machine with this, but not on the other. return self . method ( self . obj . depth , item ) # type: ignore # this is purposefully broad, as anything can happen during these calls. except Exception as error : raise RuntimeError ( f \"Could not apply style { self . method } to { item !r} : { error } \" # type: ignore ) from error StyleManager Bases: UserDict An fancy dictionary to manage a Widget's styles. Individual styles can be accessed two ways: manager . styles . style_name == manager . _get_style ( \"style_name\" ) Same with setting: widget . styles . style_name = ... widget . set_style ( \"style_name\" , ... ) The set and get methods remain for backwards compatibility reasons, but all newly written code should use the dot syntax. It is also possible to set styles as markup shorthands. For example: widget . styles . border = \"60 bold\" ...is equivalent to: widget . styles . border = \"[60 bold] {item} \" Source code in pytermgui/widgets/styles.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 class StyleManager ( UserDict ): # pylint: disable=too-many-ancestors \"\"\"An fancy dictionary to manage a Widget's styles. Individual styles can be accessed two ways: ```python3 manager.styles.style_name == manager._get_style(\"style_name\") ``` Same with setting: ```python3 widget.styles.style_name = ... widget.set_style(\"style_name\", ...) ``` The `set` and `get` methods remain for backwards compatibility reasons, but all newly written code should use the dot syntax. It is also possible to set styles as markup shorthands. For example: ```python3 widget.styles.border = \"60 bold\" ``` ...is equivalent to: ```python3 widget.styles.border = \"[60 bold]{item}\" ``` \"\"\" def __init__ ( self , parent : Widget | Type [ Widget ] | None = None , ** base , ) -> None : \"\"\"Initializes a `StyleManager`. Args: parent: The parent of this instance. It will be assigned in all `StyleCall`-s created by it. \"\"\" self . __dict__ [ \"_is_setup\" ] = False self . parent = parent super () . __init__ () for key , value in base . items (): self . _set_as_stylecall ( key , value ) self . __dict__ [ \"_is_setup\" ] = self . parent is not None @staticmethod def expand_shorthand ( shorthand : str ) -> MarkupFormatter : \"\"\"Expands a shorthand string into a `MarkupFormatter` instance. For example, all of these will expand into `MarkupFormatter([60]{item}')`: - '60' - '[60]' - '[60]{item}' Args: shorthand: The short version of markup to expand. Returns: A `MarkupFormatter` with the expanded markup. \"\"\" if len ( shorthand ) == 0 : return MarkupFormatter ( \" {item} \" ) if RE_MARKUP . match ( shorthand ) is not None : return MarkupFormatter ( shorthand ) tokens = _sub_aliases ( tokenize_markup ( f \"[ { shorthand } ]\" ), tim . context ) colors = [ tkn for tkn in tokens if Token . is_color ( tkn )] if any ( tkn . color . background for tkn in colors ) and not any ( not tkn . color . background for tkn in colors ): shorthand += \" #auto\" markup = f \"[ { shorthand } ]\" if not \" {item} \" in shorthand : markup += \" {item} \" return MarkupFormatter ( markup ) @classmethod def merge ( cls , other : StyleManager , ** styles : str ) -> StyleManager : \"\"\"Creates a new manager that merges `other` with the passed in styles. Args: other: The style manager to base the new one from. **styles: The additional styles the new instance should have. Returns: A new `StyleManager`. This instance will only gather its data when `branch` is called on it. This is done so any changes made to the original data between the `merge` call and the actual usage of the instance will be reflected. \"\"\" return cls ( ** { ** other , ** styles }) def branch ( self , parent : Widget | Type [ Widget ]) -> StyleManager : \"\"\"Branch off from the `base` style dictionary. This method should be called during widget construction. It creates a new `StyleManager` based on self, but with its data detached from the original. Args: parent: The parent of the new instance. Returns: A new `StyleManager`, with detached instances of data. This can then be modified without touching the original instance. \"\"\" return type ( self )( parent , ** self . data ) def _set_as_stylecall ( self , key : str , item : StyleValue ) -> None : \"\"\"Sets `self.data[key]` as a `StyleCall` of the given item. If the item is a string, it will be expanded into a `MarkupFormatter` before being converted into the `StyleCall`, using `expand_shorthand`. \"\"\" if isinstance ( item , StyleCall ): self . data [ key ] = StyleCall ( self . parent , item . method ) return if isinstance ( item , str ): item = self . expand_shorthand ( item ) self . data [ key ] = StyleCall ( self . parent , item ) def __setitem__ ( self , key : str , value : StyleValue ) -> None : \"\"\"Sets an item in `self.data`. If the item is a string, it will be expanded into a `MarkupFormatter` before being converted into the `StyleCall`, using `expand_shorthand`. \"\"\" self . _set_as_stylecall ( key , value ) def __setattr__ ( self , key : str , value : StyleValue ) -> None : \"\"\"Sets an attribute. It first looks if it can set inside self.data, and defaults back to self.__dict__. Raises: KeyError: The given key is not a defined attribute, and is not part of this object's style set. \"\"\" found = False if \"data\" in self . __dict__ : for part in key . split ( \"__\" ): if part in self . data : self . _set_as_stylecall ( part , value ) found = True if found : return if self . __dict__ . get ( \"_is_setup\" ) and key not in self . __dict__ : raise KeyError ( f \"Style { key !r} was not defined during construction.\" ) self . __dict__ [ key ] = value def __getattr__ ( self , key : str ) -> StyleCall : \"\"\"Allows styles.dot_syntax.\"\"\" if key in self . __dict__ : return self . __dict__ [ key ] if key in self . __dict__ [ \"data\" ]: return self . __dict__ [ \"data\" ][ key ] raise AttributeError ( key , self . data ) def __call__ ( self , ** styles : StyleValue ) -> Any : \"\"\"Allows calling the manager and setting its styles. For example: ``` >>> Button(\"Hello\").styles(label=\"@60\") ``` \"\"\" for key , value in styles . items (): self . _set_as_stylecall ( key , value ) return self . parent __call__ ( styles ) Allows calling the manager and setting its styles. For example: >>> Button(\"Hello\").styles(label=\"@60\") Source code in pytermgui/widgets/styles.py 326 327 328 329 330 331 332 333 334 335 336 337 338 def __call__ ( self , ** styles : StyleValue ) -> Any : \"\"\"Allows calling the manager and setting its styles. For example: ``` >>> Button(\"Hello\").styles(label=\"@60\") ``` \"\"\" for key , value in styles . items (): self . _set_as_stylecall ( key , value ) return self . parent __getattr__ ( key ) Allows styles.dot_syntax. Source code in pytermgui/widgets/styles.py 315 316 317 318 319 320 321 322 323 324 def __getattr__ ( self , key : str ) -> StyleCall : \"\"\"Allows styles.dot_syntax.\"\"\" if key in self . __dict__ : return self . __dict__ [ key ] if key in self . __dict__ [ \"data\" ]: return self . __dict__ [ \"data\" ][ key ] raise AttributeError ( key , self . data ) __init__ ( parent = None , base ) Initializes a StyleManager . Parameters: Name Type Description Default parent Widget | Type [ Widget ] | None The parent of this instance. It will be assigned in all StyleCall -s created by it. None Source code in pytermgui/widgets/styles.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def __init__ ( self , parent : Widget | Type [ Widget ] | None = None , ** base , ) -> None : \"\"\"Initializes a `StyleManager`. Args: parent: The parent of this instance. It will be assigned in all `StyleCall`-s created by it. \"\"\" self . __dict__ [ \"_is_setup\" ] = False self . parent = parent super () . __init__ () for key , value in base . items (): self . _set_as_stylecall ( key , value ) self . __dict__ [ \"_is_setup\" ] = self . parent is not None __setattr__ ( key , value ) Sets an attribute. It first looks if it can set inside self.data, and defaults back to self. dict . Raises: Type Description KeyError The given key is not a defined attribute, and is not part of this object's style set. Source code in pytermgui/widgets/styles.py 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 def __setattr__ ( self , key : str , value : StyleValue ) -> None : \"\"\"Sets an attribute. It first looks if it can set inside self.data, and defaults back to self.__dict__. Raises: KeyError: The given key is not a defined attribute, and is not part of this object's style set. \"\"\" found = False if \"data\" in self . __dict__ : for part in key . split ( \"__\" ): if part in self . data : self . _set_as_stylecall ( part , value ) found = True if found : return if self . __dict__ . get ( \"_is_setup\" ) and key not in self . __dict__ : raise KeyError ( f \"Style { key !r} was not defined during construction.\" ) self . __dict__ [ key ] = value __setitem__ ( key , value ) Sets an item in self.data . If the item is a string, it will be expanded into a MarkupFormatter before being converted into the StyleCall , using expand_shorthand . Source code in pytermgui/widgets/styles.py 280 281 282 283 284 285 286 287 def __setitem__ ( self , key : str , value : StyleValue ) -> None : \"\"\"Sets an item in `self.data`. If the item is a string, it will be expanded into a `MarkupFormatter` before being converted into the `StyleCall`, using `expand_shorthand`. \"\"\" self . _set_as_stylecall ( key , value ) branch ( parent ) Branch off from the base style dictionary. This method should be called during widget construction. It creates a new StyleManager based on self, but with its data detached from the original. Parameters: Name Type Description Default parent Widget | Type [ Widget ] The parent of the new instance. required Returns: Type Description StyleManager A new StyleManager , with detached instances of data. This can then be StyleManager modified without touching the original instance. Source code in pytermgui/widgets/styles.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 def branch ( self , parent : Widget | Type [ Widget ]) -> StyleManager : \"\"\"Branch off from the `base` style dictionary. This method should be called during widget construction. It creates a new `StyleManager` based on self, but with its data detached from the original. Args: parent: The parent of the new instance. Returns: A new `StyleManager`, with detached instances of data. This can then be modified without touching the original instance. \"\"\" return type ( self )( parent , ** self . data ) expand_shorthand ( shorthand ) staticmethod Expands a shorthand string into a MarkupFormatter instance. For example, all of these will expand into MarkupFormatter([60]{item}') : - '60' - '[60]' - '[60]{item}' Parameters: Name Type Description Default shorthand str The short version of markup to expand. required Returns: Type Description MarkupFormatter A MarkupFormatter with the expanded markup. Source code in pytermgui/widgets/styles.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 @staticmethod def expand_shorthand ( shorthand : str ) -> MarkupFormatter : \"\"\"Expands a shorthand string into a `MarkupFormatter` instance. For example, all of these will expand into `MarkupFormatter([60]{item}')`: - '60' - '[60]' - '[60]{item}' Args: shorthand: The short version of markup to expand. Returns: A `MarkupFormatter` with the expanded markup. \"\"\" if len ( shorthand ) == 0 : return MarkupFormatter ( \" {item} \" ) if RE_MARKUP . match ( shorthand ) is not None : return MarkupFormatter ( shorthand ) tokens = _sub_aliases ( tokenize_markup ( f \"[ { shorthand } ]\" ), tim . context ) colors = [ tkn for tkn in tokens if Token . is_color ( tkn )] if any ( tkn . color . background for tkn in colors ) and not any ( not tkn . color . background for tkn in colors ): shorthand += \" #auto\" markup = f \"[ { shorthand } ]\" if not \" {item} \" in shorthand : markup += \" {item} \" return MarkupFormatter ( markup ) merge ( other , styles ) classmethod Creates a new manager that merges other with the passed in styles. Parameters: Name Type Description Default other StyleManager The style manager to base the new one from. required **styles str The additional styles the new instance should have. {} Returns: Type Description StyleManager A new StyleManager . This instance will only gather its data when StyleManager branch is called on it. This is done so any changes made to the original StyleManager data between the merge call and the actual usage of the instance will be StyleManager reflected. Source code in pytermgui/widgets/styles.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 @classmethod def merge ( cls , other : StyleManager , ** styles : str ) -> StyleManager : \"\"\"Creates a new manager that merges `other` with the passed in styles. Args: other: The style manager to base the new one from. **styles: The additional styles the new instance should have. Returns: A new `StyleManager`. This instance will only gather its data when `branch` is called on it. This is done so any changes made to the original data between the `merge` call and the actual usage of the instance will be reflected. \"\"\" return cls ( ** { ** other , ** styles })","title":"styles"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.HighlighterStyle","text":"A style that highlights the items given to it. See pytermgui.highlighters for more information. Source code in pytermgui/widgets/styles.py 121 122 123 124 125 126 127 128 129 130 131 132 133 @dataclass class HighlighterStyle : \"\"\"A style that highlights the items given to it. See `pytermgui.highlighters` for more information. \"\"\" highlighter : Highlighter def __call__ ( self , _ : int , item : str ) -> str : \"\"\"Highlights the given string.\"\"\" return tim . parse ( self . highlighter ( item ))","title":"HighlighterStyle"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.HighlighterStyle.__call__","text":"Highlights the given string. Source code in pytermgui/widgets/styles.py 130 131 132 133 def __call__ ( self , _ : int , item : str ) -> str : \"\"\"Highlights the given string.\"\"\" return tim . parse ( self . highlighter ( item ))","title":"__call__()"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.MarkupFormatter","text":"A style that formats depth & item into the given markup on call. Useful in Widget styles, such as: import pytermgui as ptg root = ptg . Container () # Set border style to be reactive to the widget's depth root . set_style ( \"border\" , ptg . MarkupFactory ( \"[35 @ {depth} ] {item} ]\" ) Source code in pytermgui/widgets/styles.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 @dataclass class MarkupFormatter : \"\"\"A style that formats depth & item into the given markup on call. Useful in Widget styles, such as: ```python3 import pytermgui as ptg root = ptg.Container() # Set border style to be reactive to the widget's depth root.set_style(\"border\", ptg.MarkupFactory(\"[35 @{depth}]{item}]\") ``` \"\"\" markup : str ensure_strip : bool = False _markup_cache : dict [ str , str ] = field ( init = False , default_factory = dict ) def __call__ ( self , depth : int , item : str ) -> str : \"\"\"StyleType: Format depth & item into given markup template\"\"\" if self . ensure_strip : item = strip_ansi ( item ) if item in self . _markup_cache : item = self . _markup_cache [ item ] else : original = item item = get_markup ( item ) self . _markup_cache [ original ] = item return tim . parse ( self . markup . format ( depth = depth , item = item )) def __str__ ( self ) -> str : \"\"\"Returns __repr__, but with markup escaped.\"\"\" return self . __repr__ () . replace ( \"[\" , r \"\\[\" )","title":"MarkupFormatter"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.MarkupFormatter.__call__","text":"StyleType: Format depth & item into given markup template Source code in pytermgui/widgets/styles.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def __call__ ( self , depth : int , item : str ) -> str : \"\"\"StyleType: Format depth & item into given markup template\"\"\" if self . ensure_strip : item = strip_ansi ( item ) if item in self . _markup_cache : item = self . _markup_cache [ item ] else : original = item item = get_markup ( item ) self . _markup_cache [ original ] = item return tim . parse ( self . markup . format ( depth = depth , item = item ))","title":"__call__()"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.MarkupFormatter.__str__","text":"Returns repr , but with markup escaped. Source code in pytermgui/widgets/styles.py 115 116 117 118 def __str__ ( self ) -> str : \"\"\"Returns __repr__, but with markup escaped.\"\"\" return self . __repr__ () . replace ( \"[\" , r \"\\[\" )","title":"__str__()"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.StyleCall","text":"A callable object that simplifies calling style methods. Instances of this class are created within the Widget._get_style method, and this class should not be used outside of that context. Source code in pytermgui/widgets/styles.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 @dataclass class StyleCall : \"\"\"A callable object that simplifies calling style methods. Instances of this class are created within the `Widget._get_style` method, and this class should not be used outside of that context.\"\"\" obj : Widget | Type [ Widget ] | None method : StyleType def __call__ ( self , item : str ) -> str : \"\"\"DepthlessStyleType: Apply style method to item, using depth\"\"\" if self . obj is None : raise ValueError ( f \"Can not call { self . method !r} , as no object is assigned to this StyleCall.\" ) try : # mypy fails on one machine with this, but not on the other. return self . method ( self . obj . depth , item ) # type: ignore # this is purposefully broad, as anything can happen during these calls. except Exception as error : raise RuntimeError ( f \"Could not apply style { self . method } to { item !r} : { error } \" # type: ignore ) from error def __eq__ ( self , other : object ) -> bool : if not isinstance ( other , type ( self )): return False return other . method == self . method","title":"StyleCall"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.StyleCall.__call__","text":"DepthlessStyleType: Apply style method to item, using depth Source code in pytermgui/widgets/styles.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def __call__ ( self , item : str ) -> str : \"\"\"DepthlessStyleType: Apply style method to item, using depth\"\"\" if self . obj is None : raise ValueError ( f \"Can not call { self . method !r} , as no object is assigned to this StyleCall.\" ) try : # mypy fails on one machine with this, but not on the other. return self . method ( self . obj . depth , item ) # type: ignore # this is purposefully broad, as anything can happen during these calls. except Exception as error : raise RuntimeError ( f \"Could not apply style { self . method } to { item !r} : { error } \" # type: ignore ) from error","title":"__call__()"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.StyleManager","text":"Bases: UserDict An fancy dictionary to manage a Widget's styles. Individual styles can be accessed two ways: manager . styles . style_name == manager . _get_style ( \"style_name\" ) Same with setting: widget . styles . style_name = ... widget . set_style ( \"style_name\" , ... ) The set and get methods remain for backwards compatibility reasons, but all newly written code should use the dot syntax. It is also possible to set styles as markup shorthands. For example: widget . styles . border = \"60 bold\" ...is equivalent to: widget . styles . border = \"[60 bold] {item} \" Source code in pytermgui/widgets/styles.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 class StyleManager ( UserDict ): # pylint: disable=too-many-ancestors \"\"\"An fancy dictionary to manage a Widget's styles. Individual styles can be accessed two ways: ```python3 manager.styles.style_name == manager._get_style(\"style_name\") ``` Same with setting: ```python3 widget.styles.style_name = ... widget.set_style(\"style_name\", ...) ``` The `set` and `get` methods remain for backwards compatibility reasons, but all newly written code should use the dot syntax. It is also possible to set styles as markup shorthands. For example: ```python3 widget.styles.border = \"60 bold\" ``` ...is equivalent to: ```python3 widget.styles.border = \"[60 bold]{item}\" ``` \"\"\" def __init__ ( self , parent : Widget | Type [ Widget ] | None = None , ** base , ) -> None : \"\"\"Initializes a `StyleManager`. Args: parent: The parent of this instance. It will be assigned in all `StyleCall`-s created by it. \"\"\" self . __dict__ [ \"_is_setup\" ] = False self . parent = parent super () . __init__ () for key , value in base . items (): self . _set_as_stylecall ( key , value ) self . __dict__ [ \"_is_setup\" ] = self . parent is not None @staticmethod def expand_shorthand ( shorthand : str ) -> MarkupFormatter : \"\"\"Expands a shorthand string into a `MarkupFormatter` instance. For example, all of these will expand into `MarkupFormatter([60]{item}')`: - '60' - '[60]' - '[60]{item}' Args: shorthand: The short version of markup to expand. Returns: A `MarkupFormatter` with the expanded markup. \"\"\" if len ( shorthand ) == 0 : return MarkupFormatter ( \" {item} \" ) if RE_MARKUP . match ( shorthand ) is not None : return MarkupFormatter ( shorthand ) tokens = _sub_aliases ( tokenize_markup ( f \"[ { shorthand } ]\" ), tim . context ) colors = [ tkn for tkn in tokens if Token . is_color ( tkn )] if any ( tkn . color . background for tkn in colors ) and not any ( not tkn . color . background for tkn in colors ): shorthand += \" #auto\" markup = f \"[ { shorthand } ]\" if not \" {item} \" in shorthand : markup += \" {item} \" return MarkupFormatter ( markup ) @classmethod def merge ( cls , other : StyleManager , ** styles : str ) -> StyleManager : \"\"\"Creates a new manager that merges `other` with the passed in styles. Args: other: The style manager to base the new one from. **styles: The additional styles the new instance should have. Returns: A new `StyleManager`. This instance will only gather its data when `branch` is called on it. This is done so any changes made to the original data between the `merge` call and the actual usage of the instance will be reflected. \"\"\" return cls ( ** { ** other , ** styles }) def branch ( self , parent : Widget | Type [ Widget ]) -> StyleManager : \"\"\"Branch off from the `base` style dictionary. This method should be called during widget construction. It creates a new `StyleManager` based on self, but with its data detached from the original. Args: parent: The parent of the new instance. Returns: A new `StyleManager`, with detached instances of data. This can then be modified without touching the original instance. \"\"\" return type ( self )( parent , ** self . data ) def _set_as_stylecall ( self , key : str , item : StyleValue ) -> None : \"\"\"Sets `self.data[key]` as a `StyleCall` of the given item. If the item is a string, it will be expanded into a `MarkupFormatter` before being converted into the `StyleCall`, using `expand_shorthand`. \"\"\" if isinstance ( item , StyleCall ): self . data [ key ] = StyleCall ( self . parent , item . method ) return if isinstance ( item , str ): item = self . expand_shorthand ( item ) self . data [ key ] = StyleCall ( self . parent , item ) def __setitem__ ( self , key : str , value : StyleValue ) -> None : \"\"\"Sets an item in `self.data`. If the item is a string, it will be expanded into a `MarkupFormatter` before being converted into the `StyleCall`, using `expand_shorthand`. \"\"\" self . _set_as_stylecall ( key , value ) def __setattr__ ( self , key : str , value : StyleValue ) -> None : \"\"\"Sets an attribute. It first looks if it can set inside self.data, and defaults back to self.__dict__. Raises: KeyError: The given key is not a defined attribute, and is not part of this object's style set. \"\"\" found = False if \"data\" in self . __dict__ : for part in key . split ( \"__\" ): if part in self . data : self . _set_as_stylecall ( part , value ) found = True if found : return if self . __dict__ . get ( \"_is_setup\" ) and key not in self . __dict__ : raise KeyError ( f \"Style { key !r} was not defined during construction.\" ) self . __dict__ [ key ] = value def __getattr__ ( self , key : str ) -> StyleCall : \"\"\"Allows styles.dot_syntax.\"\"\" if key in self . __dict__ : return self . __dict__ [ key ] if key in self . __dict__ [ \"data\" ]: return self . __dict__ [ \"data\" ][ key ] raise AttributeError ( key , self . data ) def __call__ ( self , ** styles : StyleValue ) -> Any : \"\"\"Allows calling the manager and setting its styles. For example: ``` >>> Button(\"Hello\").styles(label=\"@60\") ``` \"\"\" for key , value in styles . items (): self . _set_as_stylecall ( key , value ) return self . parent","title":"StyleManager"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.StyleManager.__call__","text":"Allows calling the manager and setting its styles. For example: >>> Button(\"Hello\").styles(label=\"@60\") Source code in pytermgui/widgets/styles.py 326 327 328 329 330 331 332 333 334 335 336 337 338 def __call__ ( self , ** styles : StyleValue ) -> Any : \"\"\"Allows calling the manager and setting its styles. For example: ``` >>> Button(\"Hello\").styles(label=\"@60\") ``` \"\"\" for key , value in styles . items (): self . _set_as_stylecall ( key , value ) return self . parent","title":"__call__()"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.StyleManager.__getattr__","text":"Allows styles.dot_syntax. Source code in pytermgui/widgets/styles.py 315 316 317 318 319 320 321 322 323 324 def __getattr__ ( self , key : str ) -> StyleCall : \"\"\"Allows styles.dot_syntax.\"\"\" if key in self . __dict__ : return self . __dict__ [ key ] if key in self . __dict__ [ \"data\" ]: return self . __dict__ [ \"data\" ][ key ] raise AttributeError ( key , self . data )","title":"__getattr__()"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.StyleManager.__init__","text":"Initializes a StyleManager . Parameters: Name Type Description Default parent Widget | Type [ Widget ] | None The parent of this instance. It will be assigned in all StyleCall -s created by it. None Source code in pytermgui/widgets/styles.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def __init__ ( self , parent : Widget | Type [ Widget ] | None = None , ** base , ) -> None : \"\"\"Initializes a `StyleManager`. Args: parent: The parent of this instance. It will be assigned in all `StyleCall`-s created by it. \"\"\" self . __dict__ [ \"_is_setup\" ] = False self . parent = parent super () . __init__ () for key , value in base . items (): self . _set_as_stylecall ( key , value ) self . __dict__ [ \"_is_setup\" ] = self . parent is not None","title":"__init__()"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.StyleManager.__setattr__","text":"Sets an attribute. It first looks if it can set inside self.data, and defaults back to self. dict . Raises: Type Description KeyError The given key is not a defined attribute, and is not part of this object's style set. Source code in pytermgui/widgets/styles.py 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 def __setattr__ ( self , key : str , value : StyleValue ) -> None : \"\"\"Sets an attribute. It first looks if it can set inside self.data, and defaults back to self.__dict__. Raises: KeyError: The given key is not a defined attribute, and is not part of this object's style set. \"\"\" found = False if \"data\" in self . __dict__ : for part in key . split ( \"__\" ): if part in self . data : self . _set_as_stylecall ( part , value ) found = True if found : return if self . __dict__ . get ( \"_is_setup\" ) and key not in self . __dict__ : raise KeyError ( f \"Style { key !r} was not defined during construction.\" ) self . __dict__ [ key ] = value","title":"__setattr__()"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.StyleManager.__setitem__","text":"Sets an item in self.data . If the item is a string, it will be expanded into a MarkupFormatter before being converted into the StyleCall , using expand_shorthand . Source code in pytermgui/widgets/styles.py 280 281 282 283 284 285 286 287 def __setitem__ ( self , key : str , value : StyleValue ) -> None : \"\"\"Sets an item in `self.data`. If the item is a string, it will be expanded into a `MarkupFormatter` before being converted into the `StyleCall`, using `expand_shorthand`. \"\"\" self . _set_as_stylecall ( key , value )","title":"__setitem__()"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.StyleManager.branch","text":"Branch off from the base style dictionary. This method should be called during widget construction. It creates a new StyleManager based on self, but with its data detached from the original. Parameters: Name Type Description Default parent Widget | Type [ Widget ] The parent of the new instance. required Returns: Type Description StyleManager A new StyleManager , with detached instances of data. This can then be StyleManager modified without touching the original instance. Source code in pytermgui/widgets/styles.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 def branch ( self , parent : Widget | Type [ Widget ]) -> StyleManager : \"\"\"Branch off from the `base` style dictionary. This method should be called during widget construction. It creates a new `StyleManager` based on self, but with its data detached from the original. Args: parent: The parent of the new instance. Returns: A new `StyleManager`, with detached instances of data. This can then be modified without touching the original instance. \"\"\" return type ( self )( parent , ** self . data )","title":"branch()"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.StyleManager.expand_shorthand","text":"Expands a shorthand string into a MarkupFormatter instance. For example, all of these will expand into MarkupFormatter([60]{item}') : - '60' - '[60]' - '[60]{item}' Parameters: Name Type Description Default shorthand str The short version of markup to expand. required Returns: Type Description MarkupFormatter A MarkupFormatter with the expanded markup. Source code in pytermgui/widgets/styles.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 @staticmethod def expand_shorthand ( shorthand : str ) -> MarkupFormatter : \"\"\"Expands a shorthand string into a `MarkupFormatter` instance. For example, all of these will expand into `MarkupFormatter([60]{item}')`: - '60' - '[60]' - '[60]{item}' Args: shorthand: The short version of markup to expand. Returns: A `MarkupFormatter` with the expanded markup. \"\"\" if len ( shorthand ) == 0 : return MarkupFormatter ( \" {item} \" ) if RE_MARKUP . match ( shorthand ) is not None : return MarkupFormatter ( shorthand ) tokens = _sub_aliases ( tokenize_markup ( f \"[ { shorthand } ]\" ), tim . context ) colors = [ tkn for tkn in tokens if Token . is_color ( tkn )] if any ( tkn . color . background for tkn in colors ) and not any ( not tkn . color . background for tkn in colors ): shorthand += \" #auto\" markup = f \"[ { shorthand } ]\" if not \" {item} \" in shorthand : markup += \" {item} \" return MarkupFormatter ( markup )","title":"expand_shorthand()"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.StyleManager.merge","text":"Creates a new manager that merges other with the passed in styles. Parameters: Name Type Description Default other StyleManager The style manager to base the new one from. required **styles str The additional styles the new instance should have. {} Returns: Type Description StyleManager A new StyleManager . This instance will only gather its data when StyleManager branch is called on it. This is done so any changes made to the original StyleManager data between the merge call and the actual usage of the instance will be StyleManager reflected. Source code in pytermgui/widgets/styles.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 @classmethod def merge ( cls , other : StyleManager , ** styles : str ) -> StyleManager : \"\"\"Creates a new manager that merges `other` with the passed in styles. Args: other: The style manager to base the new one from. **styles: The additional styles the new instance should have. Returns: A new `StyleManager`. This instance will only gather its data when `branch` is called on it. This is done so any changes made to the original data between the `merge` call and the actual usage of the instance will be reflected. \"\"\" return cls ( ** { ** other , ** styles })","title":"merge()"},{"location":"reference/pytermgui/widgets/toggle/","text":"This module contains the Toggle class. Toggle Bases: Checkbox A specialized checkbox showing either of two states Source code in pytermgui/widgets/toggle.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Toggle ( Checkbox ): \"\"\"A specialized checkbox showing either of two states\"\"\" chars = { ** Checkbox . chars , ** { \"delimiter\" : [ \" \" , \" \" ], \"checked\" : \"choose\" }} def __init__ ( self , states : tuple [ str , str ], callback : Callable [[ str ], Any ] | None = None , ** attrs : Any , ) -> None : \"\"\"Initialize object\"\"\" self . states = states self . set_char ( \"checked\" , states [ 0 ]) self . set_char ( \"unchecked\" , states [ 1 ]) super () . __init__ ( callback , ** attrs ) self . toggle ( run_callback = False ) def _run_callback ( self ) -> None : \"\"\"Run the toggle callback with the label as its argument\"\"\" if self . callback is not None : self . callback ( self . label ) __init__ ( states , callback = None , attrs ) Initialize object Source code in pytermgui/widgets/toggle.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def __init__ ( self , states : tuple [ str , str ], callback : Callable [[ str ], Any ] | None = None , ** attrs : Any , ) -> None : \"\"\"Initialize object\"\"\" self . states = states self . set_char ( \"checked\" , states [ 0 ]) self . set_char ( \"unchecked\" , states [ 1 ]) super () . __init__ ( callback , ** attrs ) self . toggle ( run_callback = False )","title":"toggle"},{"location":"reference/pytermgui/widgets/toggle/#pytermgui.widgets.toggle.Toggle","text":"Bases: Checkbox A specialized checkbox showing either of two states Source code in pytermgui/widgets/toggle.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Toggle ( Checkbox ): \"\"\"A specialized checkbox showing either of two states\"\"\" chars = { ** Checkbox . chars , ** { \"delimiter\" : [ \" \" , \" \" ], \"checked\" : \"choose\" }} def __init__ ( self , states : tuple [ str , str ], callback : Callable [[ str ], Any ] | None = None , ** attrs : Any , ) -> None : \"\"\"Initialize object\"\"\" self . states = states self . set_char ( \"checked\" , states [ 0 ]) self . set_char ( \"unchecked\" , states [ 1 ]) super () . __init__ ( callback , ** attrs ) self . toggle ( run_callback = False ) def _run_callback ( self ) -> None : \"\"\"Run the toggle callback with the label as its argument\"\"\" if self . callback is not None : self . callback ( self . label )","title":"Toggle"},{"location":"reference/pytermgui/widgets/toggle/#pytermgui.widgets.toggle.Toggle.__init__","text":"Initialize object Source code in pytermgui/widgets/toggle.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def __init__ ( self , states : tuple [ str , str ], callback : Callable [[ str ], Any ] | None = None , ** attrs : Any , ) -> None : \"\"\"Initialize object\"\"\" self . states = states self . set_char ( \"checked\" , states [ 0 ]) self . set_char ( \"unchecked\" , states [ 1 ]) super () . __init__ ( callback , ** attrs ) self . toggle ( run_callback = False )","title":"__init__()"},{"location":"reference/pytermgui/window_manager/","text":"PyTermGUI's WindowManager, Compositor and Window live here. The window is a subclass of Container , and represents a desktop window. It can be moved, resized and otherwise interacted with. Compositor is a class specialized at drawing Window objects. It tries to be as efficient as possible, and follow a given target framerate. WindowManager is what ties the two together. It manages its list of Windows, transmits and handles mouse input and more.","title":"Index"},{"location":"reference/pytermgui/window_manager/compositor/","text":"The Compositor class, which is used by the WindowManager to draw onto the terminal. Compositor The class used to draw pytermgui.window_managers.manager.WindowManager state. This class handles turning a list of windows into a drawable buffer (composite), and then drawing it onto the screen. Calling its run method will start the drawing thread, which will draw the current window states onto the screen. This routine targets framerate , though will likely not match it perfectly. Source code in pytermgui/window_manager/compositor.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 class Compositor : \"\"\"The class used to draw `pytermgui.window_managers.manager.WindowManager` state. This class handles turning a list of windows into a drawable buffer (composite), and then drawing it onto the screen. Calling its `run` method will start the drawing thread, which will draw the current window states onto the screen. This routine targets `framerate`, though will likely not match it perfectly. \"\"\" def __init__ ( self , windows : list [ Window ], framerate : int ) -> None : \"\"\"Initializes the Compositor. Args: windows: A list of the windows to be drawn. \"\"\" self . _windows = windows self . _is_running = False self . _previous : PositionedLineList = [] self . _frametime = 0.0 self . _should_redraw : bool = True self . _cache : dict [ int , list [ str ]] = {} self . fps = 0 self . framerate = framerate @property def terminal ( self ) -> Terminal : \"\"\"Returns the current global terminal.\"\"\" return get_terminal () def _draw_loop ( self ) -> None : \"\"\"A loop that draws at regular intervals.\"\"\" framecount = 0 last_frame = fps_start_time = time . perf_counter () while self . _is_running : elapsed = time . perf_counter () - last_frame if elapsed < self . _frametime : time . sleep ( self . _frametime - elapsed ) continue animator . step ( elapsed ) last_frame = time . perf_counter () self . draw () framecount += 1 if last_frame - fps_start_time >= 1 : self . fps = framecount fps_start_time = last_frame framecount = 0 # NOTE: This is not needed at the moment, but might be at some point soon. # def _get_lines(self, window: Window) -> list[str]: # \"\"\"Gets lines from the window, caching when possible. # This also applies the blurred style of the window, if it has no focus. # \"\"\" # if window.allow_fullscreen: # window.pos = self.terminal.origin # window.width = self.terminal.width # window.height = self.terminal.height # return window.get_lines() # if window.has_focus or window.is_noblur: # return window.get_lines() # _id = id(window) # if not window.is_dirty and _id in self._cache: # return self._cache[_id] # lines: list[str] = [] # for line in window.get_lines(): # if not window.has_focus: # line = tim.parse(\"[239]\" + strip_ansi(line).replace(\"[\", r\"\\[\")) # lines.append(line) # self._cache[_id] = lines # return lines def _iter_positioned ( self , widget : Widget , until : int | None = None ) -> Iterator [ tuple [ tuple [ int , int ], str ]]: \"\"\"Iterates through (pos, line) tuples from widget.get_lines().\"\"\" # get_lines = widget.get_lines # if isinstance(widget, Window): # get_lines = lambda *_: self._get_lines(widget) # type: ignore width , height = self . terminal . size if until is None : until = widget . height for i , line in enumerate ( widget . get_lines ()[: until ]): if i >= until : break pos = ( widget . pos [ 0 ], widget . pos [ 1 ] + i ) yield ( pos , line ) for item in widget . positioned_line_buffer . copy (): pos , line = item if 0 <= pos [ 0 ] <= width and 0 <= pos [ 1 ] <= height : yield item widget . positioned_line_buffer . remove ( item ) @property def framerate ( self ) -> int : \"\"\"The framerate the draw loop runs at. Note: This will likely not be matched very accurately, mostly undershooting the given target. \"\"\" return self . _framerate @framerate . setter def framerate ( self , new : int ) -> None : \"\"\"Updates the framerate.\"\"\" self . _frametime = 1 / new self . _framerate = new def clear_cache ( self , window : Window ) -> None : \"\"\"Clears the compositor's cache related to the given window.\"\"\" if id ( window ) in self . _cache : del self . _cache [ id ( window )] def run ( self ) -> None : \"\"\"Runs the compositor draw loop as a thread.\"\"\" self . _is_running = True Thread ( name = \"CompositorDrawLoop\" , target = self . _draw_loop , daemon = True ) . start () def stop ( self ) -> None : \"\"\"Stops the compositor.\"\"\" self . _is_running = False def composite ( self ) -> PositionedLineList : \"\"\"Creates a composited buffer from the assigned windows. Note that this is currently not used.\"\"\" lines = [] windows = self . _windows # Don't unnecessarily print under full screen windows if any ( window . allow_fullscreen for window in self . _windows ): for window in reversed ( self . _windows ): if window . allow_fullscreen : windows = [ window ] break size_changes = { WidgetChange . WIDTH , WidgetChange . HEIGHT , WidgetChange . SIZE } for window in reversed ( windows ): if not window . has_focus : continue change = window . get_change () if change is None : continue if window . is_dirty or change in size_changes : for pos , line in self . _iter_positioned ( window ): lines . append (( pos , line )) window . is_dirty = False continue if change is not None : remaining = window . content_dimensions [ 1 ] for widget in window . dirty_widgets : for pos , line in self . _iter_positioned ( widget , until = remaining ): lines . append (( pos , line )) remaining -= widget . height window . dirty_widgets = [] continue if window . allow_fullscreen : break return lines def set_redraw ( self ) -> None : \"\"\"Flags compositor for full redraw. Note: At the moment the compositor will always redraw the entire screen. \"\"\" self . _should_redraw = True def draw ( self , force : bool = False ) -> None : \"\"\"Writes composited screen to the terminal. At the moment this uses full-screen rewrites. There is a compositing implementation in `composite`, but it is currently not performant enough to use. Args: force: When set, new composited lines will not be checked against the previous ones, and everything will be redrawn. \"\"\" # if self._should_redraw or force: lines : PositionedLineList = [] for window in reversed ( self . _windows ): lines . extend ( self . _iter_positioned ( window )) self . _should_redraw = False # else: # lines = self.composite() if not force and self . _previous == lines : return self . terminal . clear_stream () with self . terminal . frame () as frame : frame_write = frame . write for pos , line in lines : frame_write ( f \" \\x1b [ { pos [ 1 ] } ; { pos [ 0 ] } H { line } \" ) self . _previous = lines def redraw ( self ) -> None : \"\"\"Force-redraws the buffer.\"\"\" self . draw ( force = True ) def capture ( self , title : str , filename : str | None = None ) -> None : \"\"\"Captures the most-recently drawn buffer as `filename`. See `pytermgui.exporters.to_svg` for more information. \"\"\" with self . terminal . record () as recording : self . redraw () recording . save_svg ( title = title , filename = filename ) __init__ ( windows , framerate ) Initializes the Compositor. Parameters: Name Type Description Default windows list [ Window ] A list of the windows to be drawn. required Source code in pytermgui/window_manager/compositor.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __init__ ( self , windows : list [ Window ], framerate : int ) -> None : \"\"\"Initializes the Compositor. Args: windows: A list of the windows to be drawn. \"\"\" self . _windows = windows self . _is_running = False self . _previous : PositionedLineList = [] self . _frametime = 0.0 self . _should_redraw : bool = True self . _cache : dict [ int , list [ str ]] = {} self . fps = 0 self . framerate = framerate capture ( title , filename = None ) Captures the most-recently drawn buffer as filename . See pytermgui.exporters.to_svg for more information. Source code in pytermgui/window_manager/compositor.py 272 273 274 275 276 277 278 279 280 281 def capture ( self , title : str , filename : str | None = None ) -> None : \"\"\"Captures the most-recently drawn buffer as `filename`. See `pytermgui.exporters.to_svg` for more information. \"\"\" with self . terminal . record () as recording : self . redraw () recording . save_svg ( title = title , filename = filename ) clear_cache ( window ) Clears the compositor's cache related to the given window. Source code in pytermgui/window_manager/compositor.py 158 159 160 161 162 def clear_cache ( self , window : Window ) -> None : \"\"\"Clears the compositor's cache related to the given window.\"\"\" if id ( window ) in self . _cache : del self . _cache [ id ( window )] composite () Creates a composited buffer from the assigned windows. Note that this is currently not used. Source code in pytermgui/window_manager/compositor.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 def composite ( self ) -> PositionedLineList : \"\"\"Creates a composited buffer from the assigned windows. Note that this is currently not used.\"\"\" lines = [] windows = self . _windows # Don't unnecessarily print under full screen windows if any ( window . allow_fullscreen for window in self . _windows ): for window in reversed ( self . _windows ): if window . allow_fullscreen : windows = [ window ] break size_changes = { WidgetChange . WIDTH , WidgetChange . HEIGHT , WidgetChange . SIZE } for window in reversed ( windows ): if not window . has_focus : continue change = window . get_change () if change is None : continue if window . is_dirty or change in size_changes : for pos , line in self . _iter_positioned ( window ): lines . append (( pos , line )) window . is_dirty = False continue if change is not None : remaining = window . content_dimensions [ 1 ] for widget in window . dirty_widgets : for pos , line in self . _iter_positioned ( widget , until = remaining ): lines . append (( pos , line )) remaining -= widget . height window . dirty_widgets = [] continue if window . allow_fullscreen : break return lines draw ( force = False ) Writes composited screen to the terminal. At the moment this uses full-screen rewrites. There is a compositing implementation in composite , but it is currently not performant enough to use. Parameters: Name Type Description Default force bool When set, new composited lines will not be checked against the previous ones, and everything will be redrawn. False Source code in pytermgui/window_manager/compositor.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 def draw ( self , force : bool = False ) -> None : \"\"\"Writes composited screen to the terminal. At the moment this uses full-screen rewrites. There is a compositing implementation in `composite`, but it is currently not performant enough to use. Args: force: When set, new composited lines will not be checked against the previous ones, and everything will be redrawn. \"\"\" # if self._should_redraw or force: lines : PositionedLineList = [] for window in reversed ( self . _windows ): lines . extend ( self . _iter_positioned ( window )) self . _should_redraw = False # else: # lines = self.composite() if not force and self . _previous == lines : return self . terminal . clear_stream () with self . terminal . frame () as frame : frame_write = frame . write for pos , line in lines : frame_write ( f \" \\x1b [ { pos [ 1 ] } ; { pos [ 0 ] } H { line } \" ) self . _previous = lines framerate () property writable The framerate the draw loop runs at. Note This will likely not be matched very accurately, mostly undershooting the given target. Source code in pytermgui/window_manager/compositor.py 140 141 142 143 144 145 146 147 148 149 @property def framerate ( self ) -> int : \"\"\"The framerate the draw loop runs at. Note: This will likely not be matched very accurately, mostly undershooting the given target. \"\"\" return self . _framerate redraw () Force-redraws the buffer. Source code in pytermgui/window_manager/compositor.py 267 268 269 270 def redraw ( self ) -> None : \"\"\"Force-redraws the buffer.\"\"\" self . draw ( force = True ) run () Runs the compositor draw loop as a thread. Source code in pytermgui/window_manager/compositor.py 164 165 166 167 168 def run ( self ) -> None : \"\"\"Runs the compositor draw loop as a thread.\"\"\" self . _is_running = True Thread ( name = \"CompositorDrawLoop\" , target = self . _draw_loop , daemon = True ) . start () set_redraw () Flags compositor for full redraw. Note At the moment the compositor will always redraw the entire screen. Source code in pytermgui/window_manager/compositor.py 224 225 226 227 228 229 230 231 def set_redraw ( self ) -> None : \"\"\"Flags compositor for full redraw. Note: At the moment the compositor will always redraw the entire screen. \"\"\" self . _should_redraw = True stop () Stops the compositor. Source code in pytermgui/window_manager/compositor.py 170 171 172 173 def stop ( self ) -> None : \"\"\"Stops the compositor.\"\"\" self . _is_running = False terminal () property Returns the current global terminal. Source code in pytermgui/window_manager/compositor.py 49 50 51 52 53 @property def terminal ( self ) -> Terminal : \"\"\"Returns the current global terminal.\"\"\" return get_terminal ()","title":"compositor"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor","text":"The class used to draw pytermgui.window_managers.manager.WindowManager state. This class handles turning a list of windows into a drawable buffer (composite), and then drawing it onto the screen. Calling its run method will start the drawing thread, which will draw the current window states onto the screen. This routine targets framerate , though will likely not match it perfectly. Source code in pytermgui/window_manager/compositor.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 class Compositor : \"\"\"The class used to draw `pytermgui.window_managers.manager.WindowManager` state. This class handles turning a list of windows into a drawable buffer (composite), and then drawing it onto the screen. Calling its `run` method will start the drawing thread, which will draw the current window states onto the screen. This routine targets `framerate`, though will likely not match it perfectly. \"\"\" def __init__ ( self , windows : list [ Window ], framerate : int ) -> None : \"\"\"Initializes the Compositor. Args: windows: A list of the windows to be drawn. \"\"\" self . _windows = windows self . _is_running = False self . _previous : PositionedLineList = [] self . _frametime = 0.0 self . _should_redraw : bool = True self . _cache : dict [ int , list [ str ]] = {} self . fps = 0 self . framerate = framerate @property def terminal ( self ) -> Terminal : \"\"\"Returns the current global terminal.\"\"\" return get_terminal () def _draw_loop ( self ) -> None : \"\"\"A loop that draws at regular intervals.\"\"\" framecount = 0 last_frame = fps_start_time = time . perf_counter () while self . _is_running : elapsed = time . perf_counter () - last_frame if elapsed < self . _frametime : time . sleep ( self . _frametime - elapsed ) continue animator . step ( elapsed ) last_frame = time . perf_counter () self . draw () framecount += 1 if last_frame - fps_start_time >= 1 : self . fps = framecount fps_start_time = last_frame framecount = 0 # NOTE: This is not needed at the moment, but might be at some point soon. # def _get_lines(self, window: Window) -> list[str]: # \"\"\"Gets lines from the window, caching when possible. # This also applies the blurred style of the window, if it has no focus. # \"\"\" # if window.allow_fullscreen: # window.pos = self.terminal.origin # window.width = self.terminal.width # window.height = self.terminal.height # return window.get_lines() # if window.has_focus or window.is_noblur: # return window.get_lines() # _id = id(window) # if not window.is_dirty and _id in self._cache: # return self._cache[_id] # lines: list[str] = [] # for line in window.get_lines(): # if not window.has_focus: # line = tim.parse(\"[239]\" + strip_ansi(line).replace(\"[\", r\"\\[\")) # lines.append(line) # self._cache[_id] = lines # return lines def _iter_positioned ( self , widget : Widget , until : int | None = None ) -> Iterator [ tuple [ tuple [ int , int ], str ]]: \"\"\"Iterates through (pos, line) tuples from widget.get_lines().\"\"\" # get_lines = widget.get_lines # if isinstance(widget, Window): # get_lines = lambda *_: self._get_lines(widget) # type: ignore width , height = self . terminal . size if until is None : until = widget . height for i , line in enumerate ( widget . get_lines ()[: until ]): if i >= until : break pos = ( widget . pos [ 0 ], widget . pos [ 1 ] + i ) yield ( pos , line ) for item in widget . positioned_line_buffer . copy (): pos , line = item if 0 <= pos [ 0 ] <= width and 0 <= pos [ 1 ] <= height : yield item widget . positioned_line_buffer . remove ( item ) @property def framerate ( self ) -> int : \"\"\"The framerate the draw loop runs at. Note: This will likely not be matched very accurately, mostly undershooting the given target. \"\"\" return self . _framerate @framerate . setter def framerate ( self , new : int ) -> None : \"\"\"Updates the framerate.\"\"\" self . _frametime = 1 / new self . _framerate = new def clear_cache ( self , window : Window ) -> None : \"\"\"Clears the compositor's cache related to the given window.\"\"\" if id ( window ) in self . _cache : del self . _cache [ id ( window )] def run ( self ) -> None : \"\"\"Runs the compositor draw loop as a thread.\"\"\" self . _is_running = True Thread ( name = \"CompositorDrawLoop\" , target = self . _draw_loop , daemon = True ) . start () def stop ( self ) -> None : \"\"\"Stops the compositor.\"\"\" self . _is_running = False def composite ( self ) -> PositionedLineList : \"\"\"Creates a composited buffer from the assigned windows. Note that this is currently not used.\"\"\" lines = [] windows = self . _windows # Don't unnecessarily print under full screen windows if any ( window . allow_fullscreen for window in self . _windows ): for window in reversed ( self . _windows ): if window . allow_fullscreen : windows = [ window ] break size_changes = { WidgetChange . WIDTH , WidgetChange . HEIGHT , WidgetChange . SIZE } for window in reversed ( windows ): if not window . has_focus : continue change = window . get_change () if change is None : continue if window . is_dirty or change in size_changes : for pos , line in self . _iter_positioned ( window ): lines . append (( pos , line )) window . is_dirty = False continue if change is not None : remaining = window . content_dimensions [ 1 ] for widget in window . dirty_widgets : for pos , line in self . _iter_positioned ( widget , until = remaining ): lines . append (( pos , line )) remaining -= widget . height window . dirty_widgets = [] continue if window . allow_fullscreen : break return lines def set_redraw ( self ) -> None : \"\"\"Flags compositor for full redraw. Note: At the moment the compositor will always redraw the entire screen. \"\"\" self . _should_redraw = True def draw ( self , force : bool = False ) -> None : \"\"\"Writes composited screen to the terminal. At the moment this uses full-screen rewrites. There is a compositing implementation in `composite`, but it is currently not performant enough to use. Args: force: When set, new composited lines will not be checked against the previous ones, and everything will be redrawn. \"\"\" # if self._should_redraw or force: lines : PositionedLineList = [] for window in reversed ( self . _windows ): lines . extend ( self . _iter_positioned ( window )) self . _should_redraw = False # else: # lines = self.composite() if not force and self . _previous == lines : return self . terminal . clear_stream () with self . terminal . frame () as frame : frame_write = frame . write for pos , line in lines : frame_write ( f \" \\x1b [ { pos [ 1 ] } ; { pos [ 0 ] } H { line } \" ) self . _previous = lines def redraw ( self ) -> None : \"\"\"Force-redraws the buffer.\"\"\" self . draw ( force = True ) def capture ( self , title : str , filename : str | None = None ) -> None : \"\"\"Captures the most-recently drawn buffer as `filename`. See `pytermgui.exporters.to_svg` for more information. \"\"\" with self . terminal . record () as recording : self . redraw () recording . save_svg ( title = title , filename = filename )","title":"Compositor"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor.__init__","text":"Initializes the Compositor. Parameters: Name Type Description Default windows list [ Window ] A list of the windows to be drawn. required Source code in pytermgui/window_manager/compositor.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __init__ ( self , windows : list [ Window ], framerate : int ) -> None : \"\"\"Initializes the Compositor. Args: windows: A list of the windows to be drawn. \"\"\" self . _windows = windows self . _is_running = False self . _previous : PositionedLineList = [] self . _frametime = 0.0 self . _should_redraw : bool = True self . _cache : dict [ int , list [ str ]] = {} self . fps = 0 self . framerate = framerate","title":"__init__()"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor.capture","text":"Captures the most-recently drawn buffer as filename . See pytermgui.exporters.to_svg for more information. Source code in pytermgui/window_manager/compositor.py 272 273 274 275 276 277 278 279 280 281 def capture ( self , title : str , filename : str | None = None ) -> None : \"\"\"Captures the most-recently drawn buffer as `filename`. See `pytermgui.exporters.to_svg` for more information. \"\"\" with self . terminal . record () as recording : self . redraw () recording . save_svg ( title = title , filename = filename )","title":"capture()"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor.clear_cache","text":"Clears the compositor's cache related to the given window. Source code in pytermgui/window_manager/compositor.py 158 159 160 161 162 def clear_cache ( self , window : Window ) -> None : \"\"\"Clears the compositor's cache related to the given window.\"\"\" if id ( window ) in self . _cache : del self . _cache [ id ( window )]","title":"clear_cache()"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor.composite","text":"Creates a composited buffer from the assigned windows. Note that this is currently not used. Source code in pytermgui/window_manager/compositor.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 def composite ( self ) -> PositionedLineList : \"\"\"Creates a composited buffer from the assigned windows. Note that this is currently not used.\"\"\" lines = [] windows = self . _windows # Don't unnecessarily print under full screen windows if any ( window . allow_fullscreen for window in self . _windows ): for window in reversed ( self . _windows ): if window . allow_fullscreen : windows = [ window ] break size_changes = { WidgetChange . WIDTH , WidgetChange . HEIGHT , WidgetChange . SIZE } for window in reversed ( windows ): if not window . has_focus : continue change = window . get_change () if change is None : continue if window . is_dirty or change in size_changes : for pos , line in self . _iter_positioned ( window ): lines . append (( pos , line )) window . is_dirty = False continue if change is not None : remaining = window . content_dimensions [ 1 ] for widget in window . dirty_widgets : for pos , line in self . _iter_positioned ( widget , until = remaining ): lines . append (( pos , line )) remaining -= widget . height window . dirty_widgets = [] continue if window . allow_fullscreen : break return lines","title":"composite()"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor.draw","text":"Writes composited screen to the terminal. At the moment this uses full-screen rewrites. There is a compositing implementation in composite , but it is currently not performant enough to use. Parameters: Name Type Description Default force bool When set, new composited lines will not be checked against the previous ones, and everything will be redrawn. False Source code in pytermgui/window_manager/compositor.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 def draw ( self , force : bool = False ) -> None : \"\"\"Writes composited screen to the terminal. At the moment this uses full-screen rewrites. There is a compositing implementation in `composite`, but it is currently not performant enough to use. Args: force: When set, new composited lines will not be checked against the previous ones, and everything will be redrawn. \"\"\" # if self._should_redraw or force: lines : PositionedLineList = [] for window in reversed ( self . _windows ): lines . extend ( self . _iter_positioned ( window )) self . _should_redraw = False # else: # lines = self.composite() if not force and self . _previous == lines : return self . terminal . clear_stream () with self . terminal . frame () as frame : frame_write = frame . write for pos , line in lines : frame_write ( f \" \\x1b [ { pos [ 1 ] } ; { pos [ 0 ] } H { line } \" ) self . _previous = lines","title":"draw()"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor.framerate","text":"The framerate the draw loop runs at. Note This will likely not be matched very accurately, mostly undershooting the given target. Source code in pytermgui/window_manager/compositor.py 140 141 142 143 144 145 146 147 148 149 @property def framerate ( self ) -> int : \"\"\"The framerate the draw loop runs at. Note: This will likely not be matched very accurately, mostly undershooting the given target. \"\"\" return self . _framerate","title":"framerate()"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor.redraw","text":"Force-redraws the buffer. Source code in pytermgui/window_manager/compositor.py 267 268 269 270 def redraw ( self ) -> None : \"\"\"Force-redraws the buffer.\"\"\" self . draw ( force = True )","title":"redraw()"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor.run","text":"Runs the compositor draw loop as a thread. Source code in pytermgui/window_manager/compositor.py 164 165 166 167 168 def run ( self ) -> None : \"\"\"Runs the compositor draw loop as a thread.\"\"\" self . _is_running = True Thread ( name = \"CompositorDrawLoop\" , target = self . _draw_loop , daemon = True ) . start ()","title":"run()"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor.set_redraw","text":"Flags compositor for full redraw. Note At the moment the compositor will always redraw the entire screen. Source code in pytermgui/window_manager/compositor.py 224 225 226 227 228 229 230 231 def set_redraw ( self ) -> None : \"\"\"Flags compositor for full redraw. Note: At the moment the compositor will always redraw the entire screen. \"\"\" self . _should_redraw = True","title":"set_redraw()"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor.stop","text":"Stops the compositor. Source code in pytermgui/window_manager/compositor.py 170 171 172 173 def stop ( self ) -> None : \"\"\"Stops the compositor.\"\"\" self . _is_running = False","title":"stop()"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor.terminal","text":"Returns the current global terminal. Source code in pytermgui/window_manager/compositor.py 49 50 51 52 53 @property def terminal ( self ) -> Terminal : \"\"\"Returns the current global terminal.\"\"\" return get_terminal ()","title":"terminal()"},{"location":"reference/pytermgui/window_manager/layouts/","text":"Layouts for the WindowManager. ROW_BREAK = Slot ( 'Row Break' , Static ( 0 ), Static ( 0 )) module-attribute When encountered in Layout.build_rows , a new row will be started at the next element. Auto dataclass Bases: Dimension An automatically calculated dimension. The value of this dimension is overwritten on Layout.apply . Generally, the way calculations are done is by looking at the available size of the layout by subtracting the sum of all the non-auto dimensions from the terminal's width or height, and dividing it by the number of Auto-type dimensions in the current context. An additional offset is applied to the first dimension (left-most or top-most) of the context when the division has a remainder. Source code in pytermgui/window_manager/layouts.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 @dataclass class Auto ( Dimension ): \"\"\"An automatically calculated dimension. The value of this dimension is overwritten on `Layout.apply`. Generally, the way calculations are done is by looking at the available size of the layout by subtracting the sum of all the non-auto dimensions from the terminal's width or height, and dividing it by the number of Auto-type dimensions in the current context. An additional offset is applied to the first dimension (left-most or top-most) of the context when the division has a remainder. \"\"\" _value = 0 def __repr__ ( self ) -> str : return f \" { type ( self ) . __name__ } (value= { self . value } )\" Dimension The base class for layout dimensions. Each dimension has a value property. This returns an integer, and is essentially the meaning of the object. Source code in pytermgui/window_manager/layouts.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Dimension : \"\"\"The base class for layout dimensions. Each dimension has a `value` property. This returns an integer, and is essentially the *meaning* of the object. \"\"\" _value : int @property def value ( self ) -> int : \"\"\"Returns the value of the object. Override this for custom behaviour.\"\"\" return self . _value @value . setter def value ( self , new : int ) -> None : \"\"\"Sets a new value.\"\"\" self . _value = new def __repr__ ( self ) -> str : \"\"\"Returns `{typename}(value={value})`. We use this over the dataclasses one as that used `_value`, and it's a bit ugly. \"\"\" return f \" { type ( self ) . __name__ } (value= { self . value } )\" __repr__ () Returns {typename}(value={value}) . We use this over the dataclasses one as that used _value , and it's a bit ugly. Source code in pytermgui/window_manager/layouts.py 35 36 37 38 39 40 41 42 def __repr__ ( self ) -> str : \"\"\"Returns `{typename}(value={value})`. We use this over the dataclasses one as that used `_value`, and it's a bit ugly. \"\"\" return f \" { type ( self ) . __name__ } (value= { self . value } )\" value () property writable Returns the value of the object. Override this for custom behaviour. Source code in pytermgui/window_manager/layouts.py 21 22 23 24 25 26 27 @property def value ( self ) -> int : \"\"\"Returns the value of the object. Override this for custom behaviour.\"\"\" return self . _value Layout Defines a layout of Widgets, used by WindowManager. Internally, it keeps track of a list of Slot . This list is then turned into a list of rows, all containing slots. This is done either when the current row has run out of the terminal's width, or ROW_BREAK is encountered. Source code in pytermgui/window_manager/layouts.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 class Layout : \"\"\"Defines a layout of Widgets, used by WindowManager. Internally, it keeps track of a list of `Slot`. This list is then turned into a list of rows, all containing slots. This is done either when the current row has run out of the terminal's width, or `ROW_BREAK` is encountered. \"\"\" name : str def __init__ ( self , name : str = \"Layout\" ) -> None : self . name = name self . slots : list [ Slot ] = [] @property def terminal ( self ) -> Terminal : \"\"\"Returns the current global terminal instance.\"\"\" return get_terminal () def _to_rows ( self ) -> list [ list [ Slot ]]: \"\"\"Breaks `self.slots` into a list of list of slots. The terminal's remaining width is kept track of, and when a slot doesn't have enough space left it is pushed to a new row. Additionally, `ROW_BREAK` will force a new row to be created, starting with the next slot. \"\"\" rows : list [ list [ Slot ]] = [] available = self . terminal . width row : list [ Slot ] = [] for slot in self . slots : if available <= 0 or slot is ROW_BREAK : rows . append ( row ) row = [] available = self . terminal . width - slot . width . value if slot is ROW_BREAK : continue available -= slot . width . value row . append ( slot ) if len ( row ) > 0 : rows . append ( row ) return rows def build_rows ( self ) -> list [ list [ Slot ]]: \"\"\"Builds a list of slot rows, breaking them & applying automatic dimensions. Returns: A list[list[Slot]], aka. a list of slot-rows. \"\"\" def _get_height ( row : list [ Slot ]) -> int : defined = list ( filter ( lambda slot : not isinstance ( slot . height , Auto ), row )) if len ( defined ) > 0 : return max ( slot . height . value for slot in defined ) return 0 def _calculate_widths ( row : list [ Slot ]) -> tuple [ int , int ]: defined : list [ Slot ] = list ( filter ( lambda slt : not isinstance ( slt . width , Auto ), row ) ) undefined = list ( filter ( lambda slt : slt not in defined , row )) available = self . terminal . width - sum ( slot . width . value for slot in defined ) return divmod ( available , len ( undefined ) or 1 ) rows = self . _to_rows () heights = [ _get_height ( row ) for row in rows ] occupied = sum ( heights ) auto_height , extra_height = divmod ( self . terminal . height - occupied , heights . count ( 0 ) or 1 ) for row , height in zip ( rows , heights ): height = height or auto_height auto_width , extra_width = _calculate_widths ( row ) for slot in row : width = auto_width if isinstance ( slot . width , Auto ) else slot . width . value if isinstance ( slot . height , Auto ): slot . height . value = height + extra_height extra_height = 0 if isinstance ( slot . width , Auto ): slot . width . value = width + extra_width extra_width = 0 return rows def add_slot ( self , name : str = \"Slot\" , * , slot : Slot | None = None , width : Dimension | int | float | None = None , height : Dimension | int | float | None = None , index : int = - 1 , ) -> Slot : \"\"\"Adds a new slot to the layout. Args: name: The name of the slot. Used for display purposes. slot: An already instantiated `Slot` instance. If this is given, the additional width & height arguments will be ignored. width: The width for the new slot. See below for special types. height: The height for the new slot. See below for special types. index: The index to add the new slot to. Returns: The just-added slot. When defining dimensions, either width or height, some special value types can be given: - `Dimension`: Passed directly to the new slot. - `None`: An `Auto` dimension is created with no value. - `int`: A `Static` dimension is created with the given value. - `float`: A `Relative` dimension is created with the given value as its scale. Its `bound` attribute will default to the relevant part of the terminal's size. \"\"\" if slot is None : if width is None : width = Auto () elif isinstance ( width , int ): width = Static ( width ) elif isinstance ( width , float ): width = Relative ( width , bound = lambda : self . terminal . width ) if height is None : height = Auto () elif isinstance ( height , int ): height = Static ( height ) elif isinstance ( height , float ): height = Relative ( height , bound = lambda : self . terminal . height ) slot = Slot ( name , width = width , height = height ) if index == - 1 : self . slots . append ( slot ) return slot self . slots . insert ( index , slot ) return slot def add_break ( self , * , index : int = - 1 ) -> None : \"\"\"Adds `ROW_BREAK` to the given index. This special slot is ignored for all intents and purposes, other than when breaking the slots into rows. In that context, when encountered, the current row is deemed completed, and the next slot will go into a new row list. \"\"\" self . add_slot ( slot = ROW_BREAK , index = index ) def assign ( self , widget : Widget , * , index : int = - 1 , apply : bool = True ) -> None : \"\"\"Assigns a widget to the slot at the specified index. Args: widget: The widget to assign. index: The target slot's index. apply: If set, `apply` will be called once the widget has been assigned. \"\"\" slots = [ slot for slot in self . slots if slot is not ROW_BREAK ] if index > len ( slots ) - 1 : return slot = slots [ index ] slot . content = widget if apply : self . apply () def apply ( self ) -> None : \"\"\"Applies the layout to each slot.\"\"\" position = list ( self . terminal . origin ) for row in self . build_rows (): position [ 0 ] = 1 for slot in row : slot . apply (( position [ 0 ], position [ 1 ])) position [ 0 ] += slot . width . value position [ 1 ] += max ( slot . height . value for slot in row ) def __getattr__ ( self , attr : str ) -> Slot : \"\"\"Gets a slot by its (slugified) name.\"\"\" def _snakeify ( name : str ) -> str : return name . lower () . replace ( \" \" , \"_\" ) for slot in self . slots : if _snakeify ( slot . name ) == attr : return slot raise AttributeError ( f \"Slot with name { attr !r} could not be found.\" ) __getattr__ ( attr ) Gets a slot by its (slugified) name. Source code in pytermgui/window_manager/layouts.py 376 377 378 379 380 381 382 383 384 385 386 def __getattr__ ( self , attr : str ) -> Slot : \"\"\"Gets a slot by its (slugified) name.\"\"\" def _snakeify ( name : str ) -> str : return name . lower () . replace ( \" \" , \"_\" ) for slot in self . slots : if _snakeify ( slot . name ) == attr : return slot raise AttributeError ( f \"Slot with name { attr !r} could not be found.\" ) add_break ( * , index =- 1 ) Adds ROW_BREAK to the given index. This special slot is ignored for all intents and purposes, other than when breaking the slots into rows. In that context, when encountered, the current row is deemed completed, and the next slot will go into a new row list. Source code in pytermgui/window_manager/layouts.py 332 333 334 335 336 337 338 339 340 def add_break ( self , * , index : int = - 1 ) -> None : \"\"\"Adds `ROW_BREAK` to the given index. This special slot is ignored for all intents and purposes, other than when breaking the slots into rows. In that context, when encountered, the current row is deemed completed, and the next slot will go into a new row list. \"\"\" self . add_slot ( slot = ROW_BREAK , index = index ) add_slot ( name = 'Slot' , * , slot = None , width = None , height = None , index =- 1 ) Adds a new slot to the layout. Parameters: Name Type Description Default name str The name of the slot. Used for display purposes. 'Slot' slot Slot | None An already instantiated Slot instance. If this is given, the additional width & height arguments will be ignored. None width Dimension | int | float | None The width for the new slot. See below for special types. None height Dimension | int | float | None The height for the new slot. See below for special types. None index int The index to add the new slot to. -1 Returns: Type Description Slot The just-added slot. When defining dimensions, either width or height, some special value types can be given: - Dimension : Passed directly to the new slot. - None : An Auto dimension is created with no value. - int : A Static dimension is created with the given value. - float : A Relative dimension is created with the given value as its scale. Its bound attribute will default to the relevant part of the terminal's size. Source code in pytermgui/window_manager/layouts.py 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 def add_slot ( self , name : str = \"Slot\" , * , slot : Slot | None = None , width : Dimension | int | float | None = None , height : Dimension | int | float | None = None , index : int = - 1 , ) -> Slot : \"\"\"Adds a new slot to the layout. Args: name: The name of the slot. Used for display purposes. slot: An already instantiated `Slot` instance. If this is given, the additional width & height arguments will be ignored. width: The width for the new slot. See below for special types. height: The height for the new slot. See below for special types. index: The index to add the new slot to. Returns: The just-added slot. When defining dimensions, either width or height, some special value types can be given: - `Dimension`: Passed directly to the new slot. - `None`: An `Auto` dimension is created with no value. - `int`: A `Static` dimension is created with the given value. - `float`: A `Relative` dimension is created with the given value as its scale. Its `bound` attribute will default to the relevant part of the terminal's size. \"\"\" if slot is None : if width is None : width = Auto () elif isinstance ( width , int ): width = Static ( width ) elif isinstance ( width , float ): width = Relative ( width , bound = lambda : self . terminal . width ) if height is None : height = Auto () elif isinstance ( height , int ): height = Static ( height ) elif isinstance ( height , float ): height = Relative ( height , bound = lambda : self . terminal . height ) slot = Slot ( name , width = width , height = height ) if index == - 1 : self . slots . append ( slot ) return slot self . slots . insert ( index , slot ) return slot apply () Applies the layout to each slot. Source code in pytermgui/window_manager/layouts.py 362 363 364 365 366 367 368 369 370 371 372 373 374 def apply ( self ) -> None : \"\"\"Applies the layout to each slot.\"\"\" position = list ( self . terminal . origin ) for row in self . build_rows (): position [ 0 ] = 1 for slot in row : slot . apply (( position [ 0 ], position [ 1 ])) position [ 0 ] += slot . width . value position [ 1 ] += max ( slot . height . value for slot in row ) assign ( widget , * , index =- 1 , apply = True ) Assigns a widget to the slot at the specified index. Parameters: Name Type Description Default widget Widget The widget to assign. required index int The target slot's index. -1 apply bool If set, apply will be called once the widget has been assigned. True Source code in pytermgui/window_manager/layouts.py 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def assign ( self , widget : Widget , * , index : int = - 1 , apply : bool = True ) -> None : \"\"\"Assigns a widget to the slot at the specified index. Args: widget: The widget to assign. index: The target slot's index. apply: If set, `apply` will be called once the widget has been assigned. \"\"\" slots = [ slot for slot in self . slots if slot is not ROW_BREAK ] if index > len ( slots ) - 1 : return slot = slots [ index ] slot . content = widget if apply : self . apply () build_rows () Builds a list of slot rows, breaking them & applying automatic dimensions. Returns: Type Description list [ list [ Slot ]] A list[list[Slot]], aka. a list of slot-rows. Source code in pytermgui/window_manager/layouts.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 def build_rows ( self ) -> list [ list [ Slot ]]: \"\"\"Builds a list of slot rows, breaking them & applying automatic dimensions. Returns: A list[list[Slot]], aka. a list of slot-rows. \"\"\" def _get_height ( row : list [ Slot ]) -> int : defined = list ( filter ( lambda slot : not isinstance ( slot . height , Auto ), row )) if len ( defined ) > 0 : return max ( slot . height . value for slot in defined ) return 0 def _calculate_widths ( row : list [ Slot ]) -> tuple [ int , int ]: defined : list [ Slot ] = list ( filter ( lambda slt : not isinstance ( slt . width , Auto ), row ) ) undefined = list ( filter ( lambda slt : slt not in defined , row )) available = self . terminal . width - sum ( slot . width . value for slot in defined ) return divmod ( available , len ( undefined ) or 1 ) rows = self . _to_rows () heights = [ _get_height ( row ) for row in rows ] occupied = sum ( heights ) auto_height , extra_height = divmod ( self . terminal . height - occupied , heights . count ( 0 ) or 1 ) for row , height in zip ( rows , heights ): height = height or auto_height auto_width , extra_width = _calculate_widths ( row ) for slot in row : width = auto_width if isinstance ( slot . width , Auto ) else slot . width . value if isinstance ( slot . height , Auto ): slot . height . value = height + extra_height extra_height = 0 if isinstance ( slot . width , Auto ): slot . width . value = width + extra_width extra_width = 0 return rows terminal () property Returns the current global terminal instance. Source code in pytermgui/window_manager/layouts.py 185 186 187 188 189 @property def terminal ( self ) -> Terminal : \"\"\"Returns the current global terminal instance.\"\"\" return get_terminal () Relative dataclass Bases: Dimension A relative dimension. This dimension has a scale attribute and bound method. Every time the value is queried, int(self.bound() * self.scale) is returned. When instantiated through Layout.add_slot , bound will default to either the terminal's width or height, depending on which attribute it is applied to. Source code in pytermgui/window_manager/layouts.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @dataclass ( repr = False ) class Relative ( Dimension ): \"\"\"A relative dimension. This dimension has a scale attribute and bound method. Every time the `value` is queried, `int(self.bound() * self.scale)` is returned. When instantiated through `Layout.add_slot`, `bound` will default to either the terminal's width or height, depending on which attribute it is applied to. \"\"\" _value = 0 scale : float bound : Callable [[], int ] @property def value ( self ) -> int : \"\"\"Calculates the new value for the dimension.\"\"\" return int ( self . bound () * self . scale ) @value . setter def value ( self , new : int ) -> None : \"\"\"Disallows setting the value. We can't inherit and then override a set-get property with a get one, so this kind of patches that issue up. \"\"\" raise TypeError def __repr__ ( self ) -> str : scale = self . scale bound = self . bound original = super () . __repr__ () return original [: - 1 ] + f \", { scale =} , { bound =} \" + original [ - 1 ] value () property writable Calculates the new value for the dimension. Source code in pytermgui/window_manager/layouts.py 70 71 72 73 74 @property def value ( self ) -> int : \"\"\"Calculates the new value for the dimension.\"\"\" return int ( self . bound () * self . scale ) Slot dataclass A slot within a layout. A slot has a name, width & height, as well as some content. It's apply method can be called to apply the slot's position & dimensions to its content. Source code in pytermgui/window_manager/layouts.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 @dataclass class Slot : \"\"\"A slot within a layout. A slot has a name, width & height, as well as some content. It's `apply` method can be called to apply the slot's position & dimensions to its content. \"\"\" name : str width : Dimension height : Dimension content : Widget | None = None _restore_data : tuple [ int , int , tuple [ int , int ]] | None = None def apply ( self , position : tuple [ int , int ]) -> None : \"\"\"Applies the given position & dimension to the content. Args: position: The position that this object resides in. Set as its content's `pos`. \"\"\" if self . content is None or self . width is None or self . height is None : return if self . _restore_data is None : self . _restore_data = ( self . content . width , self . content . height , self . content . pos , ) self . content . height = self . height . value self . content . width = self . width . value self . content . pos = position def detach_content ( self ) -> None : \"\"\"Detaches content & restores its original state.\"\"\" content = self . content if content is None : raise AttributeError ( f \"No content to detach in { self !r} .\" ) assert self . _restore_data is not None content . width , content . height , content . pos = self . _restore_data self . content = None self . _restore_data = None apply ( position ) Applies the given position & dimension to the content. Parameters: Name Type Description Default position tuple [ int , int ] The position that this object resides in. Set as its content's pos . required Source code in pytermgui/window_manager/layouts.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def apply ( self , position : tuple [ int , int ]) -> None : \"\"\"Applies the given position & dimension to the content. Args: position: The position that this object resides in. Set as its content's `pos`. \"\"\" if self . content is None or self . width is None or self . height is None : return if self . _restore_data is None : self . _restore_data = ( self . content . width , self . content . height , self . content . pos , ) self . content . height = self . height . value self . content . width = self . width . value self . content . pos = position detach_content () Detaches content & restores its original state. Source code in pytermgui/window_manager/layouts.py 152 153 154 155 156 157 158 159 160 161 162 163 164 def detach_content ( self ) -> None : \"\"\"Detaches content & restores its original state.\"\"\" content = self . content if content is None : raise AttributeError ( f \"No content to detach in { self !r} .\" ) assert self . _restore_data is not None content . width , content . height , content . pos = self . _restore_data self . content = None self . _restore_data = None Static dataclass Bases: Dimension A static dimension. This dimension is immutable, and the Layout will always leave it unchanged. Source code in pytermgui/window_manager/layouts.py 45 46 47 48 49 50 51 52 @dataclass ( repr = False , frozen = True ) class Static ( Dimension ): \"\"\"A static dimension. This dimension is immutable, and the Layout will always leave it unchanged. \"\"\" _value : int = 0","title":"layouts"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.ROW_BREAK","text":"When encountered in Layout.build_rows , a new row will be started at the next element.","title":"ROW_BREAK"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Auto","text":"Bases: Dimension An automatically calculated dimension. The value of this dimension is overwritten on Layout.apply . Generally, the way calculations are done is by looking at the available size of the layout by subtracting the sum of all the non-auto dimensions from the terminal's width or height, and dividing it by the number of Auto-type dimensions in the current context. An additional offset is applied to the first dimension (left-most or top-most) of the context when the division has a remainder. Source code in pytermgui/window_manager/layouts.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 @dataclass class Auto ( Dimension ): \"\"\"An automatically calculated dimension. The value of this dimension is overwritten on `Layout.apply`. Generally, the way calculations are done is by looking at the available size of the layout by subtracting the sum of all the non-auto dimensions from the terminal's width or height, and dividing it by the number of Auto-type dimensions in the current context. An additional offset is applied to the first dimension (left-most or top-most) of the context when the division has a remainder. \"\"\" _value = 0 def __repr__ ( self ) -> str : return f \" { type ( self ) . __name__ } (value= { self . value } )\"","title":"Auto"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Dimension","text":"The base class for layout dimensions. Each dimension has a value property. This returns an integer, and is essentially the meaning of the object. Source code in pytermgui/window_manager/layouts.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Dimension : \"\"\"The base class for layout dimensions. Each dimension has a `value` property. This returns an integer, and is essentially the *meaning* of the object. \"\"\" _value : int @property def value ( self ) -> int : \"\"\"Returns the value of the object. Override this for custom behaviour.\"\"\" return self . _value @value . setter def value ( self , new : int ) -> None : \"\"\"Sets a new value.\"\"\" self . _value = new def __repr__ ( self ) -> str : \"\"\"Returns `{typename}(value={value})`. We use this over the dataclasses one as that used `_value`, and it's a bit ugly. \"\"\" return f \" { type ( self ) . __name__ } (value= { self . value } )\"","title":"Dimension"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Dimension.__repr__","text":"Returns {typename}(value={value}) . We use this over the dataclasses one as that used _value , and it's a bit ugly. Source code in pytermgui/window_manager/layouts.py 35 36 37 38 39 40 41 42 def __repr__ ( self ) -> str : \"\"\"Returns `{typename}(value={value})`. We use this over the dataclasses one as that used `_value`, and it's a bit ugly. \"\"\" return f \" { type ( self ) . __name__ } (value= { self . value } )\"","title":"__repr__()"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Dimension.value","text":"Returns the value of the object. Override this for custom behaviour. Source code in pytermgui/window_manager/layouts.py 21 22 23 24 25 26 27 @property def value ( self ) -> int : \"\"\"Returns the value of the object. Override this for custom behaviour.\"\"\" return self . _value","title":"value()"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Layout","text":"Defines a layout of Widgets, used by WindowManager. Internally, it keeps track of a list of Slot . This list is then turned into a list of rows, all containing slots. This is done either when the current row has run out of the terminal's width, or ROW_BREAK is encountered. Source code in pytermgui/window_manager/layouts.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 class Layout : \"\"\"Defines a layout of Widgets, used by WindowManager. Internally, it keeps track of a list of `Slot`. This list is then turned into a list of rows, all containing slots. This is done either when the current row has run out of the terminal's width, or `ROW_BREAK` is encountered. \"\"\" name : str def __init__ ( self , name : str = \"Layout\" ) -> None : self . name = name self . slots : list [ Slot ] = [] @property def terminal ( self ) -> Terminal : \"\"\"Returns the current global terminal instance.\"\"\" return get_terminal () def _to_rows ( self ) -> list [ list [ Slot ]]: \"\"\"Breaks `self.slots` into a list of list of slots. The terminal's remaining width is kept track of, and when a slot doesn't have enough space left it is pushed to a new row. Additionally, `ROW_BREAK` will force a new row to be created, starting with the next slot. \"\"\" rows : list [ list [ Slot ]] = [] available = self . terminal . width row : list [ Slot ] = [] for slot in self . slots : if available <= 0 or slot is ROW_BREAK : rows . append ( row ) row = [] available = self . terminal . width - slot . width . value if slot is ROW_BREAK : continue available -= slot . width . value row . append ( slot ) if len ( row ) > 0 : rows . append ( row ) return rows def build_rows ( self ) -> list [ list [ Slot ]]: \"\"\"Builds a list of slot rows, breaking them & applying automatic dimensions. Returns: A list[list[Slot]], aka. a list of slot-rows. \"\"\" def _get_height ( row : list [ Slot ]) -> int : defined = list ( filter ( lambda slot : not isinstance ( slot . height , Auto ), row )) if len ( defined ) > 0 : return max ( slot . height . value for slot in defined ) return 0 def _calculate_widths ( row : list [ Slot ]) -> tuple [ int , int ]: defined : list [ Slot ] = list ( filter ( lambda slt : not isinstance ( slt . width , Auto ), row ) ) undefined = list ( filter ( lambda slt : slt not in defined , row )) available = self . terminal . width - sum ( slot . width . value for slot in defined ) return divmod ( available , len ( undefined ) or 1 ) rows = self . _to_rows () heights = [ _get_height ( row ) for row in rows ] occupied = sum ( heights ) auto_height , extra_height = divmod ( self . terminal . height - occupied , heights . count ( 0 ) or 1 ) for row , height in zip ( rows , heights ): height = height or auto_height auto_width , extra_width = _calculate_widths ( row ) for slot in row : width = auto_width if isinstance ( slot . width , Auto ) else slot . width . value if isinstance ( slot . height , Auto ): slot . height . value = height + extra_height extra_height = 0 if isinstance ( slot . width , Auto ): slot . width . value = width + extra_width extra_width = 0 return rows def add_slot ( self , name : str = \"Slot\" , * , slot : Slot | None = None , width : Dimension | int | float | None = None , height : Dimension | int | float | None = None , index : int = - 1 , ) -> Slot : \"\"\"Adds a new slot to the layout. Args: name: The name of the slot. Used for display purposes. slot: An already instantiated `Slot` instance. If this is given, the additional width & height arguments will be ignored. width: The width for the new slot. See below for special types. height: The height for the new slot. See below for special types. index: The index to add the new slot to. Returns: The just-added slot. When defining dimensions, either width or height, some special value types can be given: - `Dimension`: Passed directly to the new slot. - `None`: An `Auto` dimension is created with no value. - `int`: A `Static` dimension is created with the given value. - `float`: A `Relative` dimension is created with the given value as its scale. Its `bound` attribute will default to the relevant part of the terminal's size. \"\"\" if slot is None : if width is None : width = Auto () elif isinstance ( width , int ): width = Static ( width ) elif isinstance ( width , float ): width = Relative ( width , bound = lambda : self . terminal . width ) if height is None : height = Auto () elif isinstance ( height , int ): height = Static ( height ) elif isinstance ( height , float ): height = Relative ( height , bound = lambda : self . terminal . height ) slot = Slot ( name , width = width , height = height ) if index == - 1 : self . slots . append ( slot ) return slot self . slots . insert ( index , slot ) return slot def add_break ( self , * , index : int = - 1 ) -> None : \"\"\"Adds `ROW_BREAK` to the given index. This special slot is ignored for all intents and purposes, other than when breaking the slots into rows. In that context, when encountered, the current row is deemed completed, and the next slot will go into a new row list. \"\"\" self . add_slot ( slot = ROW_BREAK , index = index ) def assign ( self , widget : Widget , * , index : int = - 1 , apply : bool = True ) -> None : \"\"\"Assigns a widget to the slot at the specified index. Args: widget: The widget to assign. index: The target slot's index. apply: If set, `apply` will be called once the widget has been assigned. \"\"\" slots = [ slot for slot in self . slots if slot is not ROW_BREAK ] if index > len ( slots ) - 1 : return slot = slots [ index ] slot . content = widget if apply : self . apply () def apply ( self ) -> None : \"\"\"Applies the layout to each slot.\"\"\" position = list ( self . terminal . origin ) for row in self . build_rows (): position [ 0 ] = 1 for slot in row : slot . apply (( position [ 0 ], position [ 1 ])) position [ 0 ] += slot . width . value position [ 1 ] += max ( slot . height . value for slot in row ) def __getattr__ ( self , attr : str ) -> Slot : \"\"\"Gets a slot by its (slugified) name.\"\"\" def _snakeify ( name : str ) -> str : return name . lower () . replace ( \" \" , \"_\" ) for slot in self . slots : if _snakeify ( slot . name ) == attr : return slot raise AttributeError ( f \"Slot with name { attr !r} could not be found.\" )","title":"Layout"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Layout.__getattr__","text":"Gets a slot by its (slugified) name. Source code in pytermgui/window_manager/layouts.py 376 377 378 379 380 381 382 383 384 385 386 def __getattr__ ( self , attr : str ) -> Slot : \"\"\"Gets a slot by its (slugified) name.\"\"\" def _snakeify ( name : str ) -> str : return name . lower () . replace ( \" \" , \"_\" ) for slot in self . slots : if _snakeify ( slot . name ) == attr : return slot raise AttributeError ( f \"Slot with name { attr !r} could not be found.\" )","title":"__getattr__()"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Layout.add_break","text":"Adds ROW_BREAK to the given index. This special slot is ignored for all intents and purposes, other than when breaking the slots into rows. In that context, when encountered, the current row is deemed completed, and the next slot will go into a new row list. Source code in pytermgui/window_manager/layouts.py 332 333 334 335 336 337 338 339 340 def add_break ( self , * , index : int = - 1 ) -> None : \"\"\"Adds `ROW_BREAK` to the given index. This special slot is ignored for all intents and purposes, other than when breaking the slots into rows. In that context, when encountered, the current row is deemed completed, and the next slot will go into a new row list. \"\"\" self . add_slot ( slot = ROW_BREAK , index = index )","title":"add_break()"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Layout.add_slot","text":"Adds a new slot to the layout. Parameters: Name Type Description Default name str The name of the slot. Used for display purposes. 'Slot' slot Slot | None An already instantiated Slot instance. If this is given, the additional width & height arguments will be ignored. None width Dimension | int | float | None The width for the new slot. See below for special types. None height Dimension | int | float | None The height for the new slot. See below for special types. None index int The index to add the new slot to. -1 Returns: Type Description Slot The just-added slot. When defining dimensions, either width or height, some special value types can be given: - Dimension : Passed directly to the new slot. - None : An Auto dimension is created with no value. - int : A Static dimension is created with the given value. - float : A Relative dimension is created with the given value as its scale. Its bound attribute will default to the relevant part of the terminal's size. Source code in pytermgui/window_manager/layouts.py 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 def add_slot ( self , name : str = \"Slot\" , * , slot : Slot | None = None , width : Dimension | int | float | None = None , height : Dimension | int | float | None = None , index : int = - 1 , ) -> Slot : \"\"\"Adds a new slot to the layout. Args: name: The name of the slot. Used for display purposes. slot: An already instantiated `Slot` instance. If this is given, the additional width & height arguments will be ignored. width: The width for the new slot. See below for special types. height: The height for the new slot. See below for special types. index: The index to add the new slot to. Returns: The just-added slot. When defining dimensions, either width or height, some special value types can be given: - `Dimension`: Passed directly to the new slot. - `None`: An `Auto` dimension is created with no value. - `int`: A `Static` dimension is created with the given value. - `float`: A `Relative` dimension is created with the given value as its scale. Its `bound` attribute will default to the relevant part of the terminal's size. \"\"\" if slot is None : if width is None : width = Auto () elif isinstance ( width , int ): width = Static ( width ) elif isinstance ( width , float ): width = Relative ( width , bound = lambda : self . terminal . width ) if height is None : height = Auto () elif isinstance ( height , int ): height = Static ( height ) elif isinstance ( height , float ): height = Relative ( height , bound = lambda : self . terminal . height ) slot = Slot ( name , width = width , height = height ) if index == - 1 : self . slots . append ( slot ) return slot self . slots . insert ( index , slot ) return slot","title":"add_slot()"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Layout.apply","text":"Applies the layout to each slot. Source code in pytermgui/window_manager/layouts.py 362 363 364 365 366 367 368 369 370 371 372 373 374 def apply ( self ) -> None : \"\"\"Applies the layout to each slot.\"\"\" position = list ( self . terminal . origin ) for row in self . build_rows (): position [ 0 ] = 1 for slot in row : slot . apply (( position [ 0 ], position [ 1 ])) position [ 0 ] += slot . width . value position [ 1 ] += max ( slot . height . value for slot in row )","title":"apply()"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Layout.assign","text":"Assigns a widget to the slot at the specified index. Parameters: Name Type Description Default widget Widget The widget to assign. required index int The target slot's index. -1 apply bool If set, apply will be called once the widget has been assigned. True Source code in pytermgui/window_manager/layouts.py 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def assign ( self , widget : Widget , * , index : int = - 1 , apply : bool = True ) -> None : \"\"\"Assigns a widget to the slot at the specified index. Args: widget: The widget to assign. index: The target slot's index. apply: If set, `apply` will be called once the widget has been assigned. \"\"\" slots = [ slot for slot in self . slots if slot is not ROW_BREAK ] if index > len ( slots ) - 1 : return slot = slots [ index ] slot . content = widget if apply : self . apply ()","title":"assign()"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Layout.build_rows","text":"Builds a list of slot rows, breaking them & applying automatic dimensions. Returns: Type Description list [ list [ Slot ]] A list[list[Slot]], aka. a list of slot-rows. Source code in pytermgui/window_manager/layouts.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 def build_rows ( self ) -> list [ list [ Slot ]]: \"\"\"Builds a list of slot rows, breaking them & applying automatic dimensions. Returns: A list[list[Slot]], aka. a list of slot-rows. \"\"\" def _get_height ( row : list [ Slot ]) -> int : defined = list ( filter ( lambda slot : not isinstance ( slot . height , Auto ), row )) if len ( defined ) > 0 : return max ( slot . height . value for slot in defined ) return 0 def _calculate_widths ( row : list [ Slot ]) -> tuple [ int , int ]: defined : list [ Slot ] = list ( filter ( lambda slt : not isinstance ( slt . width , Auto ), row ) ) undefined = list ( filter ( lambda slt : slt not in defined , row )) available = self . terminal . width - sum ( slot . width . value for slot in defined ) return divmod ( available , len ( undefined ) or 1 ) rows = self . _to_rows () heights = [ _get_height ( row ) for row in rows ] occupied = sum ( heights ) auto_height , extra_height = divmod ( self . terminal . height - occupied , heights . count ( 0 ) or 1 ) for row , height in zip ( rows , heights ): height = height or auto_height auto_width , extra_width = _calculate_widths ( row ) for slot in row : width = auto_width if isinstance ( slot . width , Auto ) else slot . width . value if isinstance ( slot . height , Auto ): slot . height . value = height + extra_height extra_height = 0 if isinstance ( slot . width , Auto ): slot . width . value = width + extra_width extra_width = 0 return rows","title":"build_rows()"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Layout.terminal","text":"Returns the current global terminal instance. Source code in pytermgui/window_manager/layouts.py 185 186 187 188 189 @property def terminal ( self ) -> Terminal : \"\"\"Returns the current global terminal instance.\"\"\" return get_terminal ()","title":"terminal()"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Relative","text":"Bases: Dimension A relative dimension. This dimension has a scale attribute and bound method. Every time the value is queried, int(self.bound() * self.scale) is returned. When instantiated through Layout.add_slot , bound will default to either the terminal's width or height, depending on which attribute it is applied to. Source code in pytermgui/window_manager/layouts.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @dataclass ( repr = False ) class Relative ( Dimension ): \"\"\"A relative dimension. This dimension has a scale attribute and bound method. Every time the `value` is queried, `int(self.bound() * self.scale)` is returned. When instantiated through `Layout.add_slot`, `bound` will default to either the terminal's width or height, depending on which attribute it is applied to. \"\"\" _value = 0 scale : float bound : Callable [[], int ] @property def value ( self ) -> int : \"\"\"Calculates the new value for the dimension.\"\"\" return int ( self . bound () * self . scale ) @value . setter def value ( self , new : int ) -> None : \"\"\"Disallows setting the value. We can't inherit and then override a set-get property with a get one, so this kind of patches that issue up. \"\"\" raise TypeError def __repr__ ( self ) -> str : scale = self . scale bound = self . bound original = super () . __repr__ () return original [: - 1 ] + f \", { scale =} , { bound =} \" + original [ - 1 ]","title":"Relative"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Relative.value","text":"Calculates the new value for the dimension. Source code in pytermgui/window_manager/layouts.py 70 71 72 73 74 @property def value ( self ) -> int : \"\"\"Calculates the new value for the dimension.\"\"\" return int ( self . bound () * self . scale )","title":"value()"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Slot","text":"A slot within a layout. A slot has a name, width & height, as well as some content. It's apply method can be called to apply the slot's position & dimensions to its content. Source code in pytermgui/window_manager/layouts.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 @dataclass class Slot : \"\"\"A slot within a layout. A slot has a name, width & height, as well as some content. It's `apply` method can be called to apply the slot's position & dimensions to its content. \"\"\" name : str width : Dimension height : Dimension content : Widget | None = None _restore_data : tuple [ int , int , tuple [ int , int ]] | None = None def apply ( self , position : tuple [ int , int ]) -> None : \"\"\"Applies the given position & dimension to the content. Args: position: The position that this object resides in. Set as its content's `pos`. \"\"\" if self . content is None or self . width is None or self . height is None : return if self . _restore_data is None : self . _restore_data = ( self . content . width , self . content . height , self . content . pos , ) self . content . height = self . height . value self . content . width = self . width . value self . content . pos = position def detach_content ( self ) -> None : \"\"\"Detaches content & restores its original state.\"\"\" content = self . content if content is None : raise AttributeError ( f \"No content to detach in { self !r} .\" ) assert self . _restore_data is not None content . width , content . height , content . pos = self . _restore_data self . content = None self . _restore_data = None","title":"Slot"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Slot.apply","text":"Applies the given position & dimension to the content. Parameters: Name Type Description Default position tuple [ int , int ] The position that this object resides in. Set as its content's pos . required Source code in pytermgui/window_manager/layouts.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def apply ( self , position : tuple [ int , int ]) -> None : \"\"\"Applies the given position & dimension to the content. Args: position: The position that this object resides in. Set as its content's `pos`. \"\"\" if self . content is None or self . width is None or self . height is None : return if self . _restore_data is None : self . _restore_data = ( self . content . width , self . content . height , self . content . pos , ) self . content . height = self . height . value self . content . width = self . width . value self . content . pos = position","title":"apply()"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Slot.detach_content","text":"Detaches content & restores its original state. Source code in pytermgui/window_manager/layouts.py 152 153 154 155 156 157 158 159 160 161 162 163 164 def detach_content ( self ) -> None : \"\"\"Detaches content & restores its original state.\"\"\" content = self . content if content is None : raise AttributeError ( f \"No content to detach in { self !r} .\" ) assert self . _restore_data is not None content . width , content . height , content . pos = self . _restore_data self . content = None self . _restore_data = None","title":"detach_content()"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Static","text":"Bases: Dimension A static dimension. This dimension is immutable, and the Layout will always leave it unchanged. Source code in pytermgui/window_manager/layouts.py 45 46 47 48 49 50 51 52 @dataclass ( repr = False , frozen = True ) class Static ( Dimension ): \"\"\"A static dimension. This dimension is immutable, and the Layout will always leave it unchanged. \"\"\" _value : int = 0","title":"Static"},{"location":"reference/pytermgui/window_manager/manager/","text":"The WindowManager class, whos job it is to move, control and update windows, while letting Compositor draw them. Edge Bases: Enum Enum for window edges. Source code in pytermgui/window_manager/manager.py 35 36 37 38 39 40 41 class Edge ( Enum ): \"\"\"Enum for window edges.\"\"\" LEFT = _auto () TOP = _auto () RIGHT = _auto () BOTTOM = _auto () WindowManager Bases: Widget The manager of windows. This class can be used, or even subclassed in order to create full-screen applications, using the pytermgui.window_manager.window.Window class and the general Widget API. Source code in pytermgui/window_manager/manager.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 class WindowManager ( Widget ): # pylint: disable=too-many-instance-attributes \"\"\"The manager of windows. This class can be used, or even subclassed in order to create full-screen applications, using the `pytermgui.window_manager.window.Window` class and the general Widget API. \"\"\" focusing_actions = ( MouseAction . LEFT_CLICK , MouseAction . RIGHT_CLICK ) \"\"\"These mouse actions will focus the window they are acted upon.\"\"\" autorun = True def __init__ ( self , * , layout_type : Type [ Layout ] = Layout , framerate : int = 60 , autorun : bool | None = None , ) -> None : \"\"\"Initialize the manager.\"\"\" super () . __init__ () self . _is_running = False self . _windows : list [ Window ] = [] self . _bindings : dict [ str | Type [ MouseEvent ], tuple [ BoundCallback , str ]] = {} self . focused : Window | None = None if autorun is not None : self . autorun = autorun self . layout = layout_type () self . compositor = Compositor ( self . _windows , framerate = framerate ) self . mouse_translator : MouseTranslator | None = None self . _mouse_target : Window | None = None self . _drag_offsets : tuple [ int , int ] = ( 0 , 0 ) self . _drag_target : tuple [ Window , Edge ] | None = None # This isn't quite implemented at the moment. self . restrict_within_bounds = True terminal . subscribe ( terminal . RESIZE , self . on_resize ) def __iadd__ ( self , other : object ) -> WindowManager : \"\"\"Adds a window to the manager.\"\"\" if not isinstance ( other , Window ): raise ValueError ( \"You may only add windows to a WindowManager.\" ) return self . add ( other ) def __isub__ ( self , other : object ) -> WindowManager : \"\"\"Removes a window from the manager.\"\"\" if not isinstance ( other , Window ): raise ValueError ( \"You may only add windows to a WindowManager.\" ) return self . remove ( other ) def __enter__ ( self ) -> WindowManager : \"\"\"Starts context manager.\"\"\" return self def __exit__ ( self , _ : Any , exception : Exception , __ : Any ) -> bool : \"\"\"Ends context manager.\"\"\" # Run the manager if it hasnt been run before. if self . autorun and exception is None and self . mouse_translator is None : self . run () if exception is not None : self . stop () raise exception return True def __iter__ ( self ) -> Iterator [ Window ]: \"\"\"Iterates this manager's windows.\"\"\" return iter ( self . _windows ) def _run_input_loop ( self ) -> None : \"\"\"The main input loop of the WindowManager.\"\"\" while self . _is_running : key = getch ( interrupts = False ) if key == chr ( 3 ): self . stop () break if self . handle_key ( key ): continue self . process_mouse ( key ) def get_lines ( self ) -> list [ str ]: \"\"\"Gets the empty list.\"\"\" # TODO: Allow using WindowManager as a widget. return [] def clear_cache ( self , window : Window ) -> None : \"\"\"Clears the compositor's cache related to the given window.\"\"\" self . compositor . clear_cache ( window ) def on_resize ( self , size : tuple [ int , int ]) -> None : \"\"\"Correctly updates window positions & prints when terminal gets resized. Args: size: The new terminal size. \"\"\" width , height = size for window in self . _windows : newx = max ( 0 , min ( window . pos [ 0 ], width - window . width )) newy = max ( 0 , min ( window . pos [ 1 ], height - window . height + 1 )) window . pos = ( newx , newy ) self . layout . apply () self . compositor . redraw () def run ( self , mouse_events : list [ str ] | None = None ) -> None : \"\"\"Starts the WindowManager. Args: mouse_events: A list of mouse event types to listen to. See `pytermgui.ansi_interface.report_mouse` for more information. Defaults to `[\"press_hold\", \"hover\"]`. Returns: The WindowManager's compositor instance. \"\"\" self . _is_running = True if mouse_events is None : mouse_events = [ \"press_hold\" , \"hover\" ] with alt_buffer ( cursor = False , echo = False ): with mouse_handler ( mouse_events , \"decimal_xterm\" ) as translate : self . mouse_translator = translate self . compositor . run () self . _run_input_loop () def stop ( self ) -> None : \"\"\"Stops the WindowManager and its compositor.\"\"\" self . compositor . stop () self . _is_running = False def add ( self , window : Window , assign : str | bool = True , animate : bool = True ) -> WindowManager : \"\"\"Adds a window to the manager. Args: window: The window to add. assign: The name of the slot the new window should be assigned to, or a boolean. If it is given a str, it is treated as the name of a slot. When given True, the next non-filled slot will be assigned, and when given False no assignment will be done. animate: If set, an animation will be played on the window once it's added. \"\"\" self . _windows . insert ( 0 , window ) window . manager = self if assign : if isinstance ( assign , str ): getattr ( self . layout , assign ) . content = window elif len ( self . _windows ) <= len ( self . layout . slots ): self . layout . assign ( window , index = len ( self . _windows ) - 1 ) self . layout . apply () # New windows take focus-precedence over already # existing ones, even if they are modal. self . focus ( window ) if not animate : return self if window . height > 1 : animator . animate_attr ( target = window , attr = \"height\" , start = 0 , end = window . height , duration = 300 , on_step = _center_during_animation , ) return self def remove ( self , window : Window , autostop : bool = True , animate : bool = True , ) -> WindowManager : \"\"\"Removes a window from the manager. Args: window: The window to remove. autostop: If set, the manager will be stopped if the length of its windows hits 0. \"\"\" def _on_finish ( _ : AttrAnimation | None ) -> bool : self . _windows . remove ( window ) if autostop and len ( self . _windows ) == 0 : self . stop () else : self . focus ( self . _windows [ 0 ]) return True if not animate : _on_finish ( None ) return self animator . animate_attr ( target = window , attr = \"height\" , end = 0 , duration = 300 , on_step = _center_during_animation , on_finish = _on_finish , ) return self def focus ( self , window : Window | None ) -> None : \"\"\"Focuses a window by moving it to the first index in _windows.\"\"\" if self . focused is not None : self . focused . blur () self . focused = window if window is not None : self . _windows . remove ( window ) self . _windows . insert ( 0 , window ) window . focus () def focus_next ( self ) -> Window | None : \"\"\"Focuses the next window in focus order, looping to first at the end.\"\"\" if self . focused is None : self . focus ( self . _windows [ 0 ]) return self . focused index = self . _windows . index ( self . focused ) if index == len ( self . _windows ) - 1 : index = 0 window = self . _windows [ index ] traversed = 0 while window . is_persistent or window is self . focused : if index >= len ( self . _windows ): index = 0 window = self . _windows [ index ] index += 1 traversed += 1 if traversed >= len ( self . _windows ): return self . focused self . focus ( self . _windows [ index ]) return self . focused def handle_key ( self , key : str ) -> bool : \"\"\"Processes a keypress. Args: key: The key to handle. Returns: True if the given key could be processed, False otherwise. \"\"\" # Apply WindowManager bindings if self . execute_binding ( key ): return True # Apply focused window binding, or send to InputField if self . focused is not None : if self . focused . execute_binding ( key ): return True if self . focused . handle_key ( key ): return True return False # I prefer having the _click, _drag and _release helpers within this function, for # easier readability. def process_mouse ( self , key : str ) -> None : # pylint: disable=too-many-statements \"\"\"Processes (potential) mouse input. Args: key: Input to handle. \"\"\" window : Window def _clamp_pos ( pos : tuple [ int , int ], index : int ) -> int : \"\"\"Clamp a value using index to address x/y & width/height\"\"\" offset = self . _drag_offsets [ index ] # TODO: This -2 is a very magical number. Not good. maximum = terminal . size [ index ] - (( window . width , window . height )[ index ] - 2 ) start_margin_index = abs ( index - 1 ) if self . restrict_within_bounds : return max ( index + terminal . margins [ start_margin_index ], min ( pos [ index ] - offset , maximum - terminal . margins [ start_margin_index + 2 ] - terminal . origin [ index ], ), ) return pos [ index ] - offset def _click ( pos : tuple [ int , int ], window : Window ) -> bool : \"\"\"Process clicking a window.\"\"\" left , top , right , bottom = window . rect borders = window . chars . get ( \"border\" , [ \" \" ] * 4 ) if real_length ( borders [ 1 ]) > 0 and pos [ 1 ] == top and left <= pos [ 0 ] < right : self . _drag_target = ( window , Edge . TOP ) elif ( real_length ( borders [ 3 ]) > 0 and pos [ 1 ] == bottom - 1 and left <= pos [ 0 ] < right ): self . _drag_target = ( window , Edge . BOTTOM ) elif ( real_length ( borders [ 0 ]) > 0 and pos [ 0 ] == left and top <= pos [ 1 ] < bottom ): self . _drag_target = ( window , Edge . LEFT ) elif ( real_length ( borders [ 2 ]) > 0 and pos [ 0 ] == right - 1 and top <= pos [ 1 ] < bottom ): self . _drag_target = ( window , Edge . RIGHT ) else : return False self . _drag_offsets = ( pos [ 0 ] - window . pos [ 0 ], pos [ 1 ] - window . pos [ 1 ], ) return True def _drag ( pos : tuple [ int , int ], window : Window ) -> bool : \"\"\"Process dragging a window\"\"\" if self . _drag_target is None : return False target_window , edge = self . _drag_target handled = False if window is not target_window : return False left , top , right , bottom = window . rect if not window . is_static and edge is Edge . TOP : window . pos = ( _clamp_pos ( pos , 0 ), _clamp_pos ( pos , 1 ), ) handled = True # TODO: Why are all these arbitrary offsets needed? elif not window . is_noresize : if edge is Edge . RIGHT : window . rect = ( left , top , pos [ 0 ] + 1 , bottom ) handled = True elif edge is Edge . LEFT : window . rect = ( pos [ 0 ], top , right , bottom ) handled = True elif edge is Edge . BOTTOM : window . rect = ( left , top , right , pos [ 1 ] + 1 ) handled = True if handled : window . is_dirty = True self . compositor . set_redraw () return handled def _release ( _ : tuple [ int , int ], __ : Window ) -> bool : \"\"\"Process release of key\"\"\" self . _drag_target = None # This return False so Window can handle the mouse action as well, # as not much is done in this callback. return False handlers = { MouseAction . LEFT_CLICK : _click , MouseAction . LEFT_DRAG : _drag , MouseAction . RELEASE : _release , } translate = self . mouse_translator event_list = None if translate is None else translate ( key ) if event_list is None : return for event in event_list : # Ignore null-events if event is None : continue for window in self . _windows : contains = window . contains ( event . position ) if event . action in self . focusing_actions : self . focus ( window ) if event . action in handlers and handlers [ event . action ]( event . position , window ): break if contains : if self . _mouse_target is not None : self . _mouse_target . handle_mouse ( MouseEvent ( MouseAction . RELEASE , event . position ) ) self . _mouse_target = window window . handle_mouse ( event ) break if window . is_modal : break # Unset drag_target if no windows received the input else : self . _drag_target = None if self . _mouse_target is not None : self . _mouse_target . handle_mouse ( MouseEvent ( MouseAction . RELEASE , event . position ) ) self . _mouse_target = None def screenshot ( self , title : str , filename : str = \"screenshot.svg\" ) -> None : \"\"\"Takes a screenshot of the current state. See `pytermgui.exporters.to_svg` for more information. Args: filename: The name of the file. \"\"\" self . compositor . capture ( title = title , filename = filename ) def show_positions ( self ) -> None : \"\"\"Shows the positions of each Window's widgets.\"\"\" def _show_positions ( widget , color_base : int = 60 ) -> None : \"\"\"Show positions of widget.\"\"\" if isinstance ( widget , Container ): for i , subwidget in enumerate ( widget ): _show_positions ( subwidget , color_base + i ) return if not widget . is_selectable : return debug = widget . debug () color = str_to_color ( f \"@ { color_base } \" ) buff = color ( \" \" , reset = False ) for i in range ( min ( widget . width , real_length ( debug )) - 1 ): buff += debug [ i ] self . terminal . write ( buff , pos = widget . pos ) for widget in self . _windows : _show_positions ( widget ) self . terminal . flush () getch () def alert ( self , * items : Any , center : bool = True , ** attributes : Any ) -> Window : \"\"\"Creates a modal popup of the given elements and attributes. Args: *items: All widget-convertable objects passed as children of the new window. center: If set, `pytermgui.window_manager.window.center` is called on the window. **attributes: kwargs passed as the new window's attributes. \"\"\" window = Window ( * items , is_modal = True , ** attributes ) if center : window . center () self . add ( window , assign = False ) return window def toast ( self , * items : Any , offset : int = 0 , duration : int = 300 , delay : int = 1000 , ** attributes : Any , ) -> Window : \"\"\"Creates a Material UI-inspired toast window of the given elements and attributes. Args: *items: All widget-convertable objects passed as children of the new window. delay: The amount of time before the window will start animating out. **attributes: kwargs passed as the new window's attributes. \"\"\" # pylint: disable=no-value-for-parameter toast = Window ( * items , is_noblur = True , ** attributes ) target_height = toast . height toast . overflow = Overflow . HIDE def _finish ( _ : Animation ) -> None : self . remove ( toast , animate = False ) def _progressively_show ( anim : Animation , invert : bool = False ) -> bool : height = int ( anim . state * target_height ) toast . center () if invert : toast . height = target_height - 1 - height toast . pos = ( toast . pos [ 0 ], self . terminal . height - toast . height + 1 - offset , ) return False toast . height = height toast . pos = ( toast . pos [ 0 ], self . terminal . height - toast . height + 1 - offset ) return False def _animate_toast_out ( _ : Animation ) -> None : animator . schedule ( FloatAnimation ( delay , on_finish = lambda * _ : animator . schedule ( FloatAnimation ( duration , on_step = lambda anim : _progressively_show ( anim , invert = True ), on_finish = _finish , ) ), ) ) leadup = FloatAnimation ( duration , on_step = _progressively_show , on_finish = _animate_toast_out ) # pylint: enable=no-value-for-parameter self . add ( toast . center (), animate = False , assign = False ) self . focus ( toast ) animator . schedule ( leadup ) return toast focusing_actions = ( MouseAction . LEFT_CLICK , MouseAction . RIGHT_CLICK ) class-attribute These mouse actions will focus the window they are acted upon. __enter__ () Starts context manager. Source code in pytermgui/window_manager/manager.py 105 106 107 108 def __enter__ ( self ) -> WindowManager : \"\"\"Starts context manager.\"\"\" return self __exit__ ( _ , exception , __ ) Ends context manager. Source code in pytermgui/window_manager/manager.py 110 111 112 113 114 115 116 117 118 119 120 121 def __exit__ ( self , _ : Any , exception : Exception , __ : Any ) -> bool : \"\"\"Ends context manager.\"\"\" # Run the manager if it hasnt been run before. if self . autorun and exception is None and self . mouse_translator is None : self . run () if exception is not None : self . stop () raise exception return True __iadd__ ( other ) Adds a window to the manager. Source code in pytermgui/window_manager/manager.py 89 90 91 92 93 94 95 def __iadd__ ( self , other : object ) -> WindowManager : \"\"\"Adds a window to the manager.\"\"\" if not isinstance ( other , Window ): raise ValueError ( \"You may only add windows to a WindowManager.\" ) return self . add ( other ) __init__ ( * , layout_type = Layout , framerate = 60 , autorun = None ) Initialize the manager. Source code in pytermgui/window_manager/manager.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def __init__ ( self , * , layout_type : Type [ Layout ] = Layout , framerate : int = 60 , autorun : bool | None = None , ) -> None : \"\"\"Initialize the manager.\"\"\" super () . __init__ () self . _is_running = False self . _windows : list [ Window ] = [] self . _bindings : dict [ str | Type [ MouseEvent ], tuple [ BoundCallback , str ]] = {} self . focused : Window | None = None if autorun is not None : self . autorun = autorun self . layout = layout_type () self . compositor = Compositor ( self . _windows , framerate = framerate ) self . mouse_translator : MouseTranslator | None = None self . _mouse_target : Window | None = None self . _drag_offsets : tuple [ int , int ] = ( 0 , 0 ) self . _drag_target : tuple [ Window , Edge ] | None = None # This isn't quite implemented at the moment. self . restrict_within_bounds = True terminal . subscribe ( terminal . RESIZE , self . on_resize ) __isub__ ( other ) Removes a window from the manager. Source code in pytermgui/window_manager/manager.py 97 98 99 100 101 102 103 def __isub__ ( self , other : object ) -> WindowManager : \"\"\"Removes a window from the manager.\"\"\" if not isinstance ( other , Window ): raise ValueError ( \"You may only add windows to a WindowManager.\" ) return self . remove ( other ) __iter__ () Iterates this manager's windows. Source code in pytermgui/window_manager/manager.py 123 124 125 126 def __iter__ ( self ) -> Iterator [ Window ]: \"\"\"Iterates this manager's windows.\"\"\" return iter ( self . _windows ) add ( window , assign = True , animate = True ) Adds a window to the manager. Parameters: Name Type Description Default window Window The window to add. required assign str | bool The name of the slot the new window should be assigned to, or a boolean. If it is given a str, it is treated as the name of a slot. When given True, the next non-filled slot will be assigned, and when given False no assignment will be done. True animate bool If set, an animation will be played on the window once it's added. True Source code in pytermgui/window_manager/manager.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def add ( self , window : Window , assign : str | bool = True , animate : bool = True ) -> WindowManager : \"\"\"Adds a window to the manager. Args: window: The window to add. assign: The name of the slot the new window should be assigned to, or a boolean. If it is given a str, it is treated as the name of a slot. When given True, the next non-filled slot will be assigned, and when given False no assignment will be done. animate: If set, an animation will be played on the window once it's added. \"\"\" self . _windows . insert ( 0 , window ) window . manager = self if assign : if isinstance ( assign , str ): getattr ( self . layout , assign ) . content = window elif len ( self . _windows ) <= len ( self . layout . slots ): self . layout . assign ( window , index = len ( self . _windows ) - 1 ) self . layout . apply () # New windows take focus-precedence over already # existing ones, even if they are modal. self . focus ( window ) if not animate : return self if window . height > 1 : animator . animate_attr ( target = window , attr = \"height\" , start = 0 , end = window . height , duration = 300 , on_step = _center_during_animation , ) return self alert ( items , center = True , attributes ) Creates a modal popup of the given elements and attributes. Parameters: Name Type Description Default *items Any All widget-convertable objects passed as children of the new window. () center bool If set, pytermgui.window_manager.window.center is called on the window. True **attributes Any kwargs passed as the new window's attributes. {} Source code in pytermgui/window_manager/manager.py 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 def alert ( self , * items : Any , center : bool = True , ** attributes : Any ) -> Window : \"\"\"Creates a modal popup of the given elements and attributes. Args: *items: All widget-convertable objects passed as children of the new window. center: If set, `pytermgui.window_manager.window.center` is called on the window. **attributes: kwargs passed as the new window's attributes. \"\"\" window = Window ( * items , is_modal = True , ** attributes ) if center : window . center () self . add ( window , assign = False ) return window clear_cache ( window ) Clears the compositor's cache related to the given window. Source code in pytermgui/window_manager/manager.py 150 151 152 153 def clear_cache ( self , window : Window ) -> None : \"\"\"Clears the compositor's cache related to the given window.\"\"\" self . compositor . clear_cache ( window ) focus ( window ) Focuses a window by moving it to the first index in _windows. Source code in pytermgui/window_manager/manager.py 287 288 289 290 291 292 293 294 295 296 297 298 299 def focus ( self , window : Window | None ) -> None : \"\"\"Focuses a window by moving it to the first index in _windows.\"\"\" if self . focused is not None : self . focused . blur () self . focused = window if window is not None : self . _windows . remove ( window ) self . _windows . insert ( 0 , window ) window . focus () focus_next () Focuses the next window in focus order, looping to first at the end. Source code in pytermgui/window_manager/manager.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def focus_next ( self ) -> Window | None : \"\"\"Focuses the next window in focus order, looping to first at the end.\"\"\" if self . focused is None : self . focus ( self . _windows [ 0 ]) return self . focused index = self . _windows . index ( self . focused ) if index == len ( self . _windows ) - 1 : index = 0 window = self . _windows [ index ] traversed = 0 while window . is_persistent or window is self . focused : if index >= len ( self . _windows ): index = 0 window = self . _windows [ index ] index += 1 traversed += 1 if traversed >= len ( self . _windows ): return self . focused self . focus ( self . _windows [ index ]) return self . focused get_lines () Gets the empty list. Source code in pytermgui/window_manager/manager.py 143 144 145 146 147 148 def get_lines ( self ) -> list [ str ]: \"\"\"Gets the empty list.\"\"\" # TODO: Allow using WindowManager as a widget. return [] handle_key ( key ) Processes a keypress. Parameters: Name Type Description Default key str The key to handle. required Returns: Type Description bool True if the given key could be processed, False otherwise. Source code in pytermgui/window_manager/manager.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 def handle_key ( self , key : str ) -> bool : \"\"\"Processes a keypress. Args: key: The key to handle. Returns: True if the given key could be processed, False otherwise. \"\"\" # Apply WindowManager bindings if self . execute_binding ( key ): return True # Apply focused window binding, or send to InputField if self . focused is not None : if self . focused . execute_binding ( key ): return True if self . focused . handle_key ( key ): return True return False on_resize ( size ) Correctly updates window positions & prints when terminal gets resized. Parameters: Name Type Description Default size tuple [ int , int ] The new terminal size. required Source code in pytermgui/window_manager/manager.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def on_resize ( self , size : tuple [ int , int ]) -> None : \"\"\"Correctly updates window positions & prints when terminal gets resized. Args: size: The new terminal size. \"\"\" width , height = size for window in self . _windows : newx = max ( 0 , min ( window . pos [ 0 ], width - window . width )) newy = max ( 0 , min ( window . pos [ 1 ], height - window . height + 1 )) window . pos = ( newx , newy ) self . layout . apply () self . compositor . redraw () process_mouse ( key ) Processes (potential) mouse input. Parameters: Name Type Description Default key str Input to handle. required Source code in pytermgui/window_manager/manager.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 def process_mouse ( self , key : str ) -> None : # pylint: disable=too-many-statements \"\"\"Processes (potential) mouse input. Args: key: Input to handle. \"\"\" window : Window def _clamp_pos ( pos : tuple [ int , int ], index : int ) -> int : \"\"\"Clamp a value using index to address x/y & width/height\"\"\" offset = self . _drag_offsets [ index ] # TODO: This -2 is a very magical number. Not good. maximum = terminal . size [ index ] - (( window . width , window . height )[ index ] - 2 ) start_margin_index = abs ( index - 1 ) if self . restrict_within_bounds : return max ( index + terminal . margins [ start_margin_index ], min ( pos [ index ] - offset , maximum - terminal . margins [ start_margin_index + 2 ] - terminal . origin [ index ], ), ) return pos [ index ] - offset def _click ( pos : tuple [ int , int ], window : Window ) -> bool : \"\"\"Process clicking a window.\"\"\" left , top , right , bottom = window . rect borders = window . chars . get ( \"border\" , [ \" \" ] * 4 ) if real_length ( borders [ 1 ]) > 0 and pos [ 1 ] == top and left <= pos [ 0 ] < right : self . _drag_target = ( window , Edge . TOP ) elif ( real_length ( borders [ 3 ]) > 0 and pos [ 1 ] == bottom - 1 and left <= pos [ 0 ] < right ): self . _drag_target = ( window , Edge . BOTTOM ) elif ( real_length ( borders [ 0 ]) > 0 and pos [ 0 ] == left and top <= pos [ 1 ] < bottom ): self . _drag_target = ( window , Edge . LEFT ) elif ( real_length ( borders [ 2 ]) > 0 and pos [ 0 ] == right - 1 and top <= pos [ 1 ] < bottom ): self . _drag_target = ( window , Edge . RIGHT ) else : return False self . _drag_offsets = ( pos [ 0 ] - window . pos [ 0 ], pos [ 1 ] - window . pos [ 1 ], ) return True def _drag ( pos : tuple [ int , int ], window : Window ) -> bool : \"\"\"Process dragging a window\"\"\" if self . _drag_target is None : return False target_window , edge = self . _drag_target handled = False if window is not target_window : return False left , top , right , bottom = window . rect if not window . is_static and edge is Edge . TOP : window . pos = ( _clamp_pos ( pos , 0 ), _clamp_pos ( pos , 1 ), ) handled = True # TODO: Why are all these arbitrary offsets needed? elif not window . is_noresize : if edge is Edge . RIGHT : window . rect = ( left , top , pos [ 0 ] + 1 , bottom ) handled = True elif edge is Edge . LEFT : window . rect = ( pos [ 0 ], top , right , bottom ) handled = True elif edge is Edge . BOTTOM : window . rect = ( left , top , right , pos [ 1 ] + 1 ) handled = True if handled : window . is_dirty = True self . compositor . set_redraw () return handled def _release ( _ : tuple [ int , int ], __ : Window ) -> bool : \"\"\"Process release of key\"\"\" self . _drag_target = None # This return False so Window can handle the mouse action as well, # as not much is done in this callback. return False handlers = { MouseAction . LEFT_CLICK : _click , MouseAction . LEFT_DRAG : _drag , MouseAction . RELEASE : _release , } translate = self . mouse_translator event_list = None if translate is None else translate ( key ) if event_list is None : return for event in event_list : # Ignore null-events if event is None : continue for window in self . _windows : contains = window . contains ( event . position ) if event . action in self . focusing_actions : self . focus ( window ) if event . action in handlers and handlers [ event . action ]( event . position , window ): break if contains : if self . _mouse_target is not None : self . _mouse_target . handle_mouse ( MouseEvent ( MouseAction . RELEASE , event . position ) ) self . _mouse_target = window window . handle_mouse ( event ) break if window . is_modal : break # Unset drag_target if no windows received the input else : self . _drag_target = None if self . _mouse_target is not None : self . _mouse_target . handle_mouse ( MouseEvent ( MouseAction . RELEASE , event . position ) ) self . _mouse_target = None remove ( window , autostop = True , animate = True ) Removes a window from the manager. Parameters: Name Type Description Default window Window The window to remove. required autostop bool If set, the manager will be stopped if the length of its windows hits 0. True Source code in pytermgui/window_manager/manager.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 def remove ( self , window : Window , autostop : bool = True , animate : bool = True , ) -> WindowManager : \"\"\"Removes a window from the manager. Args: window: The window to remove. autostop: If set, the manager will be stopped if the length of its windows hits 0. \"\"\" def _on_finish ( _ : AttrAnimation | None ) -> bool : self . _windows . remove ( window ) if autostop and len ( self . _windows ) == 0 : self . stop () else : self . focus ( self . _windows [ 0 ]) return True if not animate : _on_finish ( None ) return self animator . animate_attr ( target = window , attr = \"height\" , end = 0 , duration = 300 , on_step = _center_during_animation , on_finish = _on_finish , ) return self run ( mouse_events = None ) Starts the WindowManager. Parameters: Name Type Description Default mouse_events list [ str ] | None A list of mouse event types to listen to. See pytermgui.ansi_interface.report_mouse for more information. Defaults to [\"press_hold\", \"hover\"] . None Returns: Type Description None The WindowManager's compositor instance. Source code in pytermgui/window_manager/manager.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 def run ( self , mouse_events : list [ str ] | None = None ) -> None : \"\"\"Starts the WindowManager. Args: mouse_events: A list of mouse event types to listen to. See `pytermgui.ansi_interface.report_mouse` for more information. Defaults to `[\"press_hold\", \"hover\"]`. Returns: The WindowManager's compositor instance. \"\"\" self . _is_running = True if mouse_events is None : mouse_events = [ \"press_hold\" , \"hover\" ] with alt_buffer ( cursor = False , echo = False ): with mouse_handler ( mouse_events , \"decimal_xterm\" ) as translate : self . mouse_translator = translate self . compositor . run () self . _run_input_loop () screenshot ( title , filename = 'screenshot.svg' ) Takes a screenshot of the current state. See pytermgui.exporters.to_svg for more information. Parameters: Name Type Description Default filename str The name of the file. 'screenshot.svg' Source code in pytermgui/window_manager/manager.py 529 530 531 532 533 534 535 536 537 538 def screenshot ( self , title : str , filename : str = \"screenshot.svg\" ) -> None : \"\"\"Takes a screenshot of the current state. See `pytermgui.exporters.to_svg` for more information. Args: filename: The name of the file. \"\"\" self . compositor . capture ( title = title , filename = filename ) show_positions () Shows the positions of each Window's widgets. Source code in pytermgui/window_manager/manager.py 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 def show_positions ( self ) -> None : \"\"\"Shows the positions of each Window's widgets.\"\"\" def _show_positions ( widget , color_base : int = 60 ) -> None : \"\"\"Show positions of widget.\"\"\" if isinstance ( widget , Container ): for i , subwidget in enumerate ( widget ): _show_positions ( subwidget , color_base + i ) return if not widget . is_selectable : return debug = widget . debug () color = str_to_color ( f \"@ { color_base } \" ) buff = color ( \" \" , reset = False ) for i in range ( min ( widget . width , real_length ( debug )) - 1 ): buff += debug [ i ] self . terminal . write ( buff , pos = widget . pos ) for widget in self . _windows : _show_positions ( widget ) self . terminal . flush () getch () stop () Stops the WindowManager and its compositor. Source code in pytermgui/window_manager/manager.py 197 198 199 200 201 def stop ( self ) -> None : \"\"\"Stops the WindowManager and its compositor.\"\"\" self . compositor . stop () self . _is_running = False toast ( items , offset = 0 , duration = 300 , delay = 1000 , attributes ) Creates a Material UI-inspired toast window of the given elements and attributes. Parameters: Name Type Description Default *items Any All widget-convertable objects passed as children of the new window. () delay int The amount of time before the window will start animating out. 1000 **attributes Any kwargs passed as the new window's attributes. {} Source code in pytermgui/window_manager/manager.py 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 def toast ( self , * items : Any , offset : int = 0 , duration : int = 300 , delay : int = 1000 , ** attributes : Any , ) -> Window : \"\"\"Creates a Material UI-inspired toast window of the given elements and attributes. Args: *items: All widget-convertable objects passed as children of the new window. delay: The amount of time before the window will start animating out. **attributes: kwargs passed as the new window's attributes. \"\"\" # pylint: disable=no-value-for-parameter toast = Window ( * items , is_noblur = True , ** attributes ) target_height = toast . height toast . overflow = Overflow . HIDE def _finish ( _ : Animation ) -> None : self . remove ( toast , animate = False ) def _progressively_show ( anim : Animation , invert : bool = False ) -> bool : height = int ( anim . state * target_height ) toast . center () if invert : toast . height = target_height - 1 - height toast . pos = ( toast . pos [ 0 ], self . terminal . height - toast . height + 1 - offset , ) return False toast . height = height toast . pos = ( toast . pos [ 0 ], self . terminal . height - toast . height + 1 - offset ) return False def _animate_toast_out ( _ : Animation ) -> None : animator . schedule ( FloatAnimation ( delay , on_finish = lambda * _ : animator . schedule ( FloatAnimation ( duration , on_step = lambda anim : _progressively_show ( anim , invert = True ), on_finish = _finish , ) ), ) ) leadup = FloatAnimation ( duration , on_step = _progressively_show , on_finish = _animate_toast_out ) # pylint: enable=no-value-for-parameter self . add ( toast . center (), animate = False , assign = False ) self . focus ( toast ) animator . schedule ( leadup ) return toast","title":"manager"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.Edge","text":"Bases: Enum Enum for window edges. Source code in pytermgui/window_manager/manager.py 35 36 37 38 39 40 41 class Edge ( Enum ): \"\"\"Enum for window edges.\"\"\" LEFT = _auto () TOP = _auto () RIGHT = _auto () BOTTOM = _auto ()","title":"Edge"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager","text":"Bases: Widget The manager of windows. This class can be used, or even subclassed in order to create full-screen applications, using the pytermgui.window_manager.window.Window class and the general Widget API. Source code in pytermgui/window_manager/manager.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 class WindowManager ( Widget ): # pylint: disable=too-many-instance-attributes \"\"\"The manager of windows. This class can be used, or even subclassed in order to create full-screen applications, using the `pytermgui.window_manager.window.Window` class and the general Widget API. \"\"\" focusing_actions = ( MouseAction . LEFT_CLICK , MouseAction . RIGHT_CLICK ) \"\"\"These mouse actions will focus the window they are acted upon.\"\"\" autorun = True def __init__ ( self , * , layout_type : Type [ Layout ] = Layout , framerate : int = 60 , autorun : bool | None = None , ) -> None : \"\"\"Initialize the manager.\"\"\" super () . __init__ () self . _is_running = False self . _windows : list [ Window ] = [] self . _bindings : dict [ str | Type [ MouseEvent ], tuple [ BoundCallback , str ]] = {} self . focused : Window | None = None if autorun is not None : self . autorun = autorun self . layout = layout_type () self . compositor = Compositor ( self . _windows , framerate = framerate ) self . mouse_translator : MouseTranslator | None = None self . _mouse_target : Window | None = None self . _drag_offsets : tuple [ int , int ] = ( 0 , 0 ) self . _drag_target : tuple [ Window , Edge ] | None = None # This isn't quite implemented at the moment. self . restrict_within_bounds = True terminal . subscribe ( terminal . RESIZE , self . on_resize ) def __iadd__ ( self , other : object ) -> WindowManager : \"\"\"Adds a window to the manager.\"\"\" if not isinstance ( other , Window ): raise ValueError ( \"You may only add windows to a WindowManager.\" ) return self . add ( other ) def __isub__ ( self , other : object ) -> WindowManager : \"\"\"Removes a window from the manager.\"\"\" if not isinstance ( other , Window ): raise ValueError ( \"You may only add windows to a WindowManager.\" ) return self . remove ( other ) def __enter__ ( self ) -> WindowManager : \"\"\"Starts context manager.\"\"\" return self def __exit__ ( self , _ : Any , exception : Exception , __ : Any ) -> bool : \"\"\"Ends context manager.\"\"\" # Run the manager if it hasnt been run before. if self . autorun and exception is None and self . mouse_translator is None : self . run () if exception is not None : self . stop () raise exception return True def __iter__ ( self ) -> Iterator [ Window ]: \"\"\"Iterates this manager's windows.\"\"\" return iter ( self . _windows ) def _run_input_loop ( self ) -> None : \"\"\"The main input loop of the WindowManager.\"\"\" while self . _is_running : key = getch ( interrupts = False ) if key == chr ( 3 ): self . stop () break if self . handle_key ( key ): continue self . process_mouse ( key ) def get_lines ( self ) -> list [ str ]: \"\"\"Gets the empty list.\"\"\" # TODO: Allow using WindowManager as a widget. return [] def clear_cache ( self , window : Window ) -> None : \"\"\"Clears the compositor's cache related to the given window.\"\"\" self . compositor . clear_cache ( window ) def on_resize ( self , size : tuple [ int , int ]) -> None : \"\"\"Correctly updates window positions & prints when terminal gets resized. Args: size: The new terminal size. \"\"\" width , height = size for window in self . _windows : newx = max ( 0 , min ( window . pos [ 0 ], width - window . width )) newy = max ( 0 , min ( window . pos [ 1 ], height - window . height + 1 )) window . pos = ( newx , newy ) self . layout . apply () self . compositor . redraw () def run ( self , mouse_events : list [ str ] | None = None ) -> None : \"\"\"Starts the WindowManager. Args: mouse_events: A list of mouse event types to listen to. See `pytermgui.ansi_interface.report_mouse` for more information. Defaults to `[\"press_hold\", \"hover\"]`. Returns: The WindowManager's compositor instance. \"\"\" self . _is_running = True if mouse_events is None : mouse_events = [ \"press_hold\" , \"hover\" ] with alt_buffer ( cursor = False , echo = False ): with mouse_handler ( mouse_events , \"decimal_xterm\" ) as translate : self . mouse_translator = translate self . compositor . run () self . _run_input_loop () def stop ( self ) -> None : \"\"\"Stops the WindowManager and its compositor.\"\"\" self . compositor . stop () self . _is_running = False def add ( self , window : Window , assign : str | bool = True , animate : bool = True ) -> WindowManager : \"\"\"Adds a window to the manager. Args: window: The window to add. assign: The name of the slot the new window should be assigned to, or a boolean. If it is given a str, it is treated as the name of a slot. When given True, the next non-filled slot will be assigned, and when given False no assignment will be done. animate: If set, an animation will be played on the window once it's added. \"\"\" self . _windows . insert ( 0 , window ) window . manager = self if assign : if isinstance ( assign , str ): getattr ( self . layout , assign ) . content = window elif len ( self . _windows ) <= len ( self . layout . slots ): self . layout . assign ( window , index = len ( self . _windows ) - 1 ) self . layout . apply () # New windows take focus-precedence over already # existing ones, even if they are modal. self . focus ( window ) if not animate : return self if window . height > 1 : animator . animate_attr ( target = window , attr = \"height\" , start = 0 , end = window . height , duration = 300 , on_step = _center_during_animation , ) return self def remove ( self , window : Window , autostop : bool = True , animate : bool = True , ) -> WindowManager : \"\"\"Removes a window from the manager. Args: window: The window to remove. autostop: If set, the manager will be stopped if the length of its windows hits 0. \"\"\" def _on_finish ( _ : AttrAnimation | None ) -> bool : self . _windows . remove ( window ) if autostop and len ( self . _windows ) == 0 : self . stop () else : self . focus ( self . _windows [ 0 ]) return True if not animate : _on_finish ( None ) return self animator . animate_attr ( target = window , attr = \"height\" , end = 0 , duration = 300 , on_step = _center_during_animation , on_finish = _on_finish , ) return self def focus ( self , window : Window | None ) -> None : \"\"\"Focuses a window by moving it to the first index in _windows.\"\"\" if self . focused is not None : self . focused . blur () self . focused = window if window is not None : self . _windows . remove ( window ) self . _windows . insert ( 0 , window ) window . focus () def focus_next ( self ) -> Window | None : \"\"\"Focuses the next window in focus order, looping to first at the end.\"\"\" if self . focused is None : self . focus ( self . _windows [ 0 ]) return self . focused index = self . _windows . index ( self . focused ) if index == len ( self . _windows ) - 1 : index = 0 window = self . _windows [ index ] traversed = 0 while window . is_persistent or window is self . focused : if index >= len ( self . _windows ): index = 0 window = self . _windows [ index ] index += 1 traversed += 1 if traversed >= len ( self . _windows ): return self . focused self . focus ( self . _windows [ index ]) return self . focused def handle_key ( self , key : str ) -> bool : \"\"\"Processes a keypress. Args: key: The key to handle. Returns: True if the given key could be processed, False otherwise. \"\"\" # Apply WindowManager bindings if self . execute_binding ( key ): return True # Apply focused window binding, or send to InputField if self . focused is not None : if self . focused . execute_binding ( key ): return True if self . focused . handle_key ( key ): return True return False # I prefer having the _click, _drag and _release helpers within this function, for # easier readability. def process_mouse ( self , key : str ) -> None : # pylint: disable=too-many-statements \"\"\"Processes (potential) mouse input. Args: key: Input to handle. \"\"\" window : Window def _clamp_pos ( pos : tuple [ int , int ], index : int ) -> int : \"\"\"Clamp a value using index to address x/y & width/height\"\"\" offset = self . _drag_offsets [ index ] # TODO: This -2 is a very magical number. Not good. maximum = terminal . size [ index ] - (( window . width , window . height )[ index ] - 2 ) start_margin_index = abs ( index - 1 ) if self . restrict_within_bounds : return max ( index + terminal . margins [ start_margin_index ], min ( pos [ index ] - offset , maximum - terminal . margins [ start_margin_index + 2 ] - terminal . origin [ index ], ), ) return pos [ index ] - offset def _click ( pos : tuple [ int , int ], window : Window ) -> bool : \"\"\"Process clicking a window.\"\"\" left , top , right , bottom = window . rect borders = window . chars . get ( \"border\" , [ \" \" ] * 4 ) if real_length ( borders [ 1 ]) > 0 and pos [ 1 ] == top and left <= pos [ 0 ] < right : self . _drag_target = ( window , Edge . TOP ) elif ( real_length ( borders [ 3 ]) > 0 and pos [ 1 ] == bottom - 1 and left <= pos [ 0 ] < right ): self . _drag_target = ( window , Edge . BOTTOM ) elif ( real_length ( borders [ 0 ]) > 0 and pos [ 0 ] == left and top <= pos [ 1 ] < bottom ): self . _drag_target = ( window , Edge . LEFT ) elif ( real_length ( borders [ 2 ]) > 0 and pos [ 0 ] == right - 1 and top <= pos [ 1 ] < bottom ): self . _drag_target = ( window , Edge . RIGHT ) else : return False self . _drag_offsets = ( pos [ 0 ] - window . pos [ 0 ], pos [ 1 ] - window . pos [ 1 ], ) return True def _drag ( pos : tuple [ int , int ], window : Window ) -> bool : \"\"\"Process dragging a window\"\"\" if self . _drag_target is None : return False target_window , edge = self . _drag_target handled = False if window is not target_window : return False left , top , right , bottom = window . rect if not window . is_static and edge is Edge . TOP : window . pos = ( _clamp_pos ( pos , 0 ), _clamp_pos ( pos , 1 ), ) handled = True # TODO: Why are all these arbitrary offsets needed? elif not window . is_noresize : if edge is Edge . RIGHT : window . rect = ( left , top , pos [ 0 ] + 1 , bottom ) handled = True elif edge is Edge . LEFT : window . rect = ( pos [ 0 ], top , right , bottom ) handled = True elif edge is Edge . BOTTOM : window . rect = ( left , top , right , pos [ 1 ] + 1 ) handled = True if handled : window . is_dirty = True self . compositor . set_redraw () return handled def _release ( _ : tuple [ int , int ], __ : Window ) -> bool : \"\"\"Process release of key\"\"\" self . _drag_target = None # This return False so Window can handle the mouse action as well, # as not much is done in this callback. return False handlers = { MouseAction . LEFT_CLICK : _click , MouseAction . LEFT_DRAG : _drag , MouseAction . RELEASE : _release , } translate = self . mouse_translator event_list = None if translate is None else translate ( key ) if event_list is None : return for event in event_list : # Ignore null-events if event is None : continue for window in self . _windows : contains = window . contains ( event . position ) if event . action in self . focusing_actions : self . focus ( window ) if event . action in handlers and handlers [ event . action ]( event . position , window ): break if contains : if self . _mouse_target is not None : self . _mouse_target . handle_mouse ( MouseEvent ( MouseAction . RELEASE , event . position ) ) self . _mouse_target = window window . handle_mouse ( event ) break if window . is_modal : break # Unset drag_target if no windows received the input else : self . _drag_target = None if self . _mouse_target is not None : self . _mouse_target . handle_mouse ( MouseEvent ( MouseAction . RELEASE , event . position ) ) self . _mouse_target = None def screenshot ( self , title : str , filename : str = \"screenshot.svg\" ) -> None : \"\"\"Takes a screenshot of the current state. See `pytermgui.exporters.to_svg` for more information. Args: filename: The name of the file. \"\"\" self . compositor . capture ( title = title , filename = filename ) def show_positions ( self ) -> None : \"\"\"Shows the positions of each Window's widgets.\"\"\" def _show_positions ( widget , color_base : int = 60 ) -> None : \"\"\"Show positions of widget.\"\"\" if isinstance ( widget , Container ): for i , subwidget in enumerate ( widget ): _show_positions ( subwidget , color_base + i ) return if not widget . is_selectable : return debug = widget . debug () color = str_to_color ( f \"@ { color_base } \" ) buff = color ( \" \" , reset = False ) for i in range ( min ( widget . width , real_length ( debug )) - 1 ): buff += debug [ i ] self . terminal . write ( buff , pos = widget . pos ) for widget in self . _windows : _show_positions ( widget ) self . terminal . flush () getch () def alert ( self , * items : Any , center : bool = True , ** attributes : Any ) -> Window : \"\"\"Creates a modal popup of the given elements and attributes. Args: *items: All widget-convertable objects passed as children of the new window. center: If set, `pytermgui.window_manager.window.center` is called on the window. **attributes: kwargs passed as the new window's attributes. \"\"\" window = Window ( * items , is_modal = True , ** attributes ) if center : window . center () self . add ( window , assign = False ) return window def toast ( self , * items : Any , offset : int = 0 , duration : int = 300 , delay : int = 1000 , ** attributes : Any , ) -> Window : \"\"\"Creates a Material UI-inspired toast window of the given elements and attributes. Args: *items: All widget-convertable objects passed as children of the new window. delay: The amount of time before the window will start animating out. **attributes: kwargs passed as the new window's attributes. \"\"\" # pylint: disable=no-value-for-parameter toast = Window ( * items , is_noblur = True , ** attributes ) target_height = toast . height toast . overflow = Overflow . HIDE def _finish ( _ : Animation ) -> None : self . remove ( toast , animate = False ) def _progressively_show ( anim : Animation , invert : bool = False ) -> bool : height = int ( anim . state * target_height ) toast . center () if invert : toast . height = target_height - 1 - height toast . pos = ( toast . pos [ 0 ], self . terminal . height - toast . height + 1 - offset , ) return False toast . height = height toast . pos = ( toast . pos [ 0 ], self . terminal . height - toast . height + 1 - offset ) return False def _animate_toast_out ( _ : Animation ) -> None : animator . schedule ( FloatAnimation ( delay , on_finish = lambda * _ : animator . schedule ( FloatAnimation ( duration , on_step = lambda anim : _progressively_show ( anim , invert = True ), on_finish = _finish , ) ), ) ) leadup = FloatAnimation ( duration , on_step = _progressively_show , on_finish = _animate_toast_out ) # pylint: enable=no-value-for-parameter self . add ( toast . center (), animate = False , assign = False ) self . focus ( toast ) animator . schedule ( leadup ) return toast","title":"WindowManager"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.focusing_actions","text":"These mouse actions will focus the window they are acted upon.","title":"focusing_actions"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.__enter__","text":"Starts context manager. Source code in pytermgui/window_manager/manager.py 105 106 107 108 def __enter__ ( self ) -> WindowManager : \"\"\"Starts context manager.\"\"\" return self","title":"__enter__()"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.__exit__","text":"Ends context manager. Source code in pytermgui/window_manager/manager.py 110 111 112 113 114 115 116 117 118 119 120 121 def __exit__ ( self , _ : Any , exception : Exception , __ : Any ) -> bool : \"\"\"Ends context manager.\"\"\" # Run the manager if it hasnt been run before. if self . autorun and exception is None and self . mouse_translator is None : self . run () if exception is not None : self . stop () raise exception return True","title":"__exit__()"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.__iadd__","text":"Adds a window to the manager. Source code in pytermgui/window_manager/manager.py 89 90 91 92 93 94 95 def __iadd__ ( self , other : object ) -> WindowManager : \"\"\"Adds a window to the manager.\"\"\" if not isinstance ( other , Window ): raise ValueError ( \"You may only add windows to a WindowManager.\" ) return self . add ( other )","title":"__iadd__()"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.__init__","text":"Initialize the manager. Source code in pytermgui/window_manager/manager.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def __init__ ( self , * , layout_type : Type [ Layout ] = Layout , framerate : int = 60 , autorun : bool | None = None , ) -> None : \"\"\"Initialize the manager.\"\"\" super () . __init__ () self . _is_running = False self . _windows : list [ Window ] = [] self . _bindings : dict [ str | Type [ MouseEvent ], tuple [ BoundCallback , str ]] = {} self . focused : Window | None = None if autorun is not None : self . autorun = autorun self . layout = layout_type () self . compositor = Compositor ( self . _windows , framerate = framerate ) self . mouse_translator : MouseTranslator | None = None self . _mouse_target : Window | None = None self . _drag_offsets : tuple [ int , int ] = ( 0 , 0 ) self . _drag_target : tuple [ Window , Edge ] | None = None # This isn't quite implemented at the moment. self . restrict_within_bounds = True terminal . subscribe ( terminal . RESIZE , self . on_resize )","title":"__init__()"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.__isub__","text":"Removes a window from the manager. Source code in pytermgui/window_manager/manager.py 97 98 99 100 101 102 103 def __isub__ ( self , other : object ) -> WindowManager : \"\"\"Removes a window from the manager.\"\"\" if not isinstance ( other , Window ): raise ValueError ( \"You may only add windows to a WindowManager.\" ) return self . remove ( other )","title":"__isub__()"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.__iter__","text":"Iterates this manager's windows. Source code in pytermgui/window_manager/manager.py 123 124 125 126 def __iter__ ( self ) -> Iterator [ Window ]: \"\"\"Iterates this manager's windows.\"\"\" return iter ( self . _windows )","title":"__iter__()"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.add","text":"Adds a window to the manager. Parameters: Name Type Description Default window Window The window to add. required assign str | bool The name of the slot the new window should be assigned to, or a boolean. If it is given a str, it is treated as the name of a slot. When given True, the next non-filled slot will be assigned, and when given False no assignment will be done. True animate bool If set, an animation will be played on the window once it's added. True Source code in pytermgui/window_manager/manager.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def add ( self , window : Window , assign : str | bool = True , animate : bool = True ) -> WindowManager : \"\"\"Adds a window to the manager. Args: window: The window to add. assign: The name of the slot the new window should be assigned to, or a boolean. If it is given a str, it is treated as the name of a slot. When given True, the next non-filled slot will be assigned, and when given False no assignment will be done. animate: If set, an animation will be played on the window once it's added. \"\"\" self . _windows . insert ( 0 , window ) window . manager = self if assign : if isinstance ( assign , str ): getattr ( self . layout , assign ) . content = window elif len ( self . _windows ) <= len ( self . layout . slots ): self . layout . assign ( window , index = len ( self . _windows ) - 1 ) self . layout . apply () # New windows take focus-precedence over already # existing ones, even if they are modal. self . focus ( window ) if not animate : return self if window . height > 1 : animator . animate_attr ( target = window , attr = \"height\" , start = 0 , end = window . height , duration = 300 , on_step = _center_during_animation , ) return self","title":"add()"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.alert","text":"Creates a modal popup of the given elements and attributes. Parameters: Name Type Description Default *items Any All widget-convertable objects passed as children of the new window. () center bool If set, pytermgui.window_manager.window.center is called on the window. True **attributes Any kwargs passed as the new window's attributes. {} Source code in pytermgui/window_manager/manager.py 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 def alert ( self , * items : Any , center : bool = True , ** attributes : Any ) -> Window : \"\"\"Creates a modal popup of the given elements and attributes. Args: *items: All widget-convertable objects passed as children of the new window. center: If set, `pytermgui.window_manager.window.center` is called on the window. **attributes: kwargs passed as the new window's attributes. \"\"\" window = Window ( * items , is_modal = True , ** attributes ) if center : window . center () self . add ( window , assign = False ) return window","title":"alert()"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.clear_cache","text":"Clears the compositor's cache related to the given window. Source code in pytermgui/window_manager/manager.py 150 151 152 153 def clear_cache ( self , window : Window ) -> None : \"\"\"Clears the compositor's cache related to the given window.\"\"\" self . compositor . clear_cache ( window )","title":"clear_cache()"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.focus","text":"Focuses a window by moving it to the first index in _windows. Source code in pytermgui/window_manager/manager.py 287 288 289 290 291 292 293 294 295 296 297 298 299 def focus ( self , window : Window | None ) -> None : \"\"\"Focuses a window by moving it to the first index in _windows.\"\"\" if self . focused is not None : self . focused . blur () self . focused = window if window is not None : self . _windows . remove ( window ) self . _windows . insert ( 0 , window ) window . focus ()","title":"focus()"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.focus_next","text":"Focuses the next window in focus order, looping to first at the end. Source code in pytermgui/window_manager/manager.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def focus_next ( self ) -> Window | None : \"\"\"Focuses the next window in focus order, looping to first at the end.\"\"\" if self . focused is None : self . focus ( self . _windows [ 0 ]) return self . focused index = self . _windows . index ( self . focused ) if index == len ( self . _windows ) - 1 : index = 0 window = self . _windows [ index ] traversed = 0 while window . is_persistent or window is self . focused : if index >= len ( self . _windows ): index = 0 window = self . _windows [ index ] index += 1 traversed += 1 if traversed >= len ( self . _windows ): return self . focused self . focus ( self . _windows [ index ]) return self . focused","title":"focus_next()"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.get_lines","text":"Gets the empty list. Source code in pytermgui/window_manager/manager.py 143 144 145 146 147 148 def get_lines ( self ) -> list [ str ]: \"\"\"Gets the empty list.\"\"\" # TODO: Allow using WindowManager as a widget. return []","title":"get_lines()"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.handle_key","text":"Processes a keypress. Parameters: Name Type Description Default key str The key to handle. required Returns: Type Description bool True if the given key could be processed, False otherwise. Source code in pytermgui/window_manager/manager.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 def handle_key ( self , key : str ) -> bool : \"\"\"Processes a keypress. Args: key: The key to handle. Returns: True if the given key could be processed, False otherwise. \"\"\" # Apply WindowManager bindings if self . execute_binding ( key ): return True # Apply focused window binding, or send to InputField if self . focused is not None : if self . focused . execute_binding ( key ): return True if self . focused . handle_key ( key ): return True return False","title":"handle_key()"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.on_resize","text":"Correctly updates window positions & prints when terminal gets resized. Parameters: Name Type Description Default size tuple [ int , int ] The new terminal size. required Source code in pytermgui/window_manager/manager.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def on_resize ( self , size : tuple [ int , int ]) -> None : \"\"\"Correctly updates window positions & prints when terminal gets resized. Args: size: The new terminal size. \"\"\" width , height = size for window in self . _windows : newx = max ( 0 , min ( window . pos [ 0 ], width - window . width )) newy = max ( 0 , min ( window . pos [ 1 ], height - window . height + 1 )) window . pos = ( newx , newy ) self . layout . apply () self . compositor . redraw ()","title":"on_resize()"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.process_mouse","text":"Processes (potential) mouse input. Parameters: Name Type Description Default key str Input to handle. required Source code in pytermgui/window_manager/manager.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 def process_mouse ( self , key : str ) -> None : # pylint: disable=too-many-statements \"\"\"Processes (potential) mouse input. Args: key: Input to handle. \"\"\" window : Window def _clamp_pos ( pos : tuple [ int , int ], index : int ) -> int : \"\"\"Clamp a value using index to address x/y & width/height\"\"\" offset = self . _drag_offsets [ index ] # TODO: This -2 is a very magical number. Not good. maximum = terminal . size [ index ] - (( window . width , window . height )[ index ] - 2 ) start_margin_index = abs ( index - 1 ) if self . restrict_within_bounds : return max ( index + terminal . margins [ start_margin_index ], min ( pos [ index ] - offset , maximum - terminal . margins [ start_margin_index + 2 ] - terminal . origin [ index ], ), ) return pos [ index ] - offset def _click ( pos : tuple [ int , int ], window : Window ) -> bool : \"\"\"Process clicking a window.\"\"\" left , top , right , bottom = window . rect borders = window . chars . get ( \"border\" , [ \" \" ] * 4 ) if real_length ( borders [ 1 ]) > 0 and pos [ 1 ] == top and left <= pos [ 0 ] < right : self . _drag_target = ( window , Edge . TOP ) elif ( real_length ( borders [ 3 ]) > 0 and pos [ 1 ] == bottom - 1 and left <= pos [ 0 ] < right ): self . _drag_target = ( window , Edge . BOTTOM ) elif ( real_length ( borders [ 0 ]) > 0 and pos [ 0 ] == left and top <= pos [ 1 ] < bottom ): self . _drag_target = ( window , Edge . LEFT ) elif ( real_length ( borders [ 2 ]) > 0 and pos [ 0 ] == right - 1 and top <= pos [ 1 ] < bottom ): self . _drag_target = ( window , Edge . RIGHT ) else : return False self . _drag_offsets = ( pos [ 0 ] - window . pos [ 0 ], pos [ 1 ] - window . pos [ 1 ], ) return True def _drag ( pos : tuple [ int , int ], window : Window ) -> bool : \"\"\"Process dragging a window\"\"\" if self . _drag_target is None : return False target_window , edge = self . _drag_target handled = False if window is not target_window : return False left , top , right , bottom = window . rect if not window . is_static and edge is Edge . TOP : window . pos = ( _clamp_pos ( pos , 0 ), _clamp_pos ( pos , 1 ), ) handled = True # TODO: Why are all these arbitrary offsets needed? elif not window . is_noresize : if edge is Edge . RIGHT : window . rect = ( left , top , pos [ 0 ] + 1 , bottom ) handled = True elif edge is Edge . LEFT : window . rect = ( pos [ 0 ], top , right , bottom ) handled = True elif edge is Edge . BOTTOM : window . rect = ( left , top , right , pos [ 1 ] + 1 ) handled = True if handled : window . is_dirty = True self . compositor . set_redraw () return handled def _release ( _ : tuple [ int , int ], __ : Window ) -> bool : \"\"\"Process release of key\"\"\" self . _drag_target = None # This return False so Window can handle the mouse action as well, # as not much is done in this callback. return False handlers = { MouseAction . LEFT_CLICK : _click , MouseAction . LEFT_DRAG : _drag , MouseAction . RELEASE : _release , } translate = self . mouse_translator event_list = None if translate is None else translate ( key ) if event_list is None : return for event in event_list : # Ignore null-events if event is None : continue for window in self . _windows : contains = window . contains ( event . position ) if event . action in self . focusing_actions : self . focus ( window ) if event . action in handlers and handlers [ event . action ]( event . position , window ): break if contains : if self . _mouse_target is not None : self . _mouse_target . handle_mouse ( MouseEvent ( MouseAction . RELEASE , event . position ) ) self . _mouse_target = window window . handle_mouse ( event ) break if window . is_modal : break # Unset drag_target if no windows received the input else : self . _drag_target = None if self . _mouse_target is not None : self . _mouse_target . handle_mouse ( MouseEvent ( MouseAction . RELEASE , event . position ) ) self . _mouse_target = None","title":"process_mouse()"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.remove","text":"Removes a window from the manager. Parameters: Name Type Description Default window Window The window to remove. required autostop bool If set, the manager will be stopped if the length of its windows hits 0. True Source code in pytermgui/window_manager/manager.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 def remove ( self , window : Window , autostop : bool = True , animate : bool = True , ) -> WindowManager : \"\"\"Removes a window from the manager. Args: window: The window to remove. autostop: If set, the manager will be stopped if the length of its windows hits 0. \"\"\" def _on_finish ( _ : AttrAnimation | None ) -> bool : self . _windows . remove ( window ) if autostop and len ( self . _windows ) == 0 : self . stop () else : self . focus ( self . _windows [ 0 ]) return True if not animate : _on_finish ( None ) return self animator . animate_attr ( target = window , attr = \"height\" , end = 0 , duration = 300 , on_step = _center_during_animation , on_finish = _on_finish , ) return self","title":"remove()"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.run","text":"Starts the WindowManager. Parameters: Name Type Description Default mouse_events list [ str ] | None A list of mouse event types to listen to. See pytermgui.ansi_interface.report_mouse for more information. Defaults to [\"press_hold\", \"hover\"] . None Returns: Type Description None The WindowManager's compositor instance. Source code in pytermgui/window_manager/manager.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 def run ( self , mouse_events : list [ str ] | None = None ) -> None : \"\"\"Starts the WindowManager. Args: mouse_events: A list of mouse event types to listen to. See `pytermgui.ansi_interface.report_mouse` for more information. Defaults to `[\"press_hold\", \"hover\"]`. Returns: The WindowManager's compositor instance. \"\"\" self . _is_running = True if mouse_events is None : mouse_events = [ \"press_hold\" , \"hover\" ] with alt_buffer ( cursor = False , echo = False ): with mouse_handler ( mouse_events , \"decimal_xterm\" ) as translate : self . mouse_translator = translate self . compositor . run () self . _run_input_loop ()","title":"run()"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.screenshot","text":"Takes a screenshot of the current state. See pytermgui.exporters.to_svg for more information. Parameters: Name Type Description Default filename str The name of the file. 'screenshot.svg' Source code in pytermgui/window_manager/manager.py 529 530 531 532 533 534 535 536 537 538 def screenshot ( self , title : str , filename : str = \"screenshot.svg\" ) -> None : \"\"\"Takes a screenshot of the current state. See `pytermgui.exporters.to_svg` for more information. Args: filename: The name of the file. \"\"\" self . compositor . capture ( title = title , filename = filename )","title":"screenshot()"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.show_positions","text":"Shows the positions of each Window's widgets. Source code in pytermgui/window_manager/manager.py 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 def show_positions ( self ) -> None : \"\"\"Shows the positions of each Window's widgets.\"\"\" def _show_positions ( widget , color_base : int = 60 ) -> None : \"\"\"Show positions of widget.\"\"\" if isinstance ( widget , Container ): for i , subwidget in enumerate ( widget ): _show_positions ( subwidget , color_base + i ) return if not widget . is_selectable : return debug = widget . debug () color = str_to_color ( f \"@ { color_base } \" ) buff = color ( \" \" , reset = False ) for i in range ( min ( widget . width , real_length ( debug )) - 1 ): buff += debug [ i ] self . terminal . write ( buff , pos = widget . pos ) for widget in self . _windows : _show_positions ( widget ) self . terminal . flush () getch ()","title":"show_positions()"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.stop","text":"Stops the WindowManager and its compositor. Source code in pytermgui/window_manager/manager.py 197 198 199 200 201 def stop ( self ) -> None : \"\"\"Stops the WindowManager and its compositor.\"\"\" self . compositor . stop () self . _is_running = False","title":"stop()"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.toast","text":"Creates a Material UI-inspired toast window of the given elements and attributes. Parameters: Name Type Description Default *items Any All widget-convertable objects passed as children of the new window. () delay int The amount of time before the window will start animating out. 1000 **attributes Any kwargs passed as the new window's attributes. {} Source code in pytermgui/window_manager/manager.py 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 def toast ( self , * items : Any , offset : int = 0 , duration : int = 300 , delay : int = 1000 , ** attributes : Any , ) -> Window : \"\"\"Creates a Material UI-inspired toast window of the given elements and attributes. Args: *items: All widget-convertable objects passed as children of the new window. delay: The amount of time before the window will start animating out. **attributes: kwargs passed as the new window's attributes. \"\"\" # pylint: disable=no-value-for-parameter toast = Window ( * items , is_noblur = True , ** attributes ) target_height = toast . height toast . overflow = Overflow . HIDE def _finish ( _ : Animation ) -> None : self . remove ( toast , animate = False ) def _progressively_show ( anim : Animation , invert : bool = False ) -> bool : height = int ( anim . state * target_height ) toast . center () if invert : toast . height = target_height - 1 - height toast . pos = ( toast . pos [ 0 ], self . terminal . height - toast . height + 1 - offset , ) return False toast . height = height toast . pos = ( toast . pos [ 0 ], self . terminal . height - toast . height + 1 - offset ) return False def _animate_toast_out ( _ : Animation ) -> None : animator . schedule ( FloatAnimation ( delay , on_finish = lambda * _ : animator . schedule ( FloatAnimation ( duration , on_step = lambda anim : _progressively_show ( anim , invert = True ), on_finish = _finish , ) ), ) ) leadup = FloatAnimation ( duration , on_step = _progressively_show , on_finish = _animate_toast_out ) # pylint: enable=no-value-for-parameter self . add ( toast . center (), animate = False , assign = False ) self . focus ( toast ) animator . schedule ( leadup ) return toast","title":"toast()"},{"location":"reference/pytermgui/window_manager/window/","text":"The Window class, which is an implementation of pytermgui.widgets.Container that allows for mouse-based moving and resizing. Window Bases: Container A class representing a window. Windows are essentially fancy pytermgui.widgets.Container -s. They build on top of them to store and display various widgets, while allowing some custom functionality. Source code in pytermgui/window_manager/window.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 class Window ( Container ): # pylint: disable=too-many-instance-attributes \"\"\"A class representing a window. Windows are essentially fancy `pytermgui.widgets.Container`-s. They build on top of them to store and display various widgets, while allowing some custom functionality. \"\"\" overflow = Overflow . HIDE title = \"\" \"\"\"Title shown in left-top corner.\"\"\" is_static = False \"\"\"Static windows cannot be moved using the mouse.\"\"\" is_modal = False \"\"\"Modal windows stay on top of every other window and block interactions with other windows.\"\"\" is_noblur = False \"\"\"No-blur windows will always appear to stay in focus, even if they functionally don't.\"\"\" is_noresize = False \"\"\"No-resize windows cannot be resized using the mouse.\"\"\" is_dirty = False \"\"\"Controls whether the window should be redrawn in the next frame.\"\"\" is_persistent = False \"\"\"Persistent windows will be set noblur automatically, and remain clickable even through modals. While the library core doesn't do this for various reasons, it also might be useful to disable some behaviour (e.g. closing) for persistent windows on an implementation level. \"\"\" chars = Container . chars . copy () styles = w_styles . StyleManager ( border = \"surface\" , corner = \"surface\" , fill = \"background\" , border_focused = \"surface\" , corner_focused = \"surface\" , border_blurred = \"surface-2\" , corner_blurred = \"surface-2\" , ) def __init__ ( self , * widgets : Any , ** attrs : Any ) -> None : \"\"\"Initializes object. Args: *widgets: Widgets to add to this window after initilization. **attrs: Attributes that are passed to the constructor. \"\"\" self . _min_width : int | None = None self . _auto_min_width : int | None = None self . styles . border_focused = type ( self ) . styles . border self . styles . corner_focused = type ( self ) . styles . corner if \"box\" not in attrs : attrs [ \"box\" ] = \"DOUBLE\" super () . __init__ ( * widgets , ** attrs ) self . has_focus : bool = False self . manager : \"WindowManager\" | None = None # ------------------------- position ----- width x height self . _restore_data : tuple [ tuple [ int , int ], tuple [ int , int ]] | None = None if self . title != \"\" : self . set_title ( self . title ) if self . is_persistent : self . is_noblur = True @property def min_width ( self ) -> int | None : \"\"\"Minimum width of the window. If set to none, _auto_min_width will be calculated based on the maximum width of inner widgets. This is accurate enough for general use, but tends to lean to the safer side, i.e. it often overshoots the 'real' minimum width possible. If you find this to be the case, **AND** you can ensure that your window will not break, you may set this value manually. Returns: The calculated, or given minimum width of this object. \"\"\" return self . _min_width or self . _auto_min_width @min_width . setter def min_width ( self , new : int | None ) -> None : \"\"\"Sets a new minimum width.\"\"\" self . _min_width = new @property def rect ( self ) -> tuple [ int , int , int , int ]: \"\"\"Returns the tuple of positions that define this window. Returns: A tuple of integers, in the order (left, top, right, bottom). \"\"\" left , top = self . pos return ( left , top , left + self . width , top + self . height ) @rect . setter def rect ( self , new : tuple [ int , int , int , int ]) -> None : \"\"\"Sets new position, width and height of this window. This method also checks for the minimum width this window can be, and if the new width doesn't comply with that setting the changes are thrown away. Args: new: A tuple of integers in the order (left, top, right, bottom). \"\"\" left , top , right , bottom = new minimum = self . min_width or 0 if right - left < minimum : return # Update size policy to fill to resize inner objects properly self . size_policy = SizePolicy . FILL self . pos = ( left , top ) self . width = right - left self . height = bottom - top # Restore original size policy self . size_policy = SizePolicy . STATIC def __iadd__ ( self , other : object ) -> Window : \"\"\"Calls self._add_widget(other) and returns self.\"\"\" self . _add_widget ( other ) return self def __add__ ( self , other : object ) -> Window : \"\"\"Calls self._add_widget(other) and returns self.\"\"\" self . _add_widget ( other ) return self def _add_widget ( self , other : object , run_get_lines : bool = True ) -> Widget : \"\"\"Adds a widget to the window. Args: other: The widget-like to add. run_get_lines: Whether self.get_lines should be ran after adding. \"\"\" added = super () . _add_widget ( other , run_get_lines ) if len ( self . _widgets ) > 0 : self . _auto_min_width = max ( widget . width for widget in self . _widgets ) self . _auto_min_width += self . sidelength self . height += added . height return added @classmethod def set_focus_styles ( cls , * , focused : tuple [ w_styles . StyleValue , w_styles . StyleValue ], blurred : tuple [ w_styles . StyleValue , w_styles . StyleValue ], ) -> None : \"\"\"Sets focused & blurred border & corner styles. Args: focused: A tuple of border_focused, corner_focused styles. blurred: A tuple of border_blurred, corner_blurred styles. \"\"\" cls . styles . border_focused , cls . styles . corner_focused = focused cls . styles . border_blurred , cls . styles . corner_blurred = blurred def focus ( self ) -> None : \"\"\"Focuses this window.\"\"\" self . has_focus = True if not self . is_noblur : self . styles . border = self . styles . border_focused self . styles . corner = self . styles . corner_focused def blur ( self ) -> None : \"\"\"Blurs (unfocuses) this window.\"\"\" self . has_focus = False self . select ( None ) self . handle_mouse ( MouseEvent ( MouseAction . RELEASE , ( 0 , 0 ))) if not self . is_noblur : self . styles . border = self . styles . border_blurred self . styles . corner = self . styles . corner_blurred def clear_cache ( self ) -> None : \"\"\"Clears manager compositor's cached blur state.\"\"\" if self . manager is not None : self . manager . clear_cache ( self ) def contains ( self , pos : tuple [ int , int ]) -> bool : \"\"\"Determines whether widget contains `pos`. This method uses window.rect to get the positions. Args: pos: Position to compare. Returns: Boolean describing whether the position is inside this widget. \"\"\" left , top , right , bottom = self . rect return left <= pos [ 0 ] < right and top <= pos [ 1 ] < bottom def set_title ( self , title : str , position : int = 0 , pad : bool = True ) -> Window : \"\"\"Sets the window's title. Args: title: The string to set as the window title. position: An integer indexing into [\"left\", \"top\", \"right\", \"bottom\"], determining where the title is applied. pad: Whether there should be an extra space before and after the given title. defaults to True. \"\"\" self . title = title if pad : title = \" \" + title + \" \" corners = self . _get_char ( \"corner\" ) assert isinstance ( corners , list ) if position % 2 == 0 : corners [ position ] += title else : current = corners [ position ] corners [ position ] = title + current self . set_char ( \"corner\" , corners ) return self def center ( self , where : CenteringPolicy | None = None , store : bool = True ) -> Window : \"\"\"Center window\"\"\" super () . center ( where , store ) return self def close ( self , animate : bool = True ) -> None : \"\"\"Instruct window manager to close object\"\"\" assert self . manager is not None self . manager . remove ( self , animate = animate ) is_dirty = False class-attribute Controls whether the window should be redrawn in the next frame. is_modal = False class-attribute Modal windows stay on top of every other window and block interactions with other windows. is_noblur = False class-attribute No-blur windows will always appear to stay in focus, even if they functionally don't. is_noresize = False class-attribute No-resize windows cannot be resized using the mouse. is_persistent = False class-attribute Persistent windows will be set noblur automatically, and remain clickable even through modals. While the library core doesn't do this for various reasons, it also might be useful to disable some behaviour (e.g. closing) for persistent windows on an implementation level. is_static = False class-attribute Static windows cannot be moved using the mouse. title = '' class-attribute Title shown in left-top corner. __add__ ( other ) Calls self._add_widget(other) and returns self. Source code in pytermgui/window_manager/window.py 165 166 167 168 169 def __add__ ( self , other : object ) -> Window : \"\"\"Calls self._add_widget(other) and returns self.\"\"\" self . _add_widget ( other ) return self __iadd__ ( other ) Calls self._add_widget(other) and returns self. Source code in pytermgui/window_manager/window.py 159 160 161 162 163 def __iadd__ ( self , other : object ) -> Window : \"\"\"Calls self._add_widget(other) and returns self.\"\"\" self . _add_widget ( other ) return self __init__ ( widgets , attrs ) Initializes object. Parameters: Name Type Description Default *widgets Any Widgets to add to this window after initilization. () **attrs Any Attributes that are passed to the constructor. {} Source code in pytermgui/window_manager/window.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def __init__ ( self , * widgets : Any , ** attrs : Any ) -> None : \"\"\"Initializes object. Args: *widgets: Widgets to add to this window after initilization. **attrs: Attributes that are passed to the constructor. \"\"\" self . _min_width : int | None = None self . _auto_min_width : int | None = None self . styles . border_focused = type ( self ) . styles . border self . styles . corner_focused = type ( self ) . styles . corner if \"box\" not in attrs : attrs [ \"box\" ] = \"DOUBLE\" super () . __init__ ( * widgets , ** attrs ) self . has_focus : bool = False self . manager : \"WindowManager\" | None = None # ------------------------- position ----- width x height self . _restore_data : tuple [ tuple [ int , int ], tuple [ int , int ]] | None = None if self . title != \"\" : self . set_title ( self . title ) if self . is_persistent : self . is_noblur = True blur () Blurs (unfocuses) this window. Source code in pytermgui/window_manager/window.py 215 216 217 218 219 220 221 222 223 224 def blur ( self ) -> None : \"\"\"Blurs (unfocuses) this window.\"\"\" self . has_focus = False self . select ( None ) self . handle_mouse ( MouseEvent ( MouseAction . RELEASE , ( 0 , 0 ))) if not self . is_noblur : self . styles . border = self . styles . border_blurred self . styles . corner = self . styles . corner_blurred center ( where = None , store = True ) Center window Source code in pytermgui/window_manager/window.py 279 280 281 282 283 284 285 def center ( self , where : CenteringPolicy | None = None , store : bool = True ) -> Window : \"\"\"Center window\"\"\" super () . center ( where , store ) return self clear_cache () Clears manager compositor's cached blur state. Source code in pytermgui/window_manager/window.py 226 227 228 229 230 def clear_cache ( self ) -> None : \"\"\"Clears manager compositor's cached blur state.\"\"\" if self . manager is not None : self . manager . clear_cache ( self ) close ( animate = True ) Instruct window manager to close object Source code in pytermgui/window_manager/window.py 287 288 289 290 291 292 def close ( self , animate : bool = True ) -> None : \"\"\"Instruct window manager to close object\"\"\" assert self . manager is not None self . manager . remove ( self , animate = animate ) contains ( pos ) Determines whether widget contains pos . This method uses window.rect to get the positions. Parameters: Name Type Description Default pos tuple [ int , int ] Position to compare. required Returns: Type Description bool Boolean describing whether the position is inside this widget. Source code in pytermgui/window_manager/window.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 def contains ( self , pos : tuple [ int , int ]) -> bool : \"\"\"Determines whether widget contains `pos`. This method uses window.rect to get the positions. Args: pos: Position to compare. Returns: Boolean describing whether the position is inside this widget. \"\"\" left , top , right , bottom = self . rect return left <= pos [ 0 ] < right and top <= pos [ 1 ] < bottom focus () Focuses this window. Source code in pytermgui/window_manager/window.py 206 207 208 209 210 211 212 213 def focus ( self ) -> None : \"\"\"Focuses this window.\"\"\" self . has_focus = True if not self . is_noblur : self . styles . border = self . styles . border_focused self . styles . corner = self . styles . corner_focused min_width () property writable Minimum width of the window. If set to none, _auto_min_width will be calculated based on the maximum width of inner widgets. This is accurate enough for general use, but tends to lean to the safer side, i.e. it often overshoots the 'real' minimum width possible. If you find this to be the case, AND you can ensure that your window will not break, you may set this value manually. Returns: Type Description int | None The calculated, or given minimum width of this object. Source code in pytermgui/window_manager/window.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @property def min_width ( self ) -> int | None : \"\"\"Minimum width of the window. If set to none, _auto_min_width will be calculated based on the maximum width of inner widgets. This is accurate enough for general use, but tends to lean to the safer side, i.e. it often overshoots the 'real' minimum width possible. If you find this to be the case, **AND** you can ensure that your window will not break, you may set this value manually. Returns: The calculated, or given minimum width of this object. \"\"\" return self . _min_width or self . _auto_min_width rect () property writable Returns the tuple of positions that define this window. Returns: Type Description tuple [ int , int , int , int ] A tuple of integers, in the order (left, top, right, bottom). Source code in pytermgui/window_manager/window.py 121 122 123 124 125 126 127 128 129 130 @property def rect ( self ) -> tuple [ int , int , int , int ]: \"\"\"Returns the tuple of positions that define this window. Returns: A tuple of integers, in the order (left, top, right, bottom). \"\"\" left , top = self . pos return ( left , top , left + self . width , top + self . height ) set_focus_styles ( * , focused , blurred ) classmethod Sets focused & blurred border & corner styles. Parameters: Name Type Description Default focused tuple [ w_styles . StyleValue , w_styles . StyleValue ] A tuple of border_focused, corner_focused styles. required blurred tuple [ w_styles . StyleValue , w_styles . StyleValue ] A tuple of border_blurred, corner_blurred styles. required Source code in pytermgui/window_manager/window.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 @classmethod def set_focus_styles ( cls , * , focused : tuple [ w_styles . StyleValue , w_styles . StyleValue ], blurred : tuple [ w_styles . StyleValue , w_styles . StyleValue ], ) -> None : \"\"\"Sets focused & blurred border & corner styles. Args: focused: A tuple of border_focused, corner_focused styles. blurred: A tuple of border_blurred, corner_blurred styles. \"\"\" cls . styles . border_focused , cls . styles . corner_focused = focused cls . styles . border_blurred , cls . styles . corner_blurred = blurred set_title ( title , position = 0 , pad = True ) Sets the window's title. Parameters: Name Type Description Default title str The string to set as the window title. required position int An integer indexing into [\"left\", \"top\", \"right\", \"bottom\"], determining where the title is applied. 0 pad bool Whether there should be an extra space before and after the given title. defaults to True. True Source code in pytermgui/window_manager/window.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 def set_title ( self , title : str , position : int = 0 , pad : bool = True ) -> Window : \"\"\"Sets the window's title. Args: title: The string to set as the window title. position: An integer indexing into [\"left\", \"top\", \"right\", \"bottom\"], determining where the title is applied. pad: Whether there should be an extra space before and after the given title. defaults to True. \"\"\" self . title = title if pad : title = \" \" + title + \" \" corners = self . _get_char ( \"corner\" ) assert isinstance ( corners , list ) if position % 2 == 0 : corners [ position ] += title else : current = corners [ position ] corners [ position ] = title + current self . set_char ( \"corner\" , corners ) return self","title":"window"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window","text":"Bases: Container A class representing a window. Windows are essentially fancy pytermgui.widgets.Container -s. They build on top of them to store and display various widgets, while allowing some custom functionality. Source code in pytermgui/window_manager/window.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 class Window ( Container ): # pylint: disable=too-many-instance-attributes \"\"\"A class representing a window. Windows are essentially fancy `pytermgui.widgets.Container`-s. They build on top of them to store and display various widgets, while allowing some custom functionality. \"\"\" overflow = Overflow . HIDE title = \"\" \"\"\"Title shown in left-top corner.\"\"\" is_static = False \"\"\"Static windows cannot be moved using the mouse.\"\"\" is_modal = False \"\"\"Modal windows stay on top of every other window and block interactions with other windows.\"\"\" is_noblur = False \"\"\"No-blur windows will always appear to stay in focus, even if they functionally don't.\"\"\" is_noresize = False \"\"\"No-resize windows cannot be resized using the mouse.\"\"\" is_dirty = False \"\"\"Controls whether the window should be redrawn in the next frame.\"\"\" is_persistent = False \"\"\"Persistent windows will be set noblur automatically, and remain clickable even through modals. While the library core doesn't do this for various reasons, it also might be useful to disable some behaviour (e.g. closing) for persistent windows on an implementation level. \"\"\" chars = Container . chars . copy () styles = w_styles . StyleManager ( border = \"surface\" , corner = \"surface\" , fill = \"background\" , border_focused = \"surface\" , corner_focused = \"surface\" , border_blurred = \"surface-2\" , corner_blurred = \"surface-2\" , ) def __init__ ( self , * widgets : Any , ** attrs : Any ) -> None : \"\"\"Initializes object. Args: *widgets: Widgets to add to this window after initilization. **attrs: Attributes that are passed to the constructor. \"\"\" self . _min_width : int | None = None self . _auto_min_width : int | None = None self . styles . border_focused = type ( self ) . styles . border self . styles . corner_focused = type ( self ) . styles . corner if \"box\" not in attrs : attrs [ \"box\" ] = \"DOUBLE\" super () . __init__ ( * widgets , ** attrs ) self . has_focus : bool = False self . manager : \"WindowManager\" | None = None # ------------------------- position ----- width x height self . _restore_data : tuple [ tuple [ int , int ], tuple [ int , int ]] | None = None if self . title != \"\" : self . set_title ( self . title ) if self . is_persistent : self . is_noblur = True @property def min_width ( self ) -> int | None : \"\"\"Minimum width of the window. If set to none, _auto_min_width will be calculated based on the maximum width of inner widgets. This is accurate enough for general use, but tends to lean to the safer side, i.e. it often overshoots the 'real' minimum width possible. If you find this to be the case, **AND** you can ensure that your window will not break, you may set this value manually. Returns: The calculated, or given minimum width of this object. \"\"\" return self . _min_width or self . _auto_min_width @min_width . setter def min_width ( self , new : int | None ) -> None : \"\"\"Sets a new minimum width.\"\"\" self . _min_width = new @property def rect ( self ) -> tuple [ int , int , int , int ]: \"\"\"Returns the tuple of positions that define this window. Returns: A tuple of integers, in the order (left, top, right, bottom). \"\"\" left , top = self . pos return ( left , top , left + self . width , top + self . height ) @rect . setter def rect ( self , new : tuple [ int , int , int , int ]) -> None : \"\"\"Sets new position, width and height of this window. This method also checks for the minimum width this window can be, and if the new width doesn't comply with that setting the changes are thrown away. Args: new: A tuple of integers in the order (left, top, right, bottom). \"\"\" left , top , right , bottom = new minimum = self . min_width or 0 if right - left < minimum : return # Update size policy to fill to resize inner objects properly self . size_policy = SizePolicy . FILL self . pos = ( left , top ) self . width = right - left self . height = bottom - top # Restore original size policy self . size_policy = SizePolicy . STATIC def __iadd__ ( self , other : object ) -> Window : \"\"\"Calls self._add_widget(other) and returns self.\"\"\" self . _add_widget ( other ) return self def __add__ ( self , other : object ) -> Window : \"\"\"Calls self._add_widget(other) and returns self.\"\"\" self . _add_widget ( other ) return self def _add_widget ( self , other : object , run_get_lines : bool = True ) -> Widget : \"\"\"Adds a widget to the window. Args: other: The widget-like to add. run_get_lines: Whether self.get_lines should be ran after adding. \"\"\" added = super () . _add_widget ( other , run_get_lines ) if len ( self . _widgets ) > 0 : self . _auto_min_width = max ( widget . width for widget in self . _widgets ) self . _auto_min_width += self . sidelength self . height += added . height return added @classmethod def set_focus_styles ( cls , * , focused : tuple [ w_styles . StyleValue , w_styles . StyleValue ], blurred : tuple [ w_styles . StyleValue , w_styles . StyleValue ], ) -> None : \"\"\"Sets focused & blurred border & corner styles. Args: focused: A tuple of border_focused, corner_focused styles. blurred: A tuple of border_blurred, corner_blurred styles. \"\"\" cls . styles . border_focused , cls . styles . corner_focused = focused cls . styles . border_blurred , cls . styles . corner_blurred = blurred def focus ( self ) -> None : \"\"\"Focuses this window.\"\"\" self . has_focus = True if not self . is_noblur : self . styles . border = self . styles . border_focused self . styles . corner = self . styles . corner_focused def blur ( self ) -> None : \"\"\"Blurs (unfocuses) this window.\"\"\" self . has_focus = False self . select ( None ) self . handle_mouse ( MouseEvent ( MouseAction . RELEASE , ( 0 , 0 ))) if not self . is_noblur : self . styles . border = self . styles . border_blurred self . styles . corner = self . styles . corner_blurred def clear_cache ( self ) -> None : \"\"\"Clears manager compositor's cached blur state.\"\"\" if self . manager is not None : self . manager . clear_cache ( self ) def contains ( self , pos : tuple [ int , int ]) -> bool : \"\"\"Determines whether widget contains `pos`. This method uses window.rect to get the positions. Args: pos: Position to compare. Returns: Boolean describing whether the position is inside this widget. \"\"\" left , top , right , bottom = self . rect return left <= pos [ 0 ] < right and top <= pos [ 1 ] < bottom def set_title ( self , title : str , position : int = 0 , pad : bool = True ) -> Window : \"\"\"Sets the window's title. Args: title: The string to set as the window title. position: An integer indexing into [\"left\", \"top\", \"right\", \"bottom\"], determining where the title is applied. pad: Whether there should be an extra space before and after the given title. defaults to True. \"\"\" self . title = title if pad : title = \" \" + title + \" \" corners = self . _get_char ( \"corner\" ) assert isinstance ( corners , list ) if position % 2 == 0 : corners [ position ] += title else : current = corners [ position ] corners [ position ] = title + current self . set_char ( \"corner\" , corners ) return self def center ( self , where : CenteringPolicy | None = None , store : bool = True ) -> Window : \"\"\"Center window\"\"\" super () . center ( where , store ) return self def close ( self , animate : bool = True ) -> None : \"\"\"Instruct window manager to close object\"\"\" assert self . manager is not None self . manager . remove ( self , animate = animate )","title":"Window"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.is_dirty","text":"Controls whether the window should be redrawn in the next frame.","title":"is_dirty"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.is_modal","text":"Modal windows stay on top of every other window and block interactions with other windows.","title":"is_modal"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.is_noblur","text":"No-blur windows will always appear to stay in focus, even if they functionally don't.","title":"is_noblur"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.is_noresize","text":"No-resize windows cannot be resized using the mouse.","title":"is_noresize"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.is_persistent","text":"Persistent windows will be set noblur automatically, and remain clickable even through modals. While the library core doesn't do this for various reasons, it also might be useful to disable some behaviour (e.g. closing) for persistent windows on an implementation level.","title":"is_persistent"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.is_static","text":"Static windows cannot be moved using the mouse.","title":"is_static"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.title","text":"Title shown in left-top corner.","title":"title"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.__add__","text":"Calls self._add_widget(other) and returns self. Source code in pytermgui/window_manager/window.py 165 166 167 168 169 def __add__ ( self , other : object ) -> Window : \"\"\"Calls self._add_widget(other) and returns self.\"\"\" self . _add_widget ( other ) return self","title":"__add__()"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.__iadd__","text":"Calls self._add_widget(other) and returns self. Source code in pytermgui/window_manager/window.py 159 160 161 162 163 def __iadd__ ( self , other : object ) -> Window : \"\"\"Calls self._add_widget(other) and returns self.\"\"\" self . _add_widget ( other ) return self","title":"__iadd__()"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.__init__","text":"Initializes object. Parameters: Name Type Description Default *widgets Any Widgets to add to this window after initilization. () **attrs Any Attributes that are passed to the constructor. {} Source code in pytermgui/window_manager/window.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def __init__ ( self , * widgets : Any , ** attrs : Any ) -> None : \"\"\"Initializes object. Args: *widgets: Widgets to add to this window after initilization. **attrs: Attributes that are passed to the constructor. \"\"\" self . _min_width : int | None = None self . _auto_min_width : int | None = None self . styles . border_focused = type ( self ) . styles . border self . styles . corner_focused = type ( self ) . styles . corner if \"box\" not in attrs : attrs [ \"box\" ] = \"DOUBLE\" super () . __init__ ( * widgets , ** attrs ) self . has_focus : bool = False self . manager : \"WindowManager\" | None = None # ------------------------- position ----- width x height self . _restore_data : tuple [ tuple [ int , int ], tuple [ int , int ]] | None = None if self . title != \"\" : self . set_title ( self . title ) if self . is_persistent : self . is_noblur = True","title":"__init__()"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.blur","text":"Blurs (unfocuses) this window. Source code in pytermgui/window_manager/window.py 215 216 217 218 219 220 221 222 223 224 def blur ( self ) -> None : \"\"\"Blurs (unfocuses) this window.\"\"\" self . has_focus = False self . select ( None ) self . handle_mouse ( MouseEvent ( MouseAction . RELEASE , ( 0 , 0 ))) if not self . is_noblur : self . styles . border = self . styles . border_blurred self . styles . corner = self . styles . corner_blurred","title":"blur()"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.center","text":"Center window Source code in pytermgui/window_manager/window.py 279 280 281 282 283 284 285 def center ( self , where : CenteringPolicy | None = None , store : bool = True ) -> Window : \"\"\"Center window\"\"\" super () . center ( where , store ) return self","title":"center()"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.clear_cache","text":"Clears manager compositor's cached blur state. Source code in pytermgui/window_manager/window.py 226 227 228 229 230 def clear_cache ( self ) -> None : \"\"\"Clears manager compositor's cached blur state.\"\"\" if self . manager is not None : self . manager . clear_cache ( self )","title":"clear_cache()"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.close","text":"Instruct window manager to close object Source code in pytermgui/window_manager/window.py 287 288 289 290 291 292 def close ( self , animate : bool = True ) -> None : \"\"\"Instruct window manager to close object\"\"\" assert self . manager is not None self . manager . remove ( self , animate = animate )","title":"close()"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.contains","text":"Determines whether widget contains pos . This method uses window.rect to get the positions. Parameters: Name Type Description Default pos tuple [ int , int ] Position to compare. required Returns: Type Description bool Boolean describing whether the position is inside this widget. Source code in pytermgui/window_manager/window.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 def contains ( self , pos : tuple [ int , int ]) -> bool : \"\"\"Determines whether widget contains `pos`. This method uses window.rect to get the positions. Args: pos: Position to compare. Returns: Boolean describing whether the position is inside this widget. \"\"\" left , top , right , bottom = self . rect return left <= pos [ 0 ] < right and top <= pos [ 1 ] < bottom","title":"contains()"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.focus","text":"Focuses this window. Source code in pytermgui/window_manager/window.py 206 207 208 209 210 211 212 213 def focus ( self ) -> None : \"\"\"Focuses this window.\"\"\" self . has_focus = True if not self . is_noblur : self . styles . border = self . styles . border_focused self . styles . corner = self . styles . corner_focused","title":"focus()"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.min_width","text":"Minimum width of the window. If set to none, _auto_min_width will be calculated based on the maximum width of inner widgets. This is accurate enough for general use, but tends to lean to the safer side, i.e. it often overshoots the 'real' minimum width possible. If you find this to be the case, AND you can ensure that your window will not break, you may set this value manually. Returns: Type Description int | None The calculated, or given minimum width of this object. Source code in pytermgui/window_manager/window.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @property def min_width ( self ) -> int | None : \"\"\"Minimum width of the window. If set to none, _auto_min_width will be calculated based on the maximum width of inner widgets. This is accurate enough for general use, but tends to lean to the safer side, i.e. it often overshoots the 'real' minimum width possible. If you find this to be the case, **AND** you can ensure that your window will not break, you may set this value manually. Returns: The calculated, or given minimum width of this object. \"\"\" return self . _min_width or self . _auto_min_width","title":"min_width()"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.rect","text":"Returns the tuple of positions that define this window. Returns: Type Description tuple [ int , int , int , int ] A tuple of integers, in the order (left, top, right, bottom). Source code in pytermgui/window_manager/window.py 121 122 123 124 125 126 127 128 129 130 @property def rect ( self ) -> tuple [ int , int , int , int ]: \"\"\"Returns the tuple of positions that define this window. Returns: A tuple of integers, in the order (left, top, right, bottom). \"\"\" left , top = self . pos return ( left , top , left + self . width , top + self . height )","title":"rect()"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.set_focus_styles","text":"Sets focused & blurred border & corner styles. Parameters: Name Type Description Default focused tuple [ w_styles . StyleValue , w_styles . StyleValue ] A tuple of border_focused, corner_focused styles. required blurred tuple [ w_styles . StyleValue , w_styles . StyleValue ] A tuple of border_blurred, corner_blurred styles. required Source code in pytermgui/window_manager/window.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 @classmethod def set_focus_styles ( cls , * , focused : tuple [ w_styles . StyleValue , w_styles . StyleValue ], blurred : tuple [ w_styles . StyleValue , w_styles . StyleValue ], ) -> None : \"\"\"Sets focused & blurred border & corner styles. Args: focused: A tuple of border_focused, corner_focused styles. blurred: A tuple of border_blurred, corner_blurred styles. \"\"\" cls . styles . border_focused , cls . styles . corner_focused = focused cls . styles . border_blurred , cls . styles . corner_blurred = blurred","title":"set_focus_styles()"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.set_title","text":"Sets the window's title. Parameters: Name Type Description Default title str The string to set as the window title. required position int An integer indexing into [\"left\", \"top\", \"right\", \"bottom\"], determining where the title is applied. 0 pad bool Whether there should be an extra space before and after the given title. defaults to True. True Source code in pytermgui/window_manager/window.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 def set_title ( self , title : str , position : int = 0 , pad : bool = True ) -> Window : \"\"\"Sets the window's title. Args: title: The string to set as the window title. position: An integer indexing into [\"left\", \"top\", \"right\", \"bottom\"], determining where the title is applied. pad: Whether there should be an extra space before and after the given title. defaults to True. \"\"\" self . title = title if pad : title = \" \" + title + \" \" corners = self . _get_char ( \"corner\" ) assert isinstance ( corners , list ) if position % 2 == 0 : corners [ position ] += title else : current = corners [ position ] corners [ position ] = title + current self . set_char ( \"corner\" , corners ) return self","title":"set_title()"},{"location":"tim/","text":"PyTermGUI offers a markup language complimentary to the other features of the library, named T erminal I nline M arkup, or TIM for short. This language is in use in various places within the library, and is supported by pretty much everything we offer that displays text. from pytermgui import tim tim . print ( \"[bold lightblue]Hello[/fg italic]!\" ) tim . print ( \"[bold]TIM[/] supports [italic]macros[/],\" + \" like [!upper]upper[/!] and [bold !gradient(56)]gradient[/!].\" ) tim . print ( \"We also support [skyblue underline ~https://ptg.bczsalba.com]\" + \"terminal hyperlinks[/]!\" ) text.termage-4 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-4-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } TIM Example Hello ! TIM supports macros , like UPPER and g r a d i ent . We also support terminal hyperlinks ! Philosophy Convenience Raw ANSI sequences are cumbersome to use and hard to read/write. TIM aims to improve this by assigning easy-to-read names to pretty much all ANSI syntax. Speed Since this language is meant to be used in performance-critical applications, it must be pretty fast. As of 16th of July 2022, TIM is magnitudes faster than Rich 's own markup language, the only \"competition\" I know about. This is achieved mostly by smart caching routines, as well as a tightly written parsing algorithm. Extensibility I like tinkering. I hate using things that are made with the philosophy of \"this is what I made, and it's all that you will get.\". TIM implements customizability in its alias and macro systems. Convenience & granularity Above all, TIM was made to be simple and ergonomic to use. Styles follow their most-commonly used names, and every tag is applied as its own distinct entity, and aren't joined into a set style. This allows you to specifically clear certain tags, while not touching the rest of the style.","title":"Introduction"},{"location":"tim/#philosophy","text":"Convenience Raw ANSI sequences are cumbersome to use and hard to read/write. TIM aims to improve this by assigning easy-to-read names to pretty much all ANSI syntax. Speed Since this language is meant to be used in performance-critical applications, it must be pretty fast. As of 16th of July 2022, TIM is magnitudes faster than Rich 's own markup language, the only \"competition\" I know about. This is achieved mostly by smart caching routines, as well as a tightly written parsing algorithm. Extensibility I like tinkering. I hate using things that are made with the philosophy of \"this is what I made, and it's all that you will get.\". TIM implements customizability in its alias and macro systems. Convenience & granularity Above all, TIM was made to be simple and ergonomic to use. Styles follow their most-commonly used names, and every tag is applied as its own distinct entity, and aren't joined into a set style. This allows you to specifically clear certain tags, while not touching the rest of the style.","title":"Philosophy"},{"location":"tim/tags/","text":"Basics TIM syntax tends to be simple. At the base, we have the following structure: [tag1 tag2 ...]My content ^ ^ tag group plain text ...where tag1 & tag2 are some valid markup tags, and My content is the string you want them to modify. Tag groups are always denoted by square brackets ( [ and ] ). All text outside of a tag group is considered to be plain text. Nesting When encountering nested tag groups, only the innermost one will be parsed: TIM Output \"[[bold]bold [/ lightblue]lightblue[/]][italic lightgreen]Hello\" text.termage-5 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-5-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } [ bold lightblue ] Hello Escaping You can escape a tag group using backslashes ( \\ ): TIM Output \"\\[bold lightblue][italic lightgreen]Hello\" text.termage-6 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-6-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } [bold lightblue] Hello Re-parsing escaped markup Escaping tag groups will only be effective for the first parsing of said string. During parsing, the escaped tag group will lose the backslash to hide it from the output. Styles We support all generally supported terminal \"modes\": Resource For a great overview on these styles & ANSI sequences in general, see this gist by Christian Petersen , or this website . bold (mode 1 ): Traditionally (and on some older emulators) makes text brighter, nowadays it increases the font's weight. dim (mode 2 ): The opposite of the traditional function behind bold, makes text a bit darker. italic (mode 3 ): Uses the italicized font variant, which tilts each character. underline (mode 4 ): Draws a thin line under each character. blink & blink2 (mode 5 & 6 ): Repeatedly shows and hides the characters at an internal frequency. Like HTML's <blink> , it seems to have fallen out of favor and is no longer supported on many terminals. Some terminal's support one, but not the other. inverse (mode 7 ): Inverts the function of the foreground and background colors, i.e. the foreground color will now act on the background and vice-versa. invisible (mode 8 ): Hides text. Not widely supported, for some reason. strikethrough (mode 9 ): Draws a line through each character, somewhere near the vertical middle. overline (mode 53 ): Draws a line above each character. text.termage-7 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-7-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/tim/tags_modes.py \u250c Available modes \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 bold \u2502 \u2502 dim \u2502 \u2502 italic \u2502 \u2502 underline \u2502 \u2502 blink \u2502 \u2502 blink2 \u2502 \u2502 inverse \u2502 \u2502 invisible \u2502 \u2502 strikethrough \u2502 \u2502 overline \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 Implementation Under the hood, these styles are set by printing a special escape sequence to the terminal. These sequences are structured the following way: \\x1b[{mode_id}m In effect, this means bold stands for \\x1b[1m , and inverse for \\x1b[7m . Colors The terminal generally supports 3 color palettes 3 bit, or 16-color 8 base colors ( red , green , yellow , blue , magenta , cyan , white and black ), and high-brightness version of each, making a total of 16. 8-bit, or 256-color: 256 colors, each using 8 bits of information. The standard colors make up the first 16 indices. 24-bit, or truecolor Something in the ballpark of 16.7 million colors, this set represents all colors definable by 3 8-bit ( 0-255 ) values, each standing for one of the RED , GREEN and BLUE channels. Lucky for you, the reader, TIM exposes convenient syntax for all of these! Indexed colors (3-bit and 8-bit): [{index}] , where index is a number in the range 0-255 , including both ends. RGB colors (24-bit): [{rrr};{ggg};{bbb}] , where rrr , ggg and bbb each represent a number alike the ones indexed colors use, standing for the red, green and blue channels respectively. HEX colors (alternate representation of 24-bit): [#{rr};{gg};{bb}] , where each value represents a 3-bit number like above, as a hexadecimal value. Named colors (3-bit or 24-bit): [{name}] , where name is a CSS color name known to TIM : text.termage-8 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-8-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } CSS Colors aliceblue gainsboro mistyrose antiquewhite ghostwhite moccasin aqua gold navajowhite aquamarine goldenrod navy azure gray oldlace beige grey olive bisque green olivedrab black greenyellow orange blanchedalmond honeydew orangered blue hotpink orchid blueviolet indianred palegoldenrod brown indigo palegreen burlywood ivory paleturquoise cadetblue khaki palevioletred chartreuse lavender papayawhip chocolate lavenderblush peachpuff coral lawngreen peru cornflowerblue lemonchiffon pink cornsilk lightblue plum crimson lightcoral powderblue cyan lightcyan purple darkblue lightgoldenrodyellow red darkcyan lightgray rosybrown darkgoldenrod lightgrey royalblue darkgray lightgreen saddlebrown darkgrey lightpink salmon darkgreen lightsalmon sandybrown darkkhaki lightseagreen seagreen darkmagenta lightskyblue seashell darkolivegreen lightslategray sienna darkorange lightslategrey silver darkorchid lightsteelblue skyblue darkred lightyellow slateblue darksalmon lime slategray darkseagreen limegreen slategrey darkslateblue linen snow darkslategray magenta springgreen darkslategrey maroon steelblue darkturquoise mediumaquamarine tan darkviolet mediumblue teal deeppink mediumorchid thistle deepskyblue mediumpurple tomato dimgray mediumseagreen turquoise dimgrey mediumslateblue violet dodgerblue mediumspringgreen wheat firebrick mediumturquoise white floralwhite mediumvioletred whitesmoke forestgreen midnightblue yellow fuchsia mintcream yellowgreen Colors, by default, will act on the foreground. This can be changed by prefixing the color markup by an at-symbol ( @ ), like so: TIM Output \"[78 @34;52;111] My text [inverse] and now inversed! \" text.termage-9 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-9-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } My text and now inversed! Clearers After you set a style, you might want to stop it affecting text. To do so, you want to use a clearer token. Clearer tokens are denoted with the slash ( / ) prefix, and contain the identifier they are targeting. For example: To clear all attributes, including modes, colors, macros, use / with no identifier. To clear a simple terminal mode, use /{mode} , like /italic . To clear a color, use /fg for foreground colors, and /bg for background ones. To clear a macro , use either /!{name} , or /! to clear all active macros. To clear a hyperlink, use /~ . Clearing specific links Since the terminal only supports having one active hyperlink at a time, there is no reason to have syntax for specifically clearing a single link. Hyperlinks Newer terminals allow HTML anchor-inspired hyperlinks that can be clicked and take the user to places. Resource For information on the implementation of terminal-hyperlinks, check out this gist . In PyTermGUI TIM, we use the syntax: [~{protocol}://{uri}] ...where protocol is a data-transfer protocol supported by the client (usually http , https or file ), and uri is a standard URI readable by the specified protocol. For example: This documentation is hosted as a [~https://ptg.bczsalba.com]subdomain[/~] on my [~https://bczsalba.com]website! ...would create markup equivalent to the HTML: This documentation is hosted as a < a href = \"https://ptg.bczsalba.com\" > subdomain </ a > on my < a href = \"https://bczsalba.com\" > website! </ a > Macros Info This section details the syntax, but none of the semantics and usage tips, For a more in-depth explanation on macros, see the macro docs . Macros use the syntax: [!{name}({arg1}:{arg2})] ...or the shorthand [!{name}] when there are no arguments passed. In both examples, name is the name the macro is defined as, and arg1 and arg2 are some arguments passed to it. Macro arguments are separated by colons ( : ), in order to clearly visually differentiate them from Python function calls. Positioners You can position text in the terminal using the syntax: [({x};{y})] Where x and y are terminal coordinates, starting from terminal.origin . TIM Output \"[61]This is some normal text[(3;5)]But this part is located somewhere else!\" text.termage-10 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-10-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } This is some normal text But this part is located somewhere else! Pseudo-s All tags above have behaviour that is \"pre-defined\"; their meaning will be the same in all uses, regardless of context. Pseudo tags are a sort of context-aware group, where they have don't have a consistent meaning: They modify the existing meaning based on the context around them. Auto It's easier to explain by-example, so here is our first pseudo tag, #auto : Python Output from pytermgui import tim tim . print ( \"[@black #auto]White on black [@white #auto] Black on white\" ) text.termage-11 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-11-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/tim/tags_pseudo1.py White on black Black on white What this tag does is prompt the engine to look around in the current tag group, and inspect the colors set. From then it does the following (simplified): foreground = ... background = ... if foreground is None and background is not None : foreground = get_contrasting_color ( background ) In essence, it looks for any foreground color. If there is None, but there is a background color, it finds a color that contrasts the background (either an off-white or off-black) and applies that to the foreground. You get color-contrast matches that follow the W3C guidelines with just one tag!","title":"Tags"},{"location":"tim/tags/#basics","text":"TIM syntax tends to be simple. At the base, we have the following structure: [tag1 tag2 ...]My content ^ ^ tag group plain text ...where tag1 & tag2 are some valid markup tags, and My content is the string you want them to modify. Tag groups are always denoted by square brackets ( [ and ] ). All text outside of a tag group is considered to be plain text.","title":"Basics"},{"location":"tim/tags/#nesting","text":"When encountering nested tag groups, only the innermost one will be parsed: TIM Output \"[[bold]bold [/ lightblue]lightblue[/]][italic lightgreen]Hello\" text.termage-5 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-5-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } [ bold lightblue ] Hello","title":"Nesting"},{"location":"tim/tags/#escaping","text":"You can escape a tag group using backslashes ( \\ ): TIM Output \"\\[bold lightblue][italic lightgreen]Hello\" text.termage-6 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-6-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } [bold lightblue] Hello Re-parsing escaped markup Escaping tag groups will only be effective for the first parsing of said string. During parsing, the escaped tag group will lose the backslash to hide it from the output.","title":"Escaping"},{"location":"tim/tags/#styles","text":"We support all generally supported terminal \"modes\": Resource For a great overview on these styles & ANSI sequences in general, see this gist by Christian Petersen , or this website . bold (mode 1 ): Traditionally (and on some older emulators) makes text brighter, nowadays it increases the font's weight. dim (mode 2 ): The opposite of the traditional function behind bold, makes text a bit darker. italic (mode 3 ): Uses the italicized font variant, which tilts each character. underline (mode 4 ): Draws a thin line under each character. blink & blink2 (mode 5 & 6 ): Repeatedly shows and hides the characters at an internal frequency. Like HTML's <blink> , it seems to have fallen out of favor and is no longer supported on many terminals. Some terminal's support one, but not the other. inverse (mode 7 ): Inverts the function of the foreground and background colors, i.e. the foreground color will now act on the background and vice-versa. invisible (mode 8 ): Hides text. Not widely supported, for some reason. strikethrough (mode 9 ): Draws a line through each character, somewhere near the vertical middle. overline (mode 53 ): Draws a line above each character. text.termage-7 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-7-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/tim/tags_modes.py \u250c Available modes \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 bold \u2502 \u2502 dim \u2502 \u2502 italic \u2502 \u2502 underline \u2502 \u2502 blink \u2502 \u2502 blink2 \u2502 \u2502 inverse \u2502 \u2502 invisible \u2502 \u2502 strikethrough \u2502 \u2502 overline \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 Implementation Under the hood, these styles are set by printing a special escape sequence to the terminal. These sequences are structured the following way: \\x1b[{mode_id}m In effect, this means bold stands for \\x1b[1m , and inverse for \\x1b[7m .","title":"Styles"},{"location":"tim/tags/#colors","text":"The terminal generally supports 3 color palettes 3 bit, or 16-color 8 base colors ( red , green , yellow , blue , magenta , cyan , white and black ), and high-brightness version of each, making a total of 16. 8-bit, or 256-color: 256 colors, each using 8 bits of information. The standard colors make up the first 16 indices. 24-bit, or truecolor Something in the ballpark of 16.7 million colors, this set represents all colors definable by 3 8-bit ( 0-255 ) values, each standing for one of the RED , GREEN and BLUE channels. Lucky for you, the reader, TIM exposes convenient syntax for all of these! Indexed colors (3-bit and 8-bit): [{index}] , where index is a number in the range 0-255 , including both ends. RGB colors (24-bit): [{rrr};{ggg};{bbb}] , where rrr , ggg and bbb each represent a number alike the ones indexed colors use, standing for the red, green and blue channels respectively. HEX colors (alternate representation of 24-bit): [#{rr};{gg};{bb}] , where each value represents a 3-bit number like above, as a hexadecimal value. Named colors (3-bit or 24-bit): [{name}] , where name is a CSS color name known to TIM : text.termage-8 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-8-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } CSS Colors aliceblue gainsboro mistyrose antiquewhite ghostwhite moccasin aqua gold navajowhite aquamarine goldenrod navy azure gray oldlace beige grey olive bisque green olivedrab black greenyellow orange blanchedalmond honeydew orangered blue hotpink orchid blueviolet indianred palegoldenrod brown indigo palegreen burlywood ivory paleturquoise cadetblue khaki palevioletred chartreuse lavender papayawhip chocolate lavenderblush peachpuff coral lawngreen peru cornflowerblue lemonchiffon pink cornsilk lightblue plum crimson lightcoral powderblue cyan lightcyan purple darkblue lightgoldenrodyellow red darkcyan lightgray rosybrown darkgoldenrod lightgrey royalblue darkgray lightgreen saddlebrown darkgrey lightpink salmon darkgreen lightsalmon sandybrown darkkhaki lightseagreen seagreen darkmagenta lightskyblue seashell darkolivegreen lightslategray sienna darkorange lightslategrey silver darkorchid lightsteelblue skyblue darkred lightyellow slateblue darksalmon lime slategray darkseagreen limegreen slategrey darkslateblue linen snow darkslategray magenta springgreen darkslategrey maroon steelblue darkturquoise mediumaquamarine tan darkviolet mediumblue teal deeppink mediumorchid thistle deepskyblue mediumpurple tomato dimgray mediumseagreen turquoise dimgrey mediumslateblue violet dodgerblue mediumspringgreen wheat firebrick mediumturquoise white floralwhite mediumvioletred whitesmoke forestgreen midnightblue yellow fuchsia mintcream yellowgreen Colors, by default, will act on the foreground. This can be changed by prefixing the color markup by an at-symbol ( @ ), like so: TIM Output \"[78 @34;52;111] My text [inverse] and now inversed! \" text.termage-9 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-9-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } My text and now inversed!","title":"Colors"},{"location":"tim/tags/#clearers","text":"After you set a style, you might want to stop it affecting text. To do so, you want to use a clearer token. Clearer tokens are denoted with the slash ( / ) prefix, and contain the identifier they are targeting. For example: To clear all attributes, including modes, colors, macros, use / with no identifier. To clear a simple terminal mode, use /{mode} , like /italic . To clear a color, use /fg for foreground colors, and /bg for background ones. To clear a macro , use either /!{name} , or /! to clear all active macros. To clear a hyperlink, use /~ . Clearing specific links Since the terminal only supports having one active hyperlink at a time, there is no reason to have syntax for specifically clearing a single link.","title":"Clearers"},{"location":"tim/tags/#hyperlinks","text":"Newer terminals allow HTML anchor-inspired hyperlinks that can be clicked and take the user to places. Resource For information on the implementation of terminal-hyperlinks, check out this gist . In PyTermGUI TIM, we use the syntax: [~{protocol}://{uri}] ...where protocol is a data-transfer protocol supported by the client (usually http , https or file ), and uri is a standard URI readable by the specified protocol. For example: This documentation is hosted as a [~https://ptg.bczsalba.com]subdomain[/~] on my [~https://bczsalba.com]website! ...would create markup equivalent to the HTML: This documentation is hosted as a < a href = \"https://ptg.bczsalba.com\" > subdomain </ a > on my < a href = \"https://bczsalba.com\" > website! </ a >","title":"Hyperlinks"},{"location":"tim/tags/#macros","text":"Info This section details the syntax, but none of the semantics and usage tips, For a more in-depth explanation on macros, see the macro docs . Macros use the syntax: [!{name}({arg1}:{arg2})] ...or the shorthand [!{name}] when there are no arguments passed. In both examples, name is the name the macro is defined as, and arg1 and arg2 are some arguments passed to it. Macro arguments are separated by colons ( : ), in order to clearly visually differentiate them from Python function calls.","title":"Macros"},{"location":"tim/tags/#positioners","text":"You can position text in the terminal using the syntax: [({x};{y})] Where x and y are terminal coordinates, starting from terminal.origin . TIM Output \"[61]This is some normal text[(3;5)]But this part is located somewhere else!\" text.termage-10 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-10-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } This is some normal text But this part is located somewhere else!","title":"Positioners"},{"location":"tim/tags/#pseudo-s","text":"All tags above have behaviour that is \"pre-defined\"; their meaning will be the same in all uses, regardless of context. Pseudo tags are a sort of context-aware group, where they have don't have a consistent meaning: They modify the existing meaning based on the context around them.","title":"Pseudo-s"},{"location":"tim/tags/#auto","text":"It's easier to explain by-example, so here is our first pseudo tag, #auto : Python Output from pytermgui import tim tim . print ( \"[@black #auto]White on black [@white #auto] Black on white\" ) text.termage-11 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-11-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/tim/tags_pseudo1.py White on black Black on white What this tag does is prompt the engine to look around in the current tag group, and inspect the colors set. From then it does the following (simplified): foreground = ... background = ... if foreground is None and background is not None : foreground = get_contrasting_color ( background ) In essence, it looks for any foreground color. If there is None, but there is a background color, it finds a color that contrasts the background (either an off-white or off-black) and applies that to the foreground. You get color-contrast matches that follow the W3C guidelines with just one tag!","title":"Auto"},{"location":"tim/usage/","text":"So the things you read before are all great and all, but where do you apply them? Glad you (definitely) asked! The markup module exports the tim name; this is an instance of MarkupLanguage . tim is going to be your best pal for handling anything related to TIM parsing. Why do we use classes to represent a static language? There are a couple of aspects of TIM that require keeping track of some 'state', e.g. aliases and macros. This state, referred to as context internally, is passed in to all parsing functions to provide the data needed to apply the non-built-in tags. MarkupLanguage keeps track of some context that can be modified with the alias and define methods, and passes this state into every parse* call for you! Fun fact : You can use TIM in most widgets! See the styling docs for more info. Methods Parse The most important method to know about is parse . It takes some TIM string, and returns formatted text to display in the terminal. Python Output from pytermgui import tim print ( tim . parse ( \"[lightgreen]This is some [italic]styled[/italic] text!\" )) text.termage-12 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-12-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/tim/usage_parse.py This is some styled text! Print Since calling print on parsed text every time can get a bit repetitive, we have a helper function to do it for you! Just call print with the same positional and keyword arguments as you would use for the builtin print, and see the magic! You can print non-TIM text with this method as well, but you might wanna use the escape function if you want to make sure to keep things from being parsed. Though at that point, you might as well use the builtin print! Python Output from pytermgui import tim tim . print ( \"[slategrey italic]So much formatting, [!shuffle !upper]where[/!] does it all fit?\" ) text.termage-13 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-13-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/tim/usage_print.py So much formatting, RHWEE DOES IT ALL FIT? Alias As mentioned above, you can modify the TIM parser's state to enable custom behaviour. The first of these is aliasing tags, which essentially makes one tag expand to any other groups of tags while parsing. Warning Alias tags are detected as tags that had no previous meaning, e.g. aren't included in the builtin tags and are not macros. At the moment it is not possible to re-define tags. Python Output from pytermgui import tim tim . alias ( \"my-tag1\" , \"@surface primary+1\" ) # Recursive tags also work! tim . alias ( \"my-tag2\" , \"my-tag1 italic\" ) tim . print ( \"[my-tag1]My first tag \\n\\n \" + \"[/my-tag1]By default, aliases generate an unsetter \\n\\n \" + \"[my-tag2]My second tag\" ) text.termage-14 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-14-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/tim/usage_alias.py My first tag By default, aliases generate an unsetter My second tag Define You can also define macros using the define method. Macros are Python functions you can call from TIM to transform your text. They can only be referenced from TIM, definition must come from the outer Python context. There are a couple of simple macros defined by default, such as !upper , !capitalize and !lower . These are all tied to the respective Python str methods. Python Output from pytermgui import tim tim . print ( \"[!upper]some text\" ) tim . print ( \"[!lower]SOME OTHER TEXT\" ) tim . print ( \"[!gradient(210) italic]Fancy lookin' text\" ) text.termage-15 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-15-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/tim/usage_define1.py SOME TEXT some other text Fan cy loo kin ' t ext A favored example of mine is creating a simple localization layer for your application. You can define a macro, !lang , that is given a localization-id and returns some localized text. This can then be used in any place that TIM is accepted, since it is defined on the global instance. Python Output from pytermgui import tim LANGUAGE = \"en\" TRANSLATIONS = { \"welcome\" : { \"en\" : \"Welcome to the documentation\" , \"hu\" : \"\u00dcdv a dokument\u00e1ci\u00f3ban\" , } } def macro_lang ( key : str ) -> str : translation = TRANSLATIONS . get ( key ) if translation is None : return key return translation [ LANGUAGE ] tim . define ( \"!lang\" , macro_lang ) for LANGUAGE in [ \"en\" , \"hu\" ]: tim . clear_cache () tim . print ( f \"[bold]LANGUAGE: [/ 157] { LANGUAGE !r} \" ) tim . print ( \"--> [!lang]welcome[/!lang]\" ) tim . print () text.termage-16 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-16-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/tim/usage_define2.py LANGUAGE: 'en' --> Welcome to the documentation LANGUAGE: 'hu' --> \u00dcdv a dokument\u00e1ci\u00f3ban","title":"Usage in PTG"},{"location":"tim/usage/#methods","text":"","title":"Methods"},{"location":"tim/usage/#parse","text":"The most important method to know about is parse . It takes some TIM string, and returns formatted text to display in the terminal. Python Output from pytermgui import tim print ( tim . parse ( \"[lightgreen]This is some [italic]styled[/italic] text!\" )) text.termage-12 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-12-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/tim/usage_parse.py This is some styled text!","title":"Parse"},{"location":"tim/usage/#print","text":"Since calling print on parsed text every time can get a bit repetitive, we have a helper function to do it for you! Just call print with the same positional and keyword arguments as you would use for the builtin print, and see the magic! You can print non-TIM text with this method as well, but you might wanna use the escape function if you want to make sure to keep things from being parsed. Though at that point, you might as well use the builtin print! Python Output from pytermgui import tim tim . print ( \"[slategrey italic]So much formatting, [!shuffle !upper]where[/!] does it all fit?\" ) text.termage-13 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-13-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/tim/usage_print.py So much formatting, RHWEE DOES IT ALL FIT?","title":"Print"},{"location":"tim/usage/#alias","text":"As mentioned above, you can modify the TIM parser's state to enable custom behaviour. The first of these is aliasing tags, which essentially makes one tag expand to any other groups of tags while parsing. Warning Alias tags are detected as tags that had no previous meaning, e.g. aren't included in the builtin tags and are not macros. At the moment it is not possible to re-define tags. Python Output from pytermgui import tim tim . alias ( \"my-tag1\" , \"@surface primary+1\" ) # Recursive tags also work! tim . alias ( \"my-tag2\" , \"my-tag1 italic\" ) tim . print ( \"[my-tag1]My first tag \\n\\n \" + \"[/my-tag1]By default, aliases generate an unsetter \\n\\n \" + \"[my-tag2]My second tag\" ) text.termage-14 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-14-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/tim/usage_alias.py My first tag By default, aliases generate an unsetter My second tag","title":"Alias"},{"location":"tim/usage/#define","text":"You can also define macros using the define method. Macros are Python functions you can call from TIM to transform your text. They can only be referenced from TIM, definition must come from the outer Python context. There are a couple of simple macros defined by default, such as !upper , !capitalize and !lower . These are all tied to the respective Python str methods. Python Output from pytermgui import tim tim . print ( \"[!upper]some text\" ) tim . print ( \"[!lower]SOME OTHER TEXT\" ) tim . print ( \"[!gradient(210) italic]Fancy lookin' text\" ) text.termage-15 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-15-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/tim/usage_define1.py SOME TEXT some other text Fan cy loo kin ' t ext A favored example of mine is creating a simple localization layer for your application. You can define a macro, !lang , that is given a localization-id and returns some localized text. This can then be used in any place that TIM is accepted, since it is defined on the global instance. Python Output from pytermgui import tim LANGUAGE = \"en\" TRANSLATIONS = { \"welcome\" : { \"en\" : \"Welcome to the documentation\" , \"hu\" : \"\u00dcdv a dokument\u00e1ci\u00f3ban\" , } } def macro_lang ( key : str ) -> str : translation = TRANSLATIONS . get ( key ) if translation is None : return key return translation [ LANGUAGE ] tim . define ( \"!lang\" , macro_lang ) for LANGUAGE in [ \"en\" , \"hu\" ]: tim . clear_cache () tim . print ( f \"[bold]LANGUAGE: [/ 157] { LANGUAGE !r} \" ) tim . print ( \"--> [!lang]welcome[/!lang]\" ) tim . print () text.termage-16 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-16-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/tim/usage_define2.py LANGUAGE: 'en' --> Welcome to the documentation LANGUAGE: 'hu' --> \u00dcdv a dokument\u00e1ci\u00f3ban","title":"Define"},{"location":"walkthroughs/","text":"This page will host an ever-evolving set of step by step walkthroughs for the library. If you have any suggestions for topics, feel free to raise an issue describing your idea!","title":"Index"},{"location":"walkthroughs/inline/","text":"Our objective today will be to implement a function that lets us use PyTermGUI widgets in an inline-context, e.g. from the terminal prompt while retaining the shell's state. This type of usage is common for simple prompts that are part of a greater, CLI-based application; they give you the cool-factor of the TUI, and in our case its mouse & keyboard input options, while staying in a CLI environment. text.termage-17 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-17-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/inline_login.py lapis: docs * python3 inline_login.py \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502 User information \u2502 \u2502 \u2502 \u2502 Name: Balazs Cene \u2502 \u2502 Password: *********** \u2502 \u2502 \u2502 \u2502 Stay logged in \u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 Defining our goals Our target syntax will be this: prompt_widget = ptg . inline ( built_prompt ()) ...which gives us the general signature: def inline ( widget ): ... return widget Basic implementation Let's start with getting the widget to read keyboard inputs and render after each one of them. To do this, we will sit in a while loop, use the getch function and send its output to our widget's handle_key method. inline.py from pytermgui import getch , Widget def inline ( widget ): while True : key = getch () widget . handle_key ( key ) for line in widget . get_lines (): print ( line ) return widget If you run the above, you will notice 2 things: Pressing Ctrl + C leaves us with an ugly KeyboardInterrupt The widget lines aren't overwritten, but written to the terminal sequentially There is also no mouse interaction, but we'll leave that for later. Implementing clean exits Let's focus on our first problem, relating to the KeyboardInterrupt error. This is trivial to fix; we can tell getch to convert KeyboardInterrupt into the character Ctrl + C sends, and break the loop when we see said character. The reason we need to do this lies deep in the trenches of the terminal, but here is the gist: When Ctrl + C is detected, the \"interrupt\" signal is sent to the current foreground task. This signal (in simple terms) tells the program: Hey there! I think you should stop running. It's important to note that this is not a full hard drop everything you're doing and flee signal. This one is meant to allow programs to clean up after themselves before quitting, which is exactly what we will need to do. Note To see the above in effect, you can try the following code: from time import time while True : try : print ( time ()) except KeyboardInterrupt : pass return widget You will now be unable to leave the program, haha! Just kidding. Press Ctrl + \\ to send the \"kill\" signal to the program, which will stop the loop in its tracks. You can also press Ctrl + L , or type reset into the shell if your terminal got too messed up. I feel like this goes without saying, but: Please do not put inescapable loops into your code Changes Updated file from typing import TypeVar - from pytermgui import getch, Widget + from pytermgui import getch, keys, Widget T = TypeVar(\"T\", bound=Widget) def inline(widget): while True: - key = getch() + key = getch(interrupts=False) + + if key == keys.CTRL_C: + break widget.handle_key(key) for line in widget.get_lines(): print(line) return widget inline.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from typing import TypeVar from pytermgui import getch , keys , Widget T = TypeVar ( \"T\" , bound = Widget ) def inline ( widget ): while True : key = getch ( interrupts = False ) if key == keys . CTRL_C : break widget . handle_key ( key ) for line in widget . get_lines (): print ( line ) return widget If you now run this and press Ctrl + C , you should see the program quit cleanly. Improving printing The print routine above was pretty rudimentary. We can do better! To achieve the 'prompt' look we are aiming for, we need to always start printing at the same location. The simplest way to do this is to use the save_cursor and restore_cursor methods. These tell the terminal to store the current cursor location somewhere, and to move the cursor to the stored location, respectively. Let's start by making the following changes: Changes Updated file from typing import TypeVar - from pytermgui import getch, keys, Widget + from pytermgui import getch, keys, save_cursor, restore_cursor, Widget def inline(widget): while True: key = getch(interrupts=False) if key == keys.CTRL_C: break widget.handle_key(key) + save_cursor() + for line in widget.get_lines(): print(line) + + restore_cursor() return widget inline.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from typing import TypeVar from pytermgui import getch , keys , save_cursor , restore_cursor , Widget def inline ( widget ): while True : key = getch ( interrupts = False ) if key == keys . CTRL_C : break widget . handle_key ( key ) save_cursor () for line in widget . get_lines (): print ( line ) restore_cursor () return widget This fixes the issue, but you may notice our widget only gets printed after the first input. That happens because we call getch before the first prints. Let's fix it, and also move the printing logic into an inner function to make things cleaner: Changes Updated file from typing import TypeVar from pytermgui import getch, keys, save_cursor, restore_cursor, Widget def inline(widget): + def _print_widget(): + save_cursor() + + for line in widget.get_lines(): + print(line) + + restore_cursor() + + _print_widget() + while True: key = getch(interrupts=False) if key == keys.CTRL_C: break widget.handle_key(key) + _print_widget() - save_cursor() - - for line in widget.get_lines(): - print(line) - - restore_cursor() return widget inline.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from typing import TypeVar from pytermgui import getch , keys , save_cursor , restore_cursor , Widget def inline ( widget ): def _print_widget (): save_cursor () for line in widget . get_lines (): print ( line ) restore_cursor () _print_widget () while True : key = getch ( interrupts = False ) if key == keys . CTRL_C : break widget . handle_key ( key ) _print_widget () return widget You may have noticed that when exiting, part of the widget remains on the screen. This is the last print-related issue we need to fix! We can use the clear function with the \"line\" parameter to clear all the affected lines of the terminal. Let's introduce a new inner function, _clear_widget : 15 16 17 18 19 20 21 22 23 def _clear_widget (): save_cursor () for _ in range ( widget . height ): clear ( \"line\" ) terminal . write ( \" \\n \" ) # (1) restore_cursor () terminal . flush () We need to increment the cursor using newlines to make sure we aren't just clearing the same line over and over. To include this, we need to import both clear and terminal . We also probably want to call our new function, specifically before the call to print and at the end of our inline routine. Here is a snapshot of our work so far: Changes Updated file from typing import TypeVar - from pytermgui import getch, keys, save_cursor, restore_cursor, Widget + from pytermgui import ( + getch, + keys, + save_cursor, + restore_cursor, + Widget, + clear, + get_terminal, + ) def inline(widget): + # Make sure we use the global terminal + terminal = get_terminal() + def _print_widget(): save_cursor() for line in widget.get_lines(): print(line) restore_cursor() + def _clear_widget(): + save_cursor() + + for _ in range(widget.height): + clear(\"line\") + terminal.write(\"\\n\") + + restore_cursor() + terminal.flush() _print_widget() while True: key = getch(interrupts=False) if key == keys.CTRL_C: break widget.handle_key(key) + _clear_widget() _print_widget() + + _clear_widget() return widget inline.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 from typing import TypeVar from pytermgui import ( getch , keys , save_cursor , restore_cursor , Widget , clear , get_terminal , ) def inline ( widget ): # Make sure we use the global terminal terminal = get_terminal () def _print_widget (): save_cursor () for line in widget . get_lines (): print ( line ) restore_cursor () def _clear_widget (): save_cursor () for _ in range ( widget . height ): clear ( \"line\" ) terminal . write ( \" \\n \" ) restore_cursor () terminal . flush () _print_widget () while True : key = getch ( interrupts = False ) if key == keys . CTRL_C : break widget . handle_key ( key ) _clear_widget () _print_widget () _clear_widget () return widget And with that, our printing routine is exactly how we want it to be! Now onto the fancy things. Mouse support Traditionally, mouse support is the \"big bad\" enemy of writing terminal programs. However, PyTermGUI makes it a lot easier than you would've thought! The only new thing we will need to import is the mouse_handler context manager. This function does 2 things: Tells the terminal to send mouse events Returns a function that can translate mouse codes into MouseEvent instances To use it, we will wrap our while True loop into the context, and try to handle keys as mouse events when our widget didn't handle them successfully. Each widget denotes \"successful\" event handling by returning True from the given method, so the check will be simple: 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 + with mouse_handler([\"press_hold\", \"hover\"], \"decimal_xterm\") as translate: while True: key = getch(interrupts=False) if key == keys.CTRL_C: break - widget.handle_key(key) + if not widget.handle_key(key): + for event in translate(key): + if event is None: + continue + widget.handle_mouse(event) _clear_widget() _print_widget() _clear_widget() return widget There is a tiny bug with our mouse handling, however. We never tell the widget where it is located, so it will reject most events. We can easily fix this by using the report_mouse and inserting the following line at the top of our function: widget . pos = report_cursor () With the above changes, our file looks like the following: inline.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 from typing import TypeVar from pytermgui import ( getch , keys , save_cursor , restore_cursor , report_cursor , Widget , clear , get_terminal , mouse_handler , ) def inline ( widget ): # Make sure we use the global terminal terminal = get_terminal () widget . pos = report_cursor () def _print_widget (): save_cursor () for line in widget . get_lines (): print ( line ) restore_cursor () def _clear_widget (): save_cursor () for _ in range ( widget . height ): clear ( \"line\" ) terminal . write ( \" \\n \" ) restore_cursor () terminal . flush () _print_widget () with mouse_handler ([ \"press_hold\" , \"hover\" ], \"decimal_xterm\" ) as translate : while True : key = getch ( interrupts = False ) if key == keys . CTRL_C : break if not widget . handle_key ( key ): events = translate ( key ) # Don't try iterating when there are no events if events is None : continue for event in events : if event is None : continue widget . handle_mouse ( event ) _clear_widget () _print_widget () _clear_widget () return widget Congratulations! You just implemented PyTermGUI's inline function! Make sure to look at its source code for the final version of the code we've been working with, along with a few extra improvements, such as handling each the widget's positioned_line_buffer .","title":"Building an inline-widget context"},{"location":"walkthroughs/inline/#defining-our-goals","text":"Our target syntax will be this: prompt_widget = ptg . inline ( built_prompt ()) ...which gives us the general signature: def inline ( widget ): ... return widget","title":"Defining our goals"},{"location":"walkthroughs/inline/#basic-implementation","text":"Let's start with getting the widget to read keyboard inputs and render after each one of them. To do this, we will sit in a while loop, use the getch function and send its output to our widget's handle_key method. inline.py from pytermgui import getch , Widget def inline ( widget ): while True : key = getch () widget . handle_key ( key ) for line in widget . get_lines (): print ( line ) return widget If you run the above, you will notice 2 things: Pressing Ctrl + C leaves us with an ugly KeyboardInterrupt The widget lines aren't overwritten, but written to the terminal sequentially There is also no mouse interaction, but we'll leave that for later.","title":"Basic implementation"},{"location":"walkthroughs/inline/#implementing-clean-exits","text":"Let's focus on our first problem, relating to the KeyboardInterrupt error. This is trivial to fix; we can tell getch to convert KeyboardInterrupt into the character Ctrl + C sends, and break the loop when we see said character. The reason we need to do this lies deep in the trenches of the terminal, but here is the gist: When Ctrl + C is detected, the \"interrupt\" signal is sent to the current foreground task. This signal (in simple terms) tells the program: Hey there! I think you should stop running. It's important to note that this is not a full hard drop everything you're doing and flee signal. This one is meant to allow programs to clean up after themselves before quitting, which is exactly what we will need to do. Note To see the above in effect, you can try the following code: from time import time while True : try : print ( time ()) except KeyboardInterrupt : pass return widget You will now be unable to leave the program, haha! Just kidding. Press Ctrl + \\ to send the \"kill\" signal to the program, which will stop the loop in its tracks. You can also press Ctrl + L , or type reset into the shell if your terminal got too messed up. I feel like this goes without saying, but: Please do not put inescapable loops into your code Changes Updated file from typing import TypeVar - from pytermgui import getch, Widget + from pytermgui import getch, keys, Widget T = TypeVar(\"T\", bound=Widget) def inline(widget): while True: - key = getch() + key = getch(interrupts=False) + + if key == keys.CTRL_C: + break widget.handle_key(key) for line in widget.get_lines(): print(line) return widget inline.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from typing import TypeVar from pytermgui import getch , keys , Widget T = TypeVar ( \"T\" , bound = Widget ) def inline ( widget ): while True : key = getch ( interrupts = False ) if key == keys . CTRL_C : break widget . handle_key ( key ) for line in widget . get_lines (): print ( line ) return widget If you now run this and press Ctrl + C , you should see the program quit cleanly.","title":"Implementing clean exits"},{"location":"walkthroughs/inline/#improving-printing","text":"The print routine above was pretty rudimentary. We can do better! To achieve the 'prompt' look we are aiming for, we need to always start printing at the same location. The simplest way to do this is to use the save_cursor and restore_cursor methods. These tell the terminal to store the current cursor location somewhere, and to move the cursor to the stored location, respectively. Let's start by making the following changes: Changes Updated file from typing import TypeVar - from pytermgui import getch, keys, Widget + from pytermgui import getch, keys, save_cursor, restore_cursor, Widget def inline(widget): while True: key = getch(interrupts=False) if key == keys.CTRL_C: break widget.handle_key(key) + save_cursor() + for line in widget.get_lines(): print(line) + + restore_cursor() return widget inline.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from typing import TypeVar from pytermgui import getch , keys , save_cursor , restore_cursor , Widget def inline ( widget ): while True : key = getch ( interrupts = False ) if key == keys . CTRL_C : break widget . handle_key ( key ) save_cursor () for line in widget . get_lines (): print ( line ) restore_cursor () return widget This fixes the issue, but you may notice our widget only gets printed after the first input. That happens because we call getch before the first prints. Let's fix it, and also move the printing logic into an inner function to make things cleaner: Changes Updated file from typing import TypeVar from pytermgui import getch, keys, save_cursor, restore_cursor, Widget def inline(widget): + def _print_widget(): + save_cursor() + + for line in widget.get_lines(): + print(line) + + restore_cursor() + + _print_widget() + while True: key = getch(interrupts=False) if key == keys.CTRL_C: break widget.handle_key(key) + _print_widget() - save_cursor() - - for line in widget.get_lines(): - print(line) - - restore_cursor() return widget inline.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from typing import TypeVar from pytermgui import getch , keys , save_cursor , restore_cursor , Widget def inline ( widget ): def _print_widget (): save_cursor () for line in widget . get_lines (): print ( line ) restore_cursor () _print_widget () while True : key = getch ( interrupts = False ) if key == keys . CTRL_C : break widget . handle_key ( key ) _print_widget () return widget You may have noticed that when exiting, part of the widget remains on the screen. This is the last print-related issue we need to fix! We can use the clear function with the \"line\" parameter to clear all the affected lines of the terminal. Let's introduce a new inner function, _clear_widget : 15 16 17 18 19 20 21 22 23 def _clear_widget (): save_cursor () for _ in range ( widget . height ): clear ( \"line\" ) terminal . write ( \" \\n \" ) # (1) restore_cursor () terminal . flush () We need to increment the cursor using newlines to make sure we aren't just clearing the same line over and over. To include this, we need to import both clear and terminal . We also probably want to call our new function, specifically before the call to print and at the end of our inline routine. Here is a snapshot of our work so far: Changes Updated file from typing import TypeVar - from pytermgui import getch, keys, save_cursor, restore_cursor, Widget + from pytermgui import ( + getch, + keys, + save_cursor, + restore_cursor, + Widget, + clear, + get_terminal, + ) def inline(widget): + # Make sure we use the global terminal + terminal = get_terminal() + def _print_widget(): save_cursor() for line in widget.get_lines(): print(line) restore_cursor() + def _clear_widget(): + save_cursor() + + for _ in range(widget.height): + clear(\"line\") + terminal.write(\"\\n\") + + restore_cursor() + terminal.flush() _print_widget() while True: key = getch(interrupts=False) if key == keys.CTRL_C: break widget.handle_key(key) + _clear_widget() _print_widget() + + _clear_widget() return widget inline.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 from typing import TypeVar from pytermgui import ( getch , keys , save_cursor , restore_cursor , Widget , clear , get_terminal , ) def inline ( widget ): # Make sure we use the global terminal terminal = get_terminal () def _print_widget (): save_cursor () for line in widget . get_lines (): print ( line ) restore_cursor () def _clear_widget (): save_cursor () for _ in range ( widget . height ): clear ( \"line\" ) terminal . write ( \" \\n \" ) restore_cursor () terminal . flush () _print_widget () while True : key = getch ( interrupts = False ) if key == keys . CTRL_C : break widget . handle_key ( key ) _clear_widget () _print_widget () _clear_widget () return widget And with that, our printing routine is exactly how we want it to be! Now onto the fancy things.","title":"Improving printing"},{"location":"walkthroughs/inline/#mouse-support","text":"Traditionally, mouse support is the \"big bad\" enemy of writing terminal programs. However, PyTermGUI makes it a lot easier than you would've thought! The only new thing we will need to import is the mouse_handler context manager. This function does 2 things: Tells the terminal to send mouse events Returns a function that can translate mouse codes into MouseEvent instances To use it, we will wrap our while True loop into the context, and try to handle keys as mouse events when our widget didn't handle them successfully. Each widget denotes \"successful\" event handling by returning True from the given method, so the check will be simple: 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 + with mouse_handler([\"press_hold\", \"hover\"], \"decimal_xterm\") as translate: while True: key = getch(interrupts=False) if key == keys.CTRL_C: break - widget.handle_key(key) + if not widget.handle_key(key): + for event in translate(key): + if event is None: + continue + widget.handle_mouse(event) _clear_widget() _print_widget() _clear_widget() return widget There is a tiny bug with our mouse handling, however. We never tell the widget where it is located, so it will reject most events. We can easily fix this by using the report_mouse and inserting the following line at the top of our function: widget . pos = report_cursor () With the above changes, our file looks like the following: inline.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 from typing import TypeVar from pytermgui import ( getch , keys , save_cursor , restore_cursor , report_cursor , Widget , clear , get_terminal , mouse_handler , ) def inline ( widget ): # Make sure we use the global terminal terminal = get_terminal () widget . pos = report_cursor () def _print_widget (): save_cursor () for line in widget . get_lines (): print ( line ) restore_cursor () def _clear_widget (): save_cursor () for _ in range ( widget . height ): clear ( \"line\" ) terminal . write ( \" \\n \" ) restore_cursor () terminal . flush () _print_widget () with mouse_handler ([ \"press_hold\" , \"hover\" ], \"decimal_xterm\" ) as translate : while True : key = getch ( interrupts = False ) if key == keys . CTRL_C : break if not widget . handle_key ( key ): events = translate ( key ) # Don't try iterating when there are no events if events is None : continue for event in events : if event is None : continue widget . handle_mouse ( event ) _clear_widget () _print_widget () _clear_widget () return widget","title":"Mouse support"},{"location":"walkthroughs/inline/#congratulations","text":"You just implemented PyTermGUI's inline function! Make sure to look at its source code for the final version of the code we've been working with, along with a few extra improvements, such as handling each the widget's positioned_line_buffer .","title":"Congratulations!"},{"location":"widgets/attrs/","text":"All widgets share a set of attributes that can be used to make things look the way you want. Here is a quick overview on them. Note This API will likely be reformed in the future to be properly controllable through YAML config files. The underlying attributes will remain the same, but the way to access/modify them will be improved. Applicable to all Parent align This attribute can be used to tell a widget's parent to align it left, right or center. Possible values: HorizontalAlignment.LEFT or 0 : Aligns to the left side. HorizontalAlignment.CENTER or 1 : Aligns to the center. HorizontalAlignment.RIGHT or 2 : Aligns to the right. Default: HorizontalAlignment.CENTER Python Output from pytermgui import Container , Label , pretty container = Container ( Label ( \"This is the left\" , parent_align = 0 ), Label ( \"This is the center\" , parent_align = 1 ), Label ( \"This is the right\" , parent_align = 2 ), ) for line in container . get_lines (): print ( line ) text.termage-18 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-18-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/widgets/attrs/parent_align.py \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502 This is the left \u2502 \u2502 This is the center \u2502 \u2502 This is the right \u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 Size policy Widget width adjustments are handled through a system of policies. The basics are: SizePolicy.FILL : The widget will take up the entire width provided by its parent. SizePolicy.STATIC : The widget will remain at a certain width, and its parent will never try to resize it. SizePolicy.RELATIVE : The widget will take up a certain percentage of its parent's width, denoted by a floating point value between 0 and 1. While you can set these manually, it's easier for the both of us if you use the helper properties instead: text.termage-19 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-19-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } def Widget . static_width (self) -> int : Allows for a shorter way of setting a width, and SizePolicy.STATIC. Args: value: The new width integer. Returns: None, as this is setter only. def Widget . relative_width (self) -> float | None : Sets this widget's relative width, and changes size_policy to RELATIVE. The value is clamped to 1.0. If a Container holds a width of 30, and it has a subwidget with a relative width of 0.5, it will be resized to 15. Args: value: The multiplier to apply to the parent's width. Returns: The current relative_width. Default: SizePolicy.FILL Warning SizePolicy.STATIC can cause various issues if the parent widget doesn't have enough width available. If using it, make sure to make sure that the parent will never be smaller than the given widget! Python Output from pytermgui import Container , SizePolicy , pretty container = Container ( Container ( \"I fill the space\" ), Container ( \"I take up 70%\" , relative_width = 0.7 ), Container ( \"I take up exactly \\n 31 characters\" , static_width = 31 ), ) for line in container . get_lines (): print ( line ) text.termage-20 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-20-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/widgets/attrs/size_policy.py \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502 \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502 \u2502 \u2502 I fill the space \u2502 \u2502 \u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 \u2502 \u2502 \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502 \u2502 \u2502 I take up 70% \u2502 \u2502 \u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 \u2502 \u2502 \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502 \u2502 \u2502 I take up exactly \u2502 \u2502 \u2502 \u2502 31 characters \u2502 \u2502 \u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 \u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 Applicable to Container Box The container border and corner characters can be set to a few presets, which are defined in the boxes module. Setting the box attribute to either a Box instance or an upper-cased box name will set both the border and corner characters to those defined by the box. Default: SINGLE for Container , DOUBLE for Window . Python Output from pytermgui import Container , boxes , pretty container = Container ( box = \"EMPTY\" ) for name in [ name for name in dir ( boxes ) if name . isupper ()]: box = getattr ( boxes , name ) container += Container ( f \"[primary] { name } \" , box = box , ) for line in container . get_lines (): print ( line ) text.termage-21 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-21-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/widgets/attrs/box.py ---------------------------------------------------------------------- | BASIC | ---------------------------------------------------------------------- \u2554 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u2557 \u2551 DOUBLE \u2551 \u255a \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u255d \u256d \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u256e \u2502 DOUBLE_BOTTOM \u2502 \u2570 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u256f \u256d \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u256e \u2502 DOUBLE_HORIZONTAL \u2502 \u2570 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u256f \u256d \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u256e \u2551 DOUBLE_SIDES \u2551 \u2570 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u256f \u256d \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u256e \u2502 DOUBLE_TOP \u2502 \u2570 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u256f \u256d \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u256e \u2551 DOUBLE_VERTICAL \u2551 \u2570 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u256f EMPTY \u2502 \u2502 \u2502 EMPTY_HORIZONTAL \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 EMPTY_VERTICAL \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u250f \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 \u2513 \u2503 HEAVY \u2503 \u2517 \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 \u251b \u256d \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u256e \u2502 ROUNDED \u2502 \u2570 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u256f \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502 SINGLE \u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 \u2554 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u2557 \u2502 SINGLE_HORIZONTAL \u2502 \u255a \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u255d \u2554 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2557 \u2551 SINGLE_VERTICAL \u2551 \u255a \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u255d Applicable to Window Note Container's attributes also apply to Window. Title Windows can display text on the top-left corner of their borders. Warning You can only use markup in titles if the given window's corner_style parses TIM. This will always be the case with string-based shorthand styles, but may not be for custom callables. See the styling section for more info! Default: \"\" Python Output from pytermgui import Window window = Window ( \"This is my test window\" ) window . set_title ( \"[surface+2]Welcome to the docs!\" ) text.termage-22 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-22-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/widgets/attrs/title.py \u2554 Welcome to the docs! \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u2557 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 This is my test window \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u255a \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u255d","title":"Attributes to know about"},{"location":"widgets/attrs/#applicable-to-all","text":"","title":"Applicable to all"},{"location":"widgets/attrs/#parent-align","text":"This attribute can be used to tell a widget's parent to align it left, right or center. Possible values: HorizontalAlignment.LEFT or 0 : Aligns to the left side. HorizontalAlignment.CENTER or 1 : Aligns to the center. HorizontalAlignment.RIGHT or 2 : Aligns to the right. Default: HorizontalAlignment.CENTER Python Output from pytermgui import Container , Label , pretty container = Container ( Label ( \"This is the left\" , parent_align = 0 ), Label ( \"This is the center\" , parent_align = 1 ), Label ( \"This is the right\" , parent_align = 2 ), ) for line in container . get_lines (): print ( line ) text.termage-18 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-18-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/widgets/attrs/parent_align.py \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502 This is the left \u2502 \u2502 This is the center \u2502 \u2502 This is the right \u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518","title":"Parent align"},{"location":"widgets/attrs/#size-policy","text":"Widget width adjustments are handled through a system of policies. The basics are: SizePolicy.FILL : The widget will take up the entire width provided by its parent. SizePolicy.STATIC : The widget will remain at a certain width, and its parent will never try to resize it. SizePolicy.RELATIVE : The widget will take up a certain percentage of its parent's width, denoted by a floating point value between 0 and 1. While you can set these manually, it's easier for the both of us if you use the helper properties instead: text.termage-19 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-19-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } def Widget . static_width (self) -> int : Allows for a shorter way of setting a width, and SizePolicy.STATIC. Args: value: The new width integer. Returns: None, as this is setter only. def Widget . relative_width (self) -> float | None : Sets this widget's relative width, and changes size_policy to RELATIVE. The value is clamped to 1.0. If a Container holds a width of 30, and it has a subwidget with a relative width of 0.5, it will be resized to 15. Args: value: The multiplier to apply to the parent's width. Returns: The current relative_width. Default: SizePolicy.FILL Warning SizePolicy.STATIC can cause various issues if the parent widget doesn't have enough width available. If using it, make sure to make sure that the parent will never be smaller than the given widget! Python Output from pytermgui import Container , SizePolicy , pretty container = Container ( Container ( \"I fill the space\" ), Container ( \"I take up 70%\" , relative_width = 0.7 ), Container ( \"I take up exactly \\n 31 characters\" , static_width = 31 ), ) for line in container . get_lines (): print ( line ) text.termage-20 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-20-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/widgets/attrs/size_policy.py \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502 \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502 \u2502 \u2502 I fill the space \u2502 \u2502 \u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 \u2502 \u2502 \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502 \u2502 \u2502 I take up 70% \u2502 \u2502 \u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 \u2502 \u2502 \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502 \u2502 \u2502 I take up exactly \u2502 \u2502 \u2502 \u2502 31 characters \u2502 \u2502 \u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 \u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518","title":"Size policy"},{"location":"widgets/attrs/#applicable-to-container","text":"","title":"Applicable to Container"},{"location":"widgets/attrs/#box","text":"The container border and corner characters can be set to a few presets, which are defined in the boxes module. Setting the box attribute to either a Box instance or an upper-cased box name will set both the border and corner characters to those defined by the box. Default: SINGLE for Container , DOUBLE for Window . Python Output from pytermgui import Container , boxes , pretty container = Container ( box = \"EMPTY\" ) for name in [ name for name in dir ( boxes ) if name . isupper ()]: box = getattr ( boxes , name ) container += Container ( f \"[primary] { name } \" , box = box , ) for line in container . get_lines (): print ( line ) text.termage-21 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-21-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/widgets/attrs/box.py ---------------------------------------------------------------------- | BASIC | ---------------------------------------------------------------------- \u2554 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u2557 \u2551 DOUBLE \u2551 \u255a \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u255d \u256d \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u256e \u2502 DOUBLE_BOTTOM \u2502 \u2570 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u256f \u256d \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u256e \u2502 DOUBLE_HORIZONTAL \u2502 \u2570 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u256f \u256d \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u256e \u2551 DOUBLE_SIDES \u2551 \u2570 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u256f \u256d \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u256e \u2502 DOUBLE_TOP \u2502 \u2570 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u256f \u256d \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u256e \u2551 DOUBLE_VERTICAL \u2551 \u2570 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u256f EMPTY \u2502 \u2502 \u2502 EMPTY_HORIZONTAL \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 EMPTY_VERTICAL \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u250f \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 \u2513 \u2503 HEAVY \u2503 \u2517 \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 \u251b \u256d \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u256e \u2502 ROUNDED \u2502 \u2570 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u256f \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502 SINGLE \u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 \u2554 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u2557 \u2502 SINGLE_HORIZONTAL \u2502 \u255a \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u255d \u2554 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2557 \u2551 SINGLE_VERTICAL \u2551 \u255a \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u255d","title":"Box"},{"location":"widgets/attrs/#applicable-to-window","text":"Note Container's attributes also apply to Window.","title":"Applicable to Window"},{"location":"widgets/attrs/#title","text":"Windows can display text on the top-left corner of their borders. Warning You can only use markup in titles if the given window's corner_style parses TIM. This will always be the case with string-based shorthand styles, but may not be for custom callables. See the styling section for more info! Default: \"\" Python Output from pytermgui import Window window = Window ( \"This is my test window\" ) window . set_title ( \"[surface+2]Welcome to the docs!\" ) text.termage-22 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-22-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/widgets/attrs/title.py \u2554 Welcome to the docs! \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u2557 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 This is my test window \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u255a \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u255d","title":"Title"},{"location":"widgets/builtins/","text":"We provide a growing selection of widgets you can drop straight into your projects. Looking at the widgets submodule's contents can help illuminate you on the exact selection, but this page describes the most commonly used ones. A note about auto Some widgets below will have an Auto syntax field shown. The format shown can be used by the auto function to generate widgets from Python datatypes. This function is conveniently called within Container and all its subclasses ( Splitter , Window , Collapsible & more) to let you easily create widgets with minimal imports. For example: from pytermgui import Container container = Container ( \"[bold accent]This is my example\" , \"\" , \"[surface+1 dim italic]It is very cool, you see\" , \"\" , { \"My first label\" : [ \"Some button\" ]}, { \"My second label\" : [ False ]}, \"\" , ( \"Left side\" , \"Middle\" , \"Right side\" ), \"\" , [ \"Submit button\" ] ) ...is functionally identical to: from pytermgui import Container , Label , Splitter , Button , Checkbox container = Container ( Label ( \"[bold accent]This is my example\" ), Label ( \"\" ), Label ( \"[surface+1 dim italic]It is very cool, you see\" ), Label ( \"\" ), Splitter ( Label ( \"My first label\" , parent_align = 0 ), Button ( \"Some button\" , parent_align = 2 ), ), Splitter ( Label ( \"My second label\" ), Checkbox (), ) Label ( \"\" ), Splitter ( Label ( \"Left side\" ), Label ( \"Middle\" ), Label ( \"Right side\" )) Label ( \"\" ), Button ( \"Submit button\" ), ) You can use whichever you find more convenient and readable. Label A simple widget meant to display text. Supports line breaking and styling using both markup and simple callables. Auto syntax : \"label_value\" Chars : N/A Styles : value : Applies to the text within the label. Default: No styling. Container A widget to display other widgets, stacked vertically. It may display a box around said widgets as well, using the border and corner characters. Auto syntax : N/A Chars : border : A list[str] in the order left, top, right, bottom that makes up the borders of the outer box. corner : A list[str] in the order top_left, top_right, bottom_right, bottom_left that makes up the corners of the outer box. Styles : border : Applies to all border characters of the outer box. Default: surface . corner : Applies to all corner characters of the outer box. Default: surface . fill : Applies to the filler characters used for padding. Default: background . Splitter Similar to Container, but displays widgets stacked horizontally instead. Each widget is separated by the separator character set. Auto syntax : (widget1, widget2, ...) {widget_aligned_left: widget_aligned_right) Chars : separator : The str used to join the contained widgets. Styles : separator : Applies to the separator character. Default: surface . Collapsible A widget that hides or shows whatever other widgets it is given. It will always display its \"trigger\", the Button used to collapse or expand its content. Auto syntax : N/A Chars : See Container . Styles : See Container . Window An extended version of Container , used in the window_manager context. Auto syntax : N/A Chars : See Container . Styles : Same as Container , but expanded with: border_focused : Analogous to border , but only applied when the window is focused. Default: surface . corner_focused : Analogous to corner , but only applied when the window is focused. Default: surface . border_focused : Analogous to border , but only applied when the window is NOT focused. Default: surface-2 . corner_focused : Analogous to corner , but only applied when the window is NOT focused. Default: surface-2 . Button Something clickable. All widgets can be made clickable by defining an on_click method, but this widget looks the part as well. Auto syntax : [\"button_label\", button_callback] Chars : delimiter : a list[str] in the order left, right . Each character will be placed at the respective sides of the label. Styles : All styles here apply to the full label, including the left and right hand side delimiters. label : Applies in the normal state (e.g. no hover, click applied). Default: @surface dim . highlight : Applies when the button is interacted with. Default: @surface+1 dim . KeyboardButton Much like button, but has a default binding applied to it. This binding is also reflected in its label. Auto syntax : N/A Chars : All Button chars bracket : Used to wrap the button's bound key. Styles : See Button . Checkbox A simple check box, you know the drill. Auto syntax : [bool_default, callback_method] Chars : delimiter : Wraps the checkbox's value checked : The character inserted between delimiters when the widget is checked. unchecked : The character inserted between delimiters when the widget is un checked. Styles : See Button . Toggle A button that toggles its label between the two given values. Auto syntax : [(\"label_1\", \"label_2\"), callback_method] Chars : See Button . Styles : See Button . Slider A widget to display and/or control a floating point value. Auto syntax : N/A Chars : cursor : The character placed at the end of the filled section. If nothing is given, rail is used. rail : Used to fill up the width of the slider, colored as applicable. delimiter : Wraps the rail characters on both sides. Styles : cursor : Applied to the cursor character, or the last character of the rail. Default: primary . filled : Applied to the filled section of the rail if the slider is not selected. Default: surface+1 . filled_selected : Applied to the filled section of the rail if the slider is selected. Default: primary . unfilled : Applied to the unfilled section of the rail if the slider is not selected. Default: surface-1 . unfilled_selected : Applied to the unfilled section of the rail if the slider is selected. Default: surface . InputField A field to display input. Should be used in a context that sends it keyboard inputs, such as WindowManager . Auto syntax : N/A Chars : N/A Styles : value : Applies to the text of the input field. Default: No styling. prompt : Applies to the string displayed before the field's value, controlled by the prompt parameter. Default: surface+2 cursor : Applies to the field's cursor. Default: @primary dim #auto PixelMatrix A customizable matrix of unicode pixels. With some image decoding, it can be used to display low-resolution pictures. Auto syntax : N/A Chars : N/A Styles : N/A DensePixelMatrix Similar to PixelMatrix , but instead of using two unicode block characters per pixel, it uses either the upper or lower half of one. Allows for higher resolution pictures! Auto syntax : N/A Chars : See PixelMatrix Styles : See PixelMatrix","title":"The batteries included"},{"location":"widgets/builtins/#a-note-about-auto","text":"Some widgets below will have an Auto syntax field shown. The format shown can be used by the auto function to generate widgets from Python datatypes. This function is conveniently called within Container and all its subclasses ( Splitter , Window , Collapsible & more) to let you easily create widgets with minimal imports. For example: from pytermgui import Container container = Container ( \"[bold accent]This is my example\" , \"\" , \"[surface+1 dim italic]It is very cool, you see\" , \"\" , { \"My first label\" : [ \"Some button\" ]}, { \"My second label\" : [ False ]}, \"\" , ( \"Left side\" , \"Middle\" , \"Right side\" ), \"\" , [ \"Submit button\" ] ) ...is functionally identical to: from pytermgui import Container , Label , Splitter , Button , Checkbox container = Container ( Label ( \"[bold accent]This is my example\" ), Label ( \"\" ), Label ( \"[surface+1 dim italic]It is very cool, you see\" ), Label ( \"\" ), Splitter ( Label ( \"My first label\" , parent_align = 0 ), Button ( \"Some button\" , parent_align = 2 ), ), Splitter ( Label ( \"My second label\" ), Checkbox (), ) Label ( \"\" ), Splitter ( Label ( \"Left side\" ), Label ( \"Middle\" ), Label ( \"Right side\" )) Label ( \"\" ), Button ( \"Submit button\" ), ) You can use whichever you find more convenient and readable.","title":"A note about auto"},{"location":"widgets/builtins/#label","text":"A simple widget meant to display text. Supports line breaking and styling using both markup and simple callables. Auto syntax : \"label_value\" Chars : N/A Styles : value : Applies to the text within the label. Default: No styling.","title":"Label"},{"location":"widgets/builtins/#container","text":"A widget to display other widgets, stacked vertically. It may display a box around said widgets as well, using the border and corner characters. Auto syntax : N/A Chars : border : A list[str] in the order left, top, right, bottom that makes up the borders of the outer box. corner : A list[str] in the order top_left, top_right, bottom_right, bottom_left that makes up the corners of the outer box. Styles : border : Applies to all border characters of the outer box. Default: surface . corner : Applies to all corner characters of the outer box. Default: surface . fill : Applies to the filler characters used for padding. Default: background .","title":"Container"},{"location":"widgets/builtins/#splitter","text":"Similar to Container, but displays widgets stacked horizontally instead. Each widget is separated by the separator character set. Auto syntax : (widget1, widget2, ...) {widget_aligned_left: widget_aligned_right) Chars : separator : The str used to join the contained widgets. Styles : separator : Applies to the separator character. Default: surface .","title":"Splitter"},{"location":"widgets/builtins/#collapsible","text":"A widget that hides or shows whatever other widgets it is given. It will always display its \"trigger\", the Button used to collapse or expand its content. Auto syntax : N/A Chars : See Container . Styles : See Container .","title":"Collapsible"},{"location":"widgets/builtins/#window","text":"An extended version of Container , used in the window_manager context. Auto syntax : N/A Chars : See Container . Styles : Same as Container , but expanded with: border_focused : Analogous to border , but only applied when the window is focused. Default: surface . corner_focused : Analogous to corner , but only applied when the window is focused. Default: surface . border_focused : Analogous to border , but only applied when the window is NOT focused. Default: surface-2 . corner_focused : Analogous to corner , but only applied when the window is NOT focused. Default: surface-2 .","title":"Window"},{"location":"widgets/builtins/#button","text":"Something clickable. All widgets can be made clickable by defining an on_click method, but this widget looks the part as well. Auto syntax : [\"button_label\", button_callback] Chars : delimiter : a list[str] in the order left, right . Each character will be placed at the respective sides of the label. Styles : All styles here apply to the full label, including the left and right hand side delimiters. label : Applies in the normal state (e.g. no hover, click applied). Default: @surface dim . highlight : Applies when the button is interacted with. Default: @surface+1 dim .","title":"Button"},{"location":"widgets/builtins/#keyboardbutton","text":"Much like button, but has a default binding applied to it. This binding is also reflected in its label. Auto syntax : N/A Chars : All Button chars bracket : Used to wrap the button's bound key. Styles : See Button .","title":"KeyboardButton"},{"location":"widgets/builtins/#checkbox","text":"A simple check box, you know the drill. Auto syntax : [bool_default, callback_method] Chars : delimiter : Wraps the checkbox's value checked : The character inserted between delimiters when the widget is checked. unchecked : The character inserted between delimiters when the widget is un checked. Styles : See Button .","title":"Checkbox"},{"location":"widgets/builtins/#toggle","text":"A button that toggles its label between the two given values. Auto syntax : [(\"label_1\", \"label_2\"), callback_method] Chars : See Button . Styles : See Button .","title":"Toggle"},{"location":"widgets/builtins/#slider","text":"A widget to display and/or control a floating point value. Auto syntax : N/A Chars : cursor : The character placed at the end of the filled section. If nothing is given, rail is used. rail : Used to fill up the width of the slider, colored as applicable. delimiter : Wraps the rail characters on both sides. Styles : cursor : Applied to the cursor character, or the last character of the rail. Default: primary . filled : Applied to the filled section of the rail if the slider is not selected. Default: surface+1 . filled_selected : Applied to the filled section of the rail if the slider is selected. Default: primary . unfilled : Applied to the unfilled section of the rail if the slider is not selected. Default: surface-1 . unfilled_selected : Applied to the unfilled section of the rail if the slider is selected. Default: surface .","title":"Slider"},{"location":"widgets/builtins/#inputfield","text":"A field to display input. Should be used in a context that sends it keyboard inputs, such as WindowManager . Auto syntax : N/A Chars : N/A Styles : value : Applies to the text of the input field. Default: No styling. prompt : Applies to the string displayed before the field's value, controlled by the prompt parameter. Default: surface+2 cursor : Applies to the field's cursor. Default: @primary dim #auto","title":"InputField"},{"location":"widgets/builtins/#pixelmatrix","text":"A customizable matrix of unicode pixels. With some image decoding, it can be used to display low-resolution pictures. Auto syntax : N/A Chars : N/A Styles : N/A","title":"PixelMatrix"},{"location":"widgets/builtins/#densepixelmatrix","text":"Similar to PixelMatrix , but instead of using two unicode block characters per pixel, it uses either the upper or lower half of one. Allows for higher resolution pictures! Auto syntax : N/A Chars : See PixelMatrix Styles : See PixelMatrix","title":"DensePixelMatrix"},{"location":"widgets/custom/","text":"While the default widgets are pretty nifty themselves, sometimes you might wanna do your own thing. Luckily for you, PyTermGUI's Widget API is ridiculously easy to build upon! What to know Firstly, you should know some things about the shape and function of various parts of the API. Output & rendering The most important method to a widget is its get_lines . This returns a list of strings, which is what is used to eventually display it in the terminal. This method is called a healthy amount, so you probably wanna make all state changes in some other place, so get_lines can request mostly static data. Selectables Each widget can be made selectable by either setting widget._selectables_length to a non-zero value, or overwriting the selectables_length property of said widget. If you want to make parent widgets know that your widget can be selected, you can just define _selectables_length as 1. If you have multiple inner-widgets you need to handle selecting, you should inherit from Container and let it handle all the plumbing for you. If you're interested in how it does all that magic, see it's selectables property, and its select method. Input handling Both keyboard and mouse inputs are cascaded down from the WindowManager to each widget. A widget can mark some input as \"handled\" and stop it from cascading further by having its handler method return True . Note The base Widget class may go through some routines for each input, such as calling any widget bindings, or, in the case of mouse inputs, call semantic handlers. Because of this, and to ensure future backwards-compatibility (weird phrase, I know), you should start all your input handlers by calling the parent class' handler: class MyWidget ( Widget ): def handle_key ( self , key : str ) -> bool : if super () . handle_key ( key ): return # Do our own handling Keyboard input The signature of the keyboard handler is pretty simple: def handle_key ( self , key : str ) -> bool To compare key codes to canonical names (e.g. CTRL_B to \\x02 ), you can use the keys singleton: from pytermgui import Widget , keys class MyWidget ( Widget ): def handle_key ( self , key : str ) -> bool : if super () . handle_key ( key ): return True if key == keys . CTRL_F : self . do_something () return True return False Mouse input While terminal mouse inputs are historically pretty hard to handle, PTG offers a simple interface to hide all that paperwork. An interface symmetrical to the keyboard handlers exists, and is the base of all that comes below: def handle_mouse ( self , event : MouseEvent ) -> bool : The only argument is the event , which is an instance of MouseEvent . This is what it looks like: text.termage-23 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-23-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } inspect(MouseEvent) \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502 pytermgui.ansi_interface.MouseEvent \u2502 \u2502 Located in /Users/lapis/Code/Projects/pytermgui/pytermgui/ansi_interface.py \u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 class MouseEvent (action: MouseAction , position: tuple [ int , int ]) -> None : A class to represent events created by mouse actions. Its first argument is a `MouseAction` describing what happened, and its second argument is a `tuple[int, int]` describing where it happened. This class mostly exists for readability & typing reasons. It also implements the iterable protocol, so you can use the unpacking syntax, such as: ```python3 action, position = MouseEvent(...) ``` def is_primary (self) -> bool : Returns True if event.action is one of the primary (left-button) actions. def is_scroll (self) -> bool : Returns True if event.action is one of the scrolling actions. def is_secondary (self) -> bool : Returns True if event.action is one of the secondary (secondary-button) a ctions. Depending on your circumstances, you can test the event's position or action attributes: from pytermgui import Widget , MouseEvent , MouseAction class MyWidget ( Widget ): def handle_mouse ( self , event : MouseEvent ) -> bool : if super () . handle_mouse ( event ): return True if event . action == MouseAction . LEFT_CLICK : self . do_something () Since comparing against actions gets a li'l tedious over time, we have a system called semantic mouse handlers to help you. These are optional methods that are looked for when Widget is handling some mouse event, and only called when present. They all follow the syntax on_{event_name} . events can be one of: [ \"left_click\" , \"right_click\" , \"click\" , \"left_drag\" , \"right_drag\" , \"drag\" , \"scroll_up\" , \"scroll_down\" , \"scroll\" , \"shift_scroll_up\" , \"shift_scroll_down\" , \"shift_scroll\" , \"hover\" , ] Handler methods are looked for in the order of highest specifity. For example, the following widget: from pytermgui import MouseEvent , Widget class MyWidget ( Widget ): label : str = \"No action\" def get_lines ( self ) -> list [ str ]: return [ self . label ] def on_left_click ( self , event : MouseEvent ) -> bool : self . label = \"Left click\" return True def on_click ( self , event : MouseEvent ) -> bool : self . label = \"Generic click\" return True def handle_mouse ( self , event : MouseEvent ) -> bool : # Make sure we call the super handler if super () . handle_mouse ( event ): return True self . label = \"No action\" return True ...will display Left click only on left clicks, Generic click only on right clicks (as on_right_click isn't defined) and No action on any other mouse input. FAQ How do I dynamically update a widget's content? The pattern I've come to adopt for this purpose is based on a regularly updated inner state that gets displayed within get_lines . For example, let's say we have a Weather widget that regularly requests weather information and displays it. Here is how I would do it. Take extra notice of the highlighted lines: Python Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 from dataclasses import dataclass from threading import Thread from time import sleep from pytermgui import Container , StyleManager , real_length , tim @dataclass class WeatherData : state : str wind : str clouds : str class Weather ( Container ): # We want to retain the Container styles, so we merge in some new ones styles = StyleManager . merge ( Container . styles , sunny = \"yellow\" , cloudy = \"grey\" , rainy = \"darkblue\" , snowy = \"snow\" , detail = \"245\" , ) # Same story as above; unpacking into sets allows us to merge 2 dicts! chars = { ** Container . chars , ** { \"sunny\" : \"\u2600\" , \"cloudy\" : \"\u2601\" , \"rainy\" : \"\u2602\" , \"snowy\" : \"\u2603\" , }, } def __init__ ( self , location : str , timeout : int , ** attrs ) -> None : super () . __init__ ( ** attrs ) self . location = location self . timeout = timeout Thread ( target = self . _monitor_loop , daemon = True ) . start () def _request_data ( self ) -> WeatherData : ... def _monitor_loop ( self ) -> None : while True : self . data = self . _request_data () self . update_content () sleep ( self . timeout ) def update_content ( self ) -> None : state = self . data . state style = self . styles [ state ] char = self . _get_char ( state ) icon = style ( char ) self . set_widgets ( [ f \" { icon } It is currently { state } in { self . location } . { icon } \" , \"\" , f \" { self . styles . detail ( 'Wind' ) } : { self . data . wind } \" , f \" { self . styles . detail ( 'Clouds' ) } : { self . data . clouds } \" , ] ) text.termage-24 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-24-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/widgets/weather.py \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502 \u2600 It is currently sunny in Los Angeles. \u2600 \u2502 \u2502 \u2502 \u2502 Wind : 15kph N/W \u2502 \u2502 Clouds : scattered \u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 As you can see, I made the widget inherit Container . This is usually what you want when dealing with a widget that: Contains inner content representable by sub-widgets ( Label in our case) Has to periodically update said inner content We also use a thread to do all the monitoring & updating, instead of doing it in get_lines or some other periodically called method. Since get_lines is called very regularly, and its time-to-return is critical for the rendering of an application, we need to make sure to avoid putting anything with noticable delays in there. Don't overuse threads If you have multiple widgets that run on a thread-based monitor, you are likely better of creating a single master thread that updates every widget periodically. A simple monitor implementation like the following should work alright: from __future__ import annotations from dataclasses import dataclass , field from threading import Thread from time import sleep , time from typing import Callable @dataclass class Listener : callback : Callable [[], None ] period : float time_till_next : float @dataclass class Monitor : update_frequency : float = 0.5 listeners : list [ Listener ] = field ( default_factory = list ) def attach ( self , callback : Callable [[], None ], * , period : float ) -> Listener : listener = Listener ( callback , period , period ) self . listeners . append ( listener ) return listener def start ( self ) -> Monitor : def _monitor () -> None : previous = time () while True : elapsed = time () - previous for listener in self . listeners : listener . time_till_next -= elapsed if listener . time_till_next <= 0.0 : listener . callback () listener . time_till_next = listener . period previous = time () sleep ( self . update_frequency ) Thread ( target = _monitor ) . start () return self You can then use this in your widgets: from .monitor import Monitor from pytermgui import Container monitor = Monitor () . start () class Weather ( Container ): def __init__ ( self , location : str , timeout : float , ** attrs : Any ) -> None : ... # Standard init code (see above) monitor . attach ( self . _request_and_update , timeout ) def _request_and_update ( self ) -> None : self . data = self . _request () self . update_content () Let's talk about those highlighted lines, shall we? In the first set of lines we send out a request to the (imaginary) external API, and update ourselves accordingly. This update is done in the second set of lines, where the set_widgets method is used to overwrite the current widget selection. Why use this method instead of manually overwriting _widgets ? The reason this method was created in the first place was to simplify the process of: Emptying the container's widgets Resetting its height Going through a list, running auto on each item and adding it to the container It makes things a lot simpler, and it also accounts for any future oddities that mess with the process!","title":"Create your own"},{"location":"widgets/custom/#what-to-know","text":"Firstly, you should know some things about the shape and function of various parts of the API.","title":"What to know"},{"location":"widgets/custom/#output-rendering","text":"The most important method to a widget is its get_lines . This returns a list of strings, which is what is used to eventually display it in the terminal. This method is called a healthy amount, so you probably wanna make all state changes in some other place, so get_lines can request mostly static data.","title":"Output &amp; rendering"},{"location":"widgets/custom/#selectables","text":"Each widget can be made selectable by either setting widget._selectables_length to a non-zero value, or overwriting the selectables_length property of said widget. If you want to make parent widgets know that your widget can be selected, you can just define _selectables_length as 1. If you have multiple inner-widgets you need to handle selecting, you should inherit from Container and let it handle all the plumbing for you. If you're interested in how it does all that magic, see it's selectables property, and its select method.","title":"Selectables"},{"location":"widgets/custom/#input-handling","text":"Both keyboard and mouse inputs are cascaded down from the WindowManager to each widget. A widget can mark some input as \"handled\" and stop it from cascading further by having its handler method return True . Note The base Widget class may go through some routines for each input, such as calling any widget bindings, or, in the case of mouse inputs, call semantic handlers. Because of this, and to ensure future backwards-compatibility (weird phrase, I know), you should start all your input handlers by calling the parent class' handler: class MyWidget ( Widget ): def handle_key ( self , key : str ) -> bool : if super () . handle_key ( key ): return # Do our own handling","title":"Input handling"},{"location":"widgets/custom/#keyboard-input","text":"The signature of the keyboard handler is pretty simple: def handle_key ( self , key : str ) -> bool To compare key codes to canonical names (e.g. CTRL_B to \\x02 ), you can use the keys singleton: from pytermgui import Widget , keys class MyWidget ( Widget ): def handle_key ( self , key : str ) -> bool : if super () . handle_key ( key ): return True if key == keys . CTRL_F : self . do_something () return True return False","title":"Keyboard input"},{"location":"widgets/custom/#mouse-input","text":"While terminal mouse inputs are historically pretty hard to handle, PTG offers a simple interface to hide all that paperwork. An interface symmetrical to the keyboard handlers exists, and is the base of all that comes below: def handle_mouse ( self , event : MouseEvent ) -> bool : The only argument is the event , which is an instance of MouseEvent . This is what it looks like: text.termage-23 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-23-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } inspect(MouseEvent) \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502 pytermgui.ansi_interface.MouseEvent \u2502 \u2502 Located in /Users/lapis/Code/Projects/pytermgui/pytermgui/ansi_interface.py \u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 class MouseEvent (action: MouseAction , position: tuple [ int , int ]) -> None : A class to represent events created by mouse actions. Its first argument is a `MouseAction` describing what happened, and its second argument is a `tuple[int, int]` describing where it happened. This class mostly exists for readability & typing reasons. It also implements the iterable protocol, so you can use the unpacking syntax, such as: ```python3 action, position = MouseEvent(...) ``` def is_primary (self) -> bool : Returns True if event.action is one of the primary (left-button) actions. def is_scroll (self) -> bool : Returns True if event.action is one of the scrolling actions. def is_secondary (self) -> bool : Returns True if event.action is one of the secondary (secondary-button) a ctions. Depending on your circumstances, you can test the event's position or action attributes: from pytermgui import Widget , MouseEvent , MouseAction class MyWidget ( Widget ): def handle_mouse ( self , event : MouseEvent ) -> bool : if super () . handle_mouse ( event ): return True if event . action == MouseAction . LEFT_CLICK : self . do_something () Since comparing against actions gets a li'l tedious over time, we have a system called semantic mouse handlers to help you. These are optional methods that are looked for when Widget is handling some mouse event, and only called when present. They all follow the syntax on_{event_name} . events can be one of: [ \"left_click\" , \"right_click\" , \"click\" , \"left_drag\" , \"right_drag\" , \"drag\" , \"scroll_up\" , \"scroll_down\" , \"scroll\" , \"shift_scroll_up\" , \"shift_scroll_down\" , \"shift_scroll\" , \"hover\" , ] Handler methods are looked for in the order of highest specifity. For example, the following widget: from pytermgui import MouseEvent , Widget class MyWidget ( Widget ): label : str = \"No action\" def get_lines ( self ) -> list [ str ]: return [ self . label ] def on_left_click ( self , event : MouseEvent ) -> bool : self . label = \"Left click\" return True def on_click ( self , event : MouseEvent ) -> bool : self . label = \"Generic click\" return True def handle_mouse ( self , event : MouseEvent ) -> bool : # Make sure we call the super handler if super () . handle_mouse ( event ): return True self . label = \"No action\" return True ...will display Left click only on left clicks, Generic click only on right clicks (as on_right_click isn't defined) and No action on any other mouse input.","title":"Mouse input"},{"location":"widgets/custom/#faq","text":"","title":"FAQ"},{"location":"widgets/custom/#how-do-i-dynamically-update-a-widgets-content","text":"The pattern I've come to adopt for this purpose is based on a regularly updated inner state that gets displayed within get_lines . For example, let's say we have a Weather widget that regularly requests weather information and displays it. Here is how I would do it. Take extra notice of the highlighted lines: Python Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 from dataclasses import dataclass from threading import Thread from time import sleep from pytermgui import Container , StyleManager , real_length , tim @dataclass class WeatherData : state : str wind : str clouds : str class Weather ( Container ): # We want to retain the Container styles, so we merge in some new ones styles = StyleManager . merge ( Container . styles , sunny = \"yellow\" , cloudy = \"grey\" , rainy = \"darkblue\" , snowy = \"snow\" , detail = \"245\" , ) # Same story as above; unpacking into sets allows us to merge 2 dicts! chars = { ** Container . chars , ** { \"sunny\" : \"\u2600\" , \"cloudy\" : \"\u2601\" , \"rainy\" : \"\u2602\" , \"snowy\" : \"\u2603\" , }, } def __init__ ( self , location : str , timeout : int , ** attrs ) -> None : super () . __init__ ( ** attrs ) self . location = location self . timeout = timeout Thread ( target = self . _monitor_loop , daemon = True ) . start () def _request_data ( self ) -> WeatherData : ... def _monitor_loop ( self ) -> None : while True : self . data = self . _request_data () self . update_content () sleep ( self . timeout ) def update_content ( self ) -> None : state = self . data . state style = self . styles [ state ] char = self . _get_char ( state ) icon = style ( char ) self . set_widgets ( [ f \" { icon } It is currently { state } in { self . location } . { icon } \" , \"\" , f \" { self . styles . detail ( 'Wind' ) } : { self . data . wind } \" , f \" { self . styles . detail ( 'Clouds' ) } : { self . data . clouds } \" , ] ) text.termage-24 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-24-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/widgets/weather.py \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502 \u2600 It is currently sunny in Los Angeles. \u2600 \u2502 \u2502 \u2502 \u2502 Wind : 15kph N/W \u2502 \u2502 Clouds : scattered \u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 As you can see, I made the widget inherit Container . This is usually what you want when dealing with a widget that: Contains inner content representable by sub-widgets ( Label in our case) Has to periodically update said inner content We also use a thread to do all the monitoring & updating, instead of doing it in get_lines or some other periodically called method. Since get_lines is called very regularly, and its time-to-return is critical for the rendering of an application, we need to make sure to avoid putting anything with noticable delays in there. Don't overuse threads If you have multiple widgets that run on a thread-based monitor, you are likely better of creating a single master thread that updates every widget periodically. A simple monitor implementation like the following should work alright: from __future__ import annotations from dataclasses import dataclass , field from threading import Thread from time import sleep , time from typing import Callable @dataclass class Listener : callback : Callable [[], None ] period : float time_till_next : float @dataclass class Monitor : update_frequency : float = 0.5 listeners : list [ Listener ] = field ( default_factory = list ) def attach ( self , callback : Callable [[], None ], * , period : float ) -> Listener : listener = Listener ( callback , period , period ) self . listeners . append ( listener ) return listener def start ( self ) -> Monitor : def _monitor () -> None : previous = time () while True : elapsed = time () - previous for listener in self . listeners : listener . time_till_next -= elapsed if listener . time_till_next <= 0.0 : listener . callback () listener . time_till_next = listener . period previous = time () sleep ( self . update_frequency ) Thread ( target = _monitor ) . start () return self You can then use this in your widgets: from .monitor import Monitor from pytermgui import Container monitor = Monitor () . start () class Weather ( Container ): def __init__ ( self , location : str , timeout : float , ** attrs : Any ) -> None : ... # Standard init code (see above) monitor . attach ( self . _request_and_update , timeout ) def _request_and_update ( self ) -> None : self . data = self . _request () self . update_content () Let's talk about those highlighted lines, shall we? In the first set of lines we send out a request to the (imaginary) external API, and update ourselves accordingly. This update is done in the second set of lines, where the set_widgets method is used to overwrite the current widget selection. Why use this method instead of manually overwriting _widgets ? The reason this method was created in the first place was to simplify the process of: Emptying the container's widgets Resetting its height Going through a list, running auto on each item and adding it to the container It makes things a lot simpler, and it also accounts for any future oddities that mess with the process!","title":"How do I dynamically update a widget's content?"},{"location":"widgets/styling/","text":"All built in widgets use a central color palette , referencable within TIM code. Each widget will use appropriate shades of the palette by default. Since this palette is defined globally, you can also re-generate it with new colors. It only requires a primary color, but you may give it as many as you please. Here is the default palette: text.termage-25 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-25-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } pytermgui/palettes.py -3 -2 -1 primary +1 +2 +3 #313a53 #4a587c #6375a6 #7c93d0 #96a8d9 #b0bee2 #cad3ec -3 -2 -1 secondary +1 +2 +3 #53313a #7c4957 #a66274 #d07b92 #d995a7 #e2afbd #eccad3 -3 -2 -1 tertiary +1 +2 +3 #3a5331 #587c49 #75a662 #93d07b #a8d995 #bee2af #d3ecca -3 -2 -1 accent +1 +2 +3 #534a31 #7c6f49 #a69462 #d0b97b #d9c795 #e2d5af #ece3ca -3 -2 -1 surface +1 +2 +3 #191a20 #252830 #323540 #3f4350 #656873 #8b8e96 #b2b3b9 -3 -2 -1 surface2 +1 +2 +3 #20191a #302528 #403235 #503f43 #736568 #968b8e #b9b2b3 -3 -2 -1 surface3 +1 +2 +3 #1a2019 #283025 #354032 #43503f #687365 #8e968b #b3b9b2 -3 -2 -1 surface4 +1 +2 +3 #201e19 #302d25 #403c32 #504b3f #736f65 #96938b #b9b7b2 -3 -2 -1 success +1 +2 +3 #2b533c #417c5a #57a678 #6dd097 #8ad9ab #a7e2c0 #c4ecd5 -3 -2 -1 warning +1 +2 +3 #505035 #787950 #a0a16b #c9ca86 #d3d49e #dedfb6 #e9e9ce -3 -2 -1 error +1 +2 +3 #503035 #784950 #a0616b #c97a86 #d3949e #deafb6 #e9c9ce As you can see, each color name has a set of negatively and positively shaded variants. These can be accessed in the format: {color_name}{shade_offset} , such as primary+2 or surface2-1 . The \"main\" color can be referred to without an offset, like accent or success . Each color also has a background variant assigned to it, which may be used by prefixing the color-of-interest by an at symbol ( @ ), like @error or @secondary+3 . Warning Since the underlying colors may change between runs, it's best to make sure contrast ratios are met at all times. This is possible in PTG using the #auto markup pseudo-tag. As mentioned later, the library will try to append this tag to any widget style without a set foreground color. To use it outside of a widget (or to make absolute certain that it applies), add it to your markup: Python Output from pytermgui import tim tim . alias_multiple ( ** { \"@my-surface1\" : \"@white\" , \"@my-surface2\" : \"@black\" }) tim . print ( \"[@my-surface1 #auto] Black on white [@my-surface2 #auto] White on black \" ) text.termage-26 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-26-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } Black on white White on black Styling widgets As mentioned above, all widgets come with a basic, aesthetically pleasing set of styles. Sometimes though, you might wanna get a fresher look. Modifying the palette The easiest way to change up the look of your apps is by manipulating the global palette. This will change the colors of all built-in widgets, and all custom ones (so long as they use the palette colors). This can be done using the Palette.regenerate method: from pytermgui import palette palette . regenerate ( primary = \"skyblue\" ) Under the hood, it will look at the given color, and generate some complementaries for it. The above code gives use the following palette, by the way: text.termage-27 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-27-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } -3 -2 -1 primary +1 +2 +3 #36525e #517b8d #6ca4bc #87ceeb #9fd7ef #b7e1f3 #cfebf7 -3 -2 -1 secondary +1 +2 +3 #5e3652 #8d517b #bc6ca4 #eb87cd #ef9fd7 #f3b7e1 #f7cfeb -3 -2 -1 tertiary +1 +2 +3 #525e36 #7b8d51 #a4bc6c #ceeb87 #d7ef9f #e1f3b7 #ebf7cf -3 -2 -1 accent +1 +2 +3 #5e4136 #8d6251 #bc836c #eba487 #efb69f #f3c8b7 #f7dacf -3 -2 -1 surface +1 +2 +3 #1a1f22 #272f33 #343f44 #414f55 #677277 #8d9599 #b3b8bb -3 -2 -1 surface2 +1 +2 +3 #221a1f #33272f #44343f #55414f #776772 #998d95 #bbb3b8 -3 -2 -1 surface3 +1 +2 +3 #1f221a #2f3327 #3f4434 #4f5541 #727767 #95998d #b8bbb3 -3 -2 -1 surface4 +1 +2 +3 #221c1a #332a27 #443834 #554741 #776b67 #99908d #bbb5b3 -3 -2 -1 success +1 +2 +3 #2c5a3f #43875f #59b47f #70e29f #8ce7b2 #a9edc5 #c5f3d8 -3 -2 -1 warning +1 +2 +3 #525838 #7b8455 #a4b071 #cddc8e #d7e3a4 #e1eabb #ebf1d1 -3 -2 -1 error +1 +2 +3 #523838 #7b5455 #a47071 #cd8c8e #d7a3a4 #e1babb #ebd1d1 Note Using highly saturated colors as for the primary color will likely result in harsh looking styles. Even if you are tied to a certain neon-looking HEX color, it is usually nicer to use some toned-down version of it as the primary, and possibly including it as the secondary , tertiary or accent arguments. Modifying styles If just changing the base colors isn't enough, you can add more involved styles on a per-widget basis. Assigning styles is done through each widget's StyleManager , which can be accessed using widget.styles . Properties can be set in a couple of ways. The simplest one uses the dot syntax: widget . styles . label = my_style You may also assign styles in the same statement as a widget's creation if you are pressed on space, by calling the styles property with a set of keyword arguments: widget = MyWidget () . style ( label = my_style ) Finally, it is possible to assign multiple styles to the same value in one statement. This can be done by separating each key with 2 underscore characters, and works for either of the above methods: widget . styles . border__corner = my_border_style widget2 = MyWidget () . styles ( border__corner = my_border_style ) All the above examples modify styles pre-defined by the widget at declaration time. To see all the built-in styles, see the section on built-in widgets . Values for these calls can be of 2 general types: TIM string shorthands The easier way to create custom styles is by defining some markup for them. A fully expanded markup string contains both the {depth} and {item} template keys, but it can be shortened and expanded automatically for convenience. item must be in the final style string. It represents the string that was passed for styling. depth is not necessary to use; it represents the given widget's depth property. For example, surface+2 italic dim would be expanded into [surface+2 italic dim]{item} , while [!gradient(210) bold]{item} would remain untouched. Info Under the hood, these strings will create MarkupFormatter instances, which perform the formatting and parsing when called. TL;DR: This method is only syntactic sugar over the one below. Custom callables For more granular control of a style, one may use a callable. These follow the following signature: def my_style ( depth : int , item : str ) -> str : ...where depth is an integer related to the styled widget, and item is the text in need of styling. The return of this is always assumed to be parsed, ANSI-coded text. This method is far more powerful than just using template string, but it's also a lot more noisy to write. Here is a cool button style: from pytermgui import Button , Container , pretty , tim template = \"[@primary #auto] {first} [@surface-1 #auto] {second} \" def split_style ( _ : int , item : str ) -> str : if \"<SPLIT>\" not in item : return item first , second = item . split ( \"<SPLIT>\" ) return tim . parse ( template . format ( first = first , second = second )) Button . styles . label = split_style Button . set_char ( \"delimiter\" , [ \"\" ] * 2 ) my_button = Button ( \"Hey<SPLIT>There\" ) pretty . print ( my_button ) This gives the following result. See the #auto tag setting valid foregrounds for both light and dark backgrounds: text.termage-28 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-28-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/widgets/style_callables.py Button (label= \"Hey<SPLIT>There\" , padding= 0 , centered= False ) Hey There","title":"Palettes & styling"},{"location":"widgets/styling/#styling-widgets","text":"As mentioned above, all widgets come with a basic, aesthetically pleasing set of styles. Sometimes though, you might wanna get a fresher look.","title":"Styling widgets"},{"location":"widgets/styling/#modifying-the-palette","text":"The easiest way to change up the look of your apps is by manipulating the global palette. This will change the colors of all built-in widgets, and all custom ones (so long as they use the palette colors). This can be done using the Palette.regenerate method: from pytermgui import palette palette . regenerate ( primary = \"skyblue\" ) Under the hood, it will look at the given color, and generate some complementaries for it. The above code gives use the following palette, by the way: text.termage-27 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-27-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } -3 -2 -1 primary +1 +2 +3 #36525e #517b8d #6ca4bc #87ceeb #9fd7ef #b7e1f3 #cfebf7 -3 -2 -1 secondary +1 +2 +3 #5e3652 #8d517b #bc6ca4 #eb87cd #ef9fd7 #f3b7e1 #f7cfeb -3 -2 -1 tertiary +1 +2 +3 #525e36 #7b8d51 #a4bc6c #ceeb87 #d7ef9f #e1f3b7 #ebf7cf -3 -2 -1 accent +1 +2 +3 #5e4136 #8d6251 #bc836c #eba487 #efb69f #f3c8b7 #f7dacf -3 -2 -1 surface +1 +2 +3 #1a1f22 #272f33 #343f44 #414f55 #677277 #8d9599 #b3b8bb -3 -2 -1 surface2 +1 +2 +3 #221a1f #33272f #44343f #55414f #776772 #998d95 #bbb3b8 -3 -2 -1 surface3 +1 +2 +3 #1f221a #2f3327 #3f4434 #4f5541 #727767 #95998d #b8bbb3 -3 -2 -1 surface4 +1 +2 +3 #221c1a #332a27 #443834 #554741 #776b67 #99908d #bbb5b3 -3 -2 -1 success +1 +2 +3 #2c5a3f #43875f #59b47f #70e29f #8ce7b2 #a9edc5 #c5f3d8 -3 -2 -1 warning +1 +2 +3 #525838 #7b8455 #a4b071 #cddc8e #d7e3a4 #e1eabb #ebf1d1 -3 -2 -1 error +1 +2 +3 #523838 #7b5455 #a47071 #cd8c8e #d7a3a4 #e1babb #ebd1d1 Note Using highly saturated colors as for the primary color will likely result in harsh looking styles. Even if you are tied to a certain neon-looking HEX color, it is usually nicer to use some toned-down version of it as the primary, and possibly including it as the secondary , tertiary or accent arguments.","title":"Modifying the palette"},{"location":"widgets/styling/#modifying-styles","text":"If just changing the base colors isn't enough, you can add more involved styles on a per-widget basis. Assigning styles is done through each widget's StyleManager , which can be accessed using widget.styles . Properties can be set in a couple of ways. The simplest one uses the dot syntax: widget . styles . label = my_style You may also assign styles in the same statement as a widget's creation if you are pressed on space, by calling the styles property with a set of keyword arguments: widget = MyWidget () . style ( label = my_style ) Finally, it is possible to assign multiple styles to the same value in one statement. This can be done by separating each key with 2 underscore characters, and works for either of the above methods: widget . styles . border__corner = my_border_style widget2 = MyWidget () . styles ( border__corner = my_border_style ) All the above examples modify styles pre-defined by the widget at declaration time. To see all the built-in styles, see the section on built-in widgets . Values for these calls can be of 2 general types:","title":"Modifying styles"},{"location":"widgets/styling/#tim-string-shorthands","text":"The easier way to create custom styles is by defining some markup for them. A fully expanded markup string contains both the {depth} and {item} template keys, but it can be shortened and expanded automatically for convenience. item must be in the final style string. It represents the string that was passed for styling. depth is not necessary to use; it represents the given widget's depth property. For example, surface+2 italic dim would be expanded into [surface+2 italic dim]{item} , while [!gradient(210) bold]{item} would remain untouched. Info Under the hood, these strings will create MarkupFormatter instances, which perform the formatting and parsing when called. TL;DR: This method is only syntactic sugar over the one below.","title":"TIM string shorthands"},{"location":"widgets/styling/#custom-callables","text":"For more granular control of a style, one may use a callable. These follow the following signature: def my_style ( depth : int , item : str ) -> str : ...where depth is an integer related to the styled widget, and item is the text in need of styling. The return of this is always assumed to be parsed, ANSI-coded text. This method is far more powerful than just using template string, but it's also a lot more noisy to write. Here is a cool button style: from pytermgui import Button , Container , pretty , tim template = \"[@primary #auto] {first} [@surface-1 #auto] {second} \" def split_style ( _ : int , item : str ) -> str : if \"<SPLIT>\" not in item : return item first , second = item . split ( \"<SPLIT>\" ) return tim . parse ( template . format ( first = first , second = second )) Button . styles . label = split_style Button . set_char ( \"delimiter\" , [ \"\" ] * 2 ) my_button = Button ( \"Hey<SPLIT>There\" ) pretty . print ( my_button ) This gives the following result. See the #auto tag setting valid foregrounds for both light and dark backgrounds: text.termage-28 { font-size: 15px; font-family: Menlo, 'DejaVu Sans Mono', consolas, 'Courier New', monospace; font-feature-settings: normal; /* Inline SVGs are `antialiased` by default, while `src=`-d ones are `auto`.*/ -webkit-font-smoothing: auto; } .termage-28-title { font-family: 'arial'; fill: #94999A; font-size: 13px; font-weight: bold; } docs/src/widgets/style_callables.py Button (label= \"Hey<SPLIT>There\" , padding= 0 , centered= False ) Hey There","title":"Custom callables"}]}